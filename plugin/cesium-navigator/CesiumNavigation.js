/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CesiumNavigation"] = factory();
	else
		root["CesiumNavigation"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./viewerCesiumNavigationMixin.js":
/*!******************************************************!*\
  !*** ./viewerCesiumNavigationMixin.js + 104 modules ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ viewerCesiumNavigationMixin_0)\n});\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/defined.js\n/**\n * @function\n *\n * @param {*} value The object.\n * @returns {Boolean} Returns true if the object is defined, returns false otherwise.\n *\n * @example\n * if (Cesium.defined(positions)) {\n *      doSomething();\n * } else {\n *      doSomethingElse();\n * }\n */\nfunction defined(value) {\n  return value !== undefined && value !== null;\n}\n/* harmony default export */ const Core_defined = (defined);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/DeveloperError.js\n\n\n/**\n * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,\n * argument out of range, etc.  This exception should only be thrown during development;\n * it usually indicates a bug in the calling code.  This exception should never be\n * caught; instead the calling code should strive not to generate it.\n * <br /><br />\n * On the other hand, a {@link RuntimeError} indicates an exception that may\n * be thrown at runtime, e.g., out of memory, that the calling code should be prepared\n * to catch.\n *\n * @alias DeveloperError\n * @constructor\n * @extends Error\n *\n * @param {String} [message] The error message for this exception.\n *\n * @see RuntimeError\n */\nfunction DeveloperError(message) {\n  /**\n   * 'DeveloperError' indicating that this exception was thrown due to a developer error.\n   * @type {String}\n   * @readonly\n   */\n  this.name = \"DeveloperError\";\n\n  /**\n   * The explanation for why this exception was thrown.\n   * @type {String}\n   * @readonly\n   */\n  this.message = message;\n\n  //Browsers such as IE don't have a stack property until you actually throw the error.\n  let stack;\n  try {\n    throw new Error();\n  } catch (e) {\n    stack = e.stack;\n  }\n\n  /**\n   * The stack trace of this exception, if available.\n   * @type {String}\n   * @readonly\n   */\n  this.stack = stack;\n}\n\nif (Core_defined(Object.create)) {\n  DeveloperError.prototype = Object.create(Error.prototype);\n  DeveloperError.prototype.constructor = DeveloperError;\n}\n\nDeveloperError.prototype.toString = function () {\n  let str = `${this.name}: ${this.message}`;\n\n  if (Core_defined(this.stack)) {\n    str += `\\n${this.stack.toString()}`;\n  }\n\n  return str;\n};\n\n/**\n * @private\n */\nDeveloperError.throwInstantiationError = function () {\n  throw new DeveloperError(\n    \"This function defines an interface and should not be called directly.\"\n  );\n};\n/* harmony default export */ const Core_DeveloperError = (DeveloperError);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Check.js\n\n\n\n/**\n * Contains functions for checking that supplied arguments are of a specified type\n * or meet specified conditions\n * @private\n */\nconst Check = {};\n\n/**\n * Contains type checking functions, all using the typeof operator\n */\nCheck.typeOf = {};\n\nfunction getUndefinedErrorMessage(name) {\n  return `${name} is required, actual value was undefined`;\n}\n\nfunction getFailedTypeErrorMessage(actual, expected, name) {\n  return `Expected ${name} to be typeof ${expected}, actual typeof was ${actual}`;\n}\n\n/**\n * Throws if test is not defined\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value that is to be checked\n * @exception {DeveloperError} test must be defined\n */\nCheck.defined = function (name, test) {\n  if (!Core_defined(test)) {\n    throw new Core_DeveloperError(getUndefinedErrorMessage(name));\n  }\n};\n\n/**\n * Throws if test is not typeof 'function'\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'function'\n */\nCheck.typeOf.func = function (name, test) {\n  if (typeof test !== \"function\") {\n    throw new Core_DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"function\", name)\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'string'\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'string'\n */\nCheck.typeOf.string = function (name, test) {\n  if (typeof test !== \"string\") {\n    throw new Core_DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"string\", name)\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number'\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'number'\n */\nCheck.typeOf.number = function (name, test) {\n  if (typeof test !== \"number\") {\n    throw new Core_DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"number\", name)\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and less than limit\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {Number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and less than limit\n */\nCheck.typeOf.number.lessThan = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test >= limit) {\n    throw new Core_DeveloperError(\n      `Expected ${name} to be less than ${limit}, actual value was ${test}`\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and less than or equal to limit\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {Number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and less than or equal to limit\n */\nCheck.typeOf.number.lessThanOrEquals = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test > limit) {\n    throw new Core_DeveloperError(\n      `Expected ${name} to be less than or equal to ${limit}, actual value was ${test}`\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and greater than limit\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {Number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and greater than limit\n */\nCheck.typeOf.number.greaterThan = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test <= limit) {\n    throw new Core_DeveloperError(\n      `Expected ${name} to be greater than ${limit}, actual value was ${test}`\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and greater than or equal to limit\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {Number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and greater than or equal to limit\n */\nCheck.typeOf.number.greaterThanOrEquals = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test < limit) {\n    throw new Core_DeveloperError(\n      `Expected ${name} to be greater than or equal to ${limit}, actual value was ${test}`\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'object'\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'object'\n */\nCheck.typeOf.object = function (name, test) {\n  if (typeof test !== \"object\") {\n    throw new Core_DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"object\", name)\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'boolean'\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'boolean'\n */\nCheck.typeOf.bool = function (name, test) {\n  if (typeof test !== \"boolean\") {\n    throw new Core_DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"boolean\", name)\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'bigint'\n *\n * @param {String} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'bigint'\n */\nCheck.typeOf.bigint = function (name, test) {\n  if (typeof test !== \"bigint\") {\n    throw new Core_DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"bigint\", name)\n    );\n  }\n};\n\n/**\n * Throws if test1 and test2 is not typeof 'number' and not equal in value\n *\n * @param {String} name1 The name of the first variable being tested\n * @param {String} name2 The name of the second variable being tested against\n * @param {*} test1 The value to test\n * @param {*} test2 The value to test against\n * @exception {DeveloperError} test1 and test2 should be type of 'number' and be equal in value\n */\nCheck.typeOf.number.equals = function (name1, name2, test1, test2) {\n  Check.typeOf.number(name1, test1);\n  Check.typeOf.number(name2, test2);\n  if (test1 !== test2) {\n    throw new Core_DeveloperError(\n      `${name1} must be equal to ${name2}, the actual values are ${test1} and ${test2}`\n    );\n  }\n};\n/* harmony default export */ const Core_Check = (Check);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Event.js\n\n\n\n/**\n * A generic utility class for managing subscribers for a particular event.\n * This class is usually instantiated inside of a container class and\n * exposed as a property for others to subscribe to.\n *\n * @alias Event\n * @template Listener extends (...args: any[]) => void = (...args: any[]) => void\n * @constructor\n * @example\n * MyObject.prototype.myListener = function(arg1, arg2) {\n *     this.myArg1Copy = arg1;\n *     this.myArg2Copy = arg2;\n * }\n *\n * const myObjectInstance = new MyObject();\n * const evt = new Cesium.Event();\n * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);\n * evt.raiseEvent('1', '2');\n * evt.removeEventListener(MyObject.prototype.myListener);\n */\nfunction Event() {\n  this._listeners = [];\n  this._scopes = [];\n  this._toRemove = [];\n  this._insideRaiseEvent = false;\n}\n\nObject.defineProperties(Event.prototype, {\n  /**\n   * The number of listeners currently subscribed to the event.\n   * @memberof Event.prototype\n   * @type {Number}\n   * @readonly\n   */\n  numberOfListeners: {\n    get: function () {\n      return this._listeners.length - this._toRemove.length;\n    },\n  },\n});\n\n/**\n * Registers a callback function to be executed whenever the event is raised.\n * An optional scope can be provided to serve as the <code>this</code> pointer\n * in which the function will execute.\n *\n * @param {Listener} listener The function to be executed when the event is raised.\n * @param {Object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {Event.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#raiseEvent\n * @see Event#removeEventListener\n */\nEvent.prototype.addEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n\n  this._listeners.push(listener);\n  this._scopes.push(scope);\n\n  const event = this;\n  return function () {\n    event.removeEventListener(listener, scope);\n  };\n};\n\n/**\n * Unregisters a previously registered callback.\n *\n * @param {Listener} listener The function to be unregistered.\n * @param {Object} [scope] The scope that was originally passed to addEventListener.\n * @returns {Boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.\n *\n * @see Event#addEventListener\n * @see Event#raiseEvent\n */\nEvent.prototype.removeEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n\n  const listeners = this._listeners;\n  const scopes = this._scopes;\n\n  let index = -1;\n  for (let i = 0; i < listeners.length; i++) {\n    if (listeners[i] === listener && scopes[i] === scope) {\n      index = i;\n      break;\n    }\n  }\n\n  if (index !== -1) {\n    if (this._insideRaiseEvent) {\n      //In order to allow removing an event subscription from within\n      //a callback, we don't actually remove the items here.  Instead\n      //remember the index they are at and undefined their value.\n      this._toRemove.push(index);\n      listeners[index] = undefined;\n      scopes[index] = undefined;\n    } else {\n      listeners.splice(index, 1);\n      scopes.splice(index, 1);\n    }\n    return true;\n  }\n\n  return false;\n};\n\nfunction compareNumber(a, b) {\n  return b - a;\n}\n\n/**\n * Raises the event by calling each registered listener with all supplied arguments.\n *\n * @param {...Parameters<Listener>} arguments This method takes any number of parameters and passes them through to the listener functions.\n *\n * @see Event#addEventListener\n * @see Event#removeEventListener\n */\nEvent.prototype.raiseEvent = function () {\n  this._insideRaiseEvent = true;\n\n  let i;\n  const listeners = this._listeners;\n  const scopes = this._scopes;\n  let length = listeners.length;\n\n  for (i = 0; i < length; i++) {\n    const listener = listeners[i];\n    if (Core_defined(listener)) {\n      listeners[i].apply(scopes[i], arguments);\n    }\n  }\n\n  //Actually remove items removed in removeEventListener.\n  const toRemove = this._toRemove;\n  length = toRemove.length;\n  if (length > 0) {\n    toRemove.sort(compareNumber);\n    for (i = 0; i < length; i++) {\n      const index = toRemove[i];\n      listeners.splice(index, 1);\n      scopes.splice(index, 1);\n    }\n    toRemove.length = 0;\n  }\n\n  this._insideRaiseEvent = false;\n};\n\n/**\n * A function that removes a listener.\n * @callback Event.RemoveCallback\n */\n\n/* harmony default export */ const Core_Event = (Event);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/ThirdParty/knockout-3.5.1.js\nvar oldValue;\nif (typeof ko !== 'undefined') {\n    oldValue = ko;\n}\n\n(function(){\n/*!\n * Knockout JavaScript library v3.5.1\n * (c) The Knockout.js team - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n\n(function() {(function(n){var A=this||(0,eval)(\"this\"),w=A.document,R=A.navigator,v=A.jQuery,H=A.JSON;v||\"undefined\"===typeof jQuery||(v=jQuery);(function(n){n(A.ko={})})(function(S,T){function K(a,c){return null===a||typeof a in W?a===c:!1}function X(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function Y(b,c){var d;return function(){clearTimeout(d);\nd=a.a.setTimeout(b,c)}}function Z(a,c){c&&\"change\"!==c?\"beforeChange\"===c?this.pc(a):this.gb(a,c):this.qc(a)}function aa(a,c){null!==c&&c.s&&c.s()}function ba(a,c){var d=this.qd,e=d[r];e.ra||(this.Qb&&this.mb[c]?(d.uc(c,a,this.mb[c]),this.mb[c]=null,--this.Qb):e.I[c]||d.uc(c,a,e.J?{da:a}:d.$c(a)),a.Ja&&a.gd())}var a=\"undefined\"!==typeof S?S:{};a.b=function(b,c){for(var d=b.split(\".\"),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.L=function(a,c,d){a[c]=d};a.version=\"3.5.1\";a.b(\"version\",\na.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1,foreachHidesDestroyed:!1};a.a=function(){function b(a,b){for(var c in a)f.call(a,c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)f.call(b,c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var l=b[c].match(q)||[];a.a.D(d.match(q),function(b){a.a.Na(l,b,e)});b[c]=l.join(\" \")}var f=Object.prototype.hasOwnProperty,g={__proto__:[]}instanceof Array,h=\"function\"===typeof Symbol,m={},k={};m[R&&/Firefox\\/2/i.test(R.userAgent)?\n\"KeyboardEvent\":\"UIEvents\"]=[\"keyup\",\"keydown\",\"keypress\"];m.MouseEvents=\"click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave\".split(\" \");b(m,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)k[b[c]]=a});var l={propertychange:!0},p=w&&function(){for(var a=3,b=w.createElement(\"div\"),c=b.getElementsByTagName(\"i\");b.innerHTML=\"\\x3c!--[if gt IE \"+ ++a+\"]><i></i><![endif]--\\x3e\",c[0];);return 4<a?a:n}(),q=/\\S+/g,t;return{Jc:[\"authenticity_token\",/^__RequestVerificationToken(_.*)?$/],\nD:function(a,b,c){for(var d=0,e=a.length;d<e;d++)b.call(c,a[d],d,a)},A:\"function\"==typeof Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b)}:function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Lb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d,a))return a[d];return n},Pa:function(b,c){var d=a.a.A(b,c);0<d?b.splice(d,1):0===d&&b.shift()},wc:function(b){var c=[];b&&a.a.D(b,function(b){0>a.a.A(c,b)&&c.push(b)});return c},Mb:function(a,\nb,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)d.push(b.call(c,a[e],e));return d},jb:function(a,b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)b.call(c,a[e],e)&&d.push(a[e]);return d},Nb:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},Na:function(b,c,d){var e=a.a.A(a.a.bc(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},Ba:g,extend:c,setPrototypeOf:d,Ab:g?d:c,P:b,Ga:function(a,b,c){if(!a)return a;var d={},e;for(e in a)f.call(a,e)&&(d[e]=\nb.call(c,a[e],e,a));return d},Tb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},Yb:function(b){b=a.a.la(b);for(var c=(b[0]&&b[0].ownerDocument||w).createElement(\"div\"),d=0,e=b.length;d<e;d++)c.appendChild(a.oa(b[d]));return c},Ca:function(b,c){for(var d=0,e=b.length,l=[];d<e;d++){var k=b[d].cloneNode(!0);l.push(c?a.oa(k):k)}return l},va:function(b,c){a.a.Tb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},Xc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],\nl=e.parentNode,k=0,f=c.length;k<f;k++)l.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k])}},Ua:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d)}}return a},Zc:function(a,b){7>p?a.setAttribute(\"selected\",b):a.selected=b},Db:function(a){return null===a||a===n?\"\":a.trim?\na.trim():a.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,\"\")},Ud:function(a,b){a=a||\"\";return b.length>a.length?!1:a.substring(0,b.length)===b},vd:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(1!==a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return!!a},Sb:function(b){return a.a.vd(b,b.ownerDocument.documentElement)},kd:function(b){return!!a.a.Lb(b,a.a.Sb)},R:function(a){return a&&\na.tagName&&a.tagName.toLowerCase()},Ac:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Ac(b),c)},Gc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},B:function(b,c,d){var e=a.a.Ac(d);d=l[c];if(a.options.useOnlyNativeEvents||d||!v)if(d||\"function\"!=typeof b.addEventListener)if(\"undefined\"!=typeof b.attachEvent){var k=function(a){e.call(b,a)},f=\"on\"+c;b.attachEvent(f,\nk);a.a.K.za(b,function(){b.detachEvent(f,k)})}else throw Error(\"Browser doesn't support addEventListener or attachEvent\");else b.addEventListener(c,e,!1);else t||(t=\"function\"==typeof v(b).on?\"on\":\"bind\"),v(b)[t](c,e)},Fb:function(b,c){if(!b||!b.nodeType)throw Error(\"element must be a DOM node when calling triggerEvent\");var d;\"input\"===a.a.R(b)&&b.type&&\"click\"==c.toLowerCase()?(d=b.type,d=\"checkbox\"==d||\"radio\"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if(\"function\"==typeof w.createEvent)if(\"function\"==\ntypeof b.dispatchEvent)d=w.createEvent(k[c]||\"HTMLEvents\"),d.initEvent(c,!0,!0,A,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error(\"The supplied element doesn't support dispatchEvent\");else if(d&&b.click)b.click();else if(\"undefined\"!=typeof b.fireEvent)b.fireEvent(\"on\"+c);else throw Error(\"Browser doesn't support triggering events\");else v(b).trigger(c)},f:function(b){return a.O(b)?b():b},bc:function(b){return a.O(b)?b.v():b},Eb:function(b,c,d){var l;c&&(\"object\"===typeof b.classList?\n(l=b.classList[d?\"add\":\"remove\"],a.a.D(c.match(q),function(a){l.call(b.classList,a)})):\"string\"===typeof b.className.baseVal?e(b.className,\"baseVal\",c,d):e(b,\"className\",c,d))},Bb:function(b,c){var d=a.a.f(c);if(null===d||d===n)d=\"\";var e=a.h.firstChild(b);!e||3!=e.nodeType||a.h.nextSibling(e)?a.h.va(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Ad(b)},Yc:function(a,b){a.name=b;if(7>=p)try{var c=a.name.replace(/[&<>'\"]/g,function(a){return\"&#\"+a.charCodeAt(0)+\";\"});a.mergeAttributes(w.createElement(\"<input name='\"+\nc+\"'/>\"),!1)}catch(d){}},Ad:function(a){9<=p&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},wd:function(a){if(p){var b=a.style.width;a.style.width=0;a.style.width=b}},Pd:function(b,c){b=a.a.f(b);c=a.a.f(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},la:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Da:function(a){return h?Symbol(a):a},Zd:6===p,$d:7===p,W:p,Lc:function(b,c){for(var d=a.a.la(b.getElementsByTagName(\"input\")).concat(a.a.la(b.getElementsByTagName(\"textarea\"))),\ne=\"string\"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},l=[],k=d.length-1;0<=k;k--)e(d[k])&&l.push(d[k]);return l},Nd:function(b){return\"string\"==typeof b&&(b=a.a.Db(b))?H&&H.parse?H.parse(b):(new Function(\"return \"+b))():null},hc:function(b,c,d){if(!H||!H.stringify)throw Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");\nreturn H.stringify(a.a.f(b),c,d)},Od:function(c,d,e){e=e||{};var l=e.params||{},k=e.includeFields||this.Jc,f=c;if(\"object\"==typeof c&&\"form\"===a.a.R(c))for(var f=c.action,h=k.length-1;0<=h;h--)for(var g=a.a.Lc(c,k[h]),m=g.length-1;0<=m;m--)l[g[m].name]=g[m].value;d=a.a.f(d);var p=w.createElement(\"form\");p.style.display=\"none\";p.action=f;p.method=\"post\";for(var q in d)c=w.createElement(\"input\"),c.type=\"hidden\",c.name=q,c.value=a.a.hc(a.a.f(d[q])),p.appendChild(c);b(l,function(a,b){var c=w.createElement(\"input\");\nc.type=\"hidden\";c.name=a;c.value=b;p.appendChild(c)});w.body.appendChild(p);e.submitter?e.submitter(p):p.submit();setTimeout(function(){p.parentNode.removeChild(p)},0)}}}();a.b(\"utils\",a.a);a.b(\"utils.arrayForEach\",a.a.D);a.b(\"utils.arrayFirst\",a.a.Lb);a.b(\"utils.arrayFilter\",a.a.jb);a.b(\"utils.arrayGetDistinctValues\",a.a.wc);a.b(\"utils.arrayIndexOf\",a.a.A);a.b(\"utils.arrayMap\",a.a.Mb);a.b(\"utils.arrayPushAll\",a.a.Nb);a.b(\"utils.arrayRemoveItem\",a.a.Pa);a.b(\"utils.cloneNodes\",a.a.Ca);a.b(\"utils.createSymbolOrString\",\na.a.Da);a.b(\"utils.extend\",a.a.extend);a.b(\"utils.fieldsIncludedWithJsonPost\",a.a.Jc);a.b(\"utils.getFormFields\",a.a.Lc);a.b(\"utils.objectMap\",a.a.Ga);a.b(\"utils.peekObservable\",a.a.bc);a.b(\"utils.postJson\",a.a.Od);a.b(\"utils.parseJson\",a.a.Nd);a.b(\"utils.registerEventHandler\",a.a.B);a.b(\"utils.stringifyJson\",a.a.hc);a.b(\"utils.range\",a.a.Pd);a.b(\"utils.toggleDomNodeCssClass\",a.a.Eb);a.b(\"utils.triggerEvent\",a.a.Fb);a.b(\"utils.unwrapObservable\",a.a.f);a.b(\"utils.objectForEach\",a.a.P);a.b(\"utils.addOrRemoveItem\",\na.a.Na);a.b(\"utils.setTextContent\",a.a.Bb);a.b(\"unwrap\",a.a.f);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.g=new function(){var b=0,c=\"__ko__\"+(new Date).getTime(),d={},e,f;a.a.W?(e=function(a,e){var f=a[c];if(!f||\"null\"===f||!d[f]){if(!e)return n;f=a[c]=\"ko\"+b++;d[f]=\n{}}return d[f]},f=function(a){var b=a[c];return b?(delete d[b],a[c]=null,!0):!1}):(e=function(a,b){var d=a[c];!d&&b&&(d=a[c]={});return d},f=function(a){return a[c]?(delete a[c],!0):!1});return{get:function(a,b){var c=e(a,!1);return c&&c[b]},set:function(a,b,c){(a=e(a,c!==n))&&(a[b]=c)},Ub:function(a,b,c){a=e(a,!0);return a[b]||(a[b]=c)},clear:f,Z:function(){return b++ +c}}};a.b(\"utils.domData\",a.a.g);a.b(\"utils.domData.clear\",a.a.g.clear);a.a.K=new function(){function b(b,c){var d=a.a.g.get(b,e);\nd===n&&c&&(d=[],a.a.g.set(b,e,d));return d}function c(c){var e=b(c,!1);if(e)for(var e=e.slice(0),k=0;k<e.length;k++)e[k](c);a.a.g.clear(c);a.a.K.cleanExternalData(c);g[c.nodeType]&&d(c.childNodes,!0)}function d(b,d){for(var e=[],l,f=0;f<b.length;f++)if(!d||8===b[f].nodeType)if(c(e[e.length]=l=b[f]),b[f]!==l)for(;f--&&-1==a.a.A(e,b[f]););}var e=a.a.g.Z(),f={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{za:function(a,c){if(\"function\"!=typeof c)throw Error(\"Callback must be a function\");b(a,!0).push(c)},yb:function(c,\nd){var f=b(c,!1);f&&(a.a.Pa(f,d),0==f.length&&a.a.g.set(c,e,n))},oa:function(b){a.u.G(function(){f[b.nodeType]&&(c(b),g[b.nodeType]&&d(b.getElementsByTagName(\"*\")))});return b},removeNode:function(b){a.oa(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){v&&\"function\"==typeof v.cleanData&&v.cleanData([a])}}};a.oa=a.a.K.oa;a.removeNode=a.a.K.removeNode;a.b(\"cleanNode\",a.oa);a.b(\"removeNode\",a.removeNode);a.b(\"utils.domNodeDisposal\",a.a.K);a.b(\"utils.domNodeDisposal.addDisposeCallback\",\na.a.K.za);a.b(\"utils.domNodeDisposal.removeDisposeCallback\",a.a.K.yb);(function(){var b=[0,\"\",\"\"],c=[1,\"<table>\",\"</table>\"],d=[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],e=[1,\"<select multiple='multiple'>\",\"</select>\"],f={thead:c,tbody:c,tfoot:c,tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:d,th:d,option:e,optgroup:e},g=8>=a.a.W;a.a.ua=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else{if((e=v.clean([c],d))&&e[0]){for(var l=e[0];l.parentNode&&11!==l.parentNode.nodeType;)l=l.parentNode;\nl.parentNode&&l.parentNode.removeChild(l)}}else{(e=d)||(e=w);var l=e.parentWindow||e.defaultView||A,p=a.a.Db(c).toLowerCase(),q=e.createElement(\"div\"),t;t=(p=p.match(/^(?:\\x3c!--.*?--\\x3e\\s*?)*?<([a-z]+)[\\s>]/))&&f[p[1]]||b;p=t[0];t=\"ignored<div>\"+t[1]+c+t[2]+\"</div>\";\"function\"==typeof l.innerShiv?q.appendChild(l.innerShiv(t)):(g&&e.body.appendChild(q),q.innerHTML=t,g&&q.parentNode.removeChild(q));for(;p--;)q=q.lastChild;e=a.a.la(q.lastChild.childNodes)}return e};a.a.Md=function(b,c){var d=a.a.ua(b,\nc);return d.length&&d[0].parentElement||a.a.Yb(d)};a.a.fc=function(b,c){a.a.Tb(b);c=a.a.f(c);if(null!==c&&c!==n)if(\"string\"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ua(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b(\"utils.parseHtmlFragment\",a.a.ua);a.b(\"utils.setHtml\",a.a.fc);a.aa=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.aa.Uc(c.nodeValue);null!=f&&e.push({ud:c,Kd:f})}else if(1==c.nodeType)for(var f=0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],\ne)}var c={};return{Xb:function(a){if(\"function\"!=typeof a)throw Error(\"You can only pass a function to ko.memoization.memoize()\");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return\"\\x3c!--[ko_memo:\"+b+\"]--\\x3e\"},bd:function(a,b){var f=c[a];if(f===n)throw Error(\"Couldn't find any memo with ID \"+a+\". Perhaps it's already been unmemoized.\");try{return f.apply(null,b||[]),!0}finally{delete c[a]}},cd:function(c,e){var f=\n[];b(c,f);for(var g=0,h=f.length;g<h;g++){var m=f[g].ud,k=[m];e&&a.a.Nb(k,e);a.aa.bd(f[g].Kd,k);m.nodeValue=\"\";m.parentNode&&m.parentNode.removeChild(m)}},Uc:function(a){return(a=a.match(/^\\[ko_memo\\:(.*?)\\]$/))?a[1]:null}}}();a.b(\"memoization\",a.aa);a.b(\"memoization.memoize\",a.aa.Xb);a.b(\"memoization.unmemoize\",a.aa.bd);a.b(\"memoization.parseMemoText\",a.aa.Uc);a.b(\"memoization.unmemoizeDomNodeAndDescendants\",a.aa.cd);a.na=function(){function b(){if(f)for(var b=f,c=0,d;h<f;)if(d=e[h++]){if(h>b){if(5E3<=\n++c){h=f;a.a.Gc(Error(\"'Too much recursion' after processing \"+c+\" task groups.\"));break}b=f}try{d()}catch(p){a.a.Gc(p)}}}function c(){b();h=f=e.length=0}var d,e=[],f=0,g=1,h=0;A.MutationObserver?d=function(a){var b=w.createElement(\"div\");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle(\"foo\")}}(c):d=w&&\"onreadystatechange\"in w.createElement(\"script\")?function(a){var b=w.createElement(\"script\");b.onreadystatechange=function(){b.onreadystatechange=null;w.documentElement.removeChild(b);\nb=null;a()};w.documentElement.appendChild(b)}:function(a){setTimeout(a,0)};return{scheduler:d,zb:function(b){f||a.na.scheduler(c);e[f++]=b;return g++},cancel:function(a){a=a-(g-f);a>=h&&a<f&&(e[a]=null)},resetForTesting:function(){var a=f-h;h=f=e.length=0;return a},Sd:b}}();a.b(\"tasks\",a.na);a.b(\"tasks.schedule\",a.na.zb);a.b(\"tasks.runEarly\",a.na.Sd);a.Ta={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.$({read:b,write:function(e){clearTimeout(d);d=a.a.setTimeout(function(){b(e)},\nc)}})},rateLimit:function(a,c){var d,e,f;\"number\"==typeof c?d=c:(d=c.timeout,e=c.method);a.Hb=!1;f=\"function\"==typeof e?e:\"notifyWhenChangesStop\"==e?Y:X;a.ub(function(a){return f(a,d,c)})},deferred:function(b,c){if(!0!==c)throw Error(\"The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.\");b.Hb||(b.Hb=!0,b.ub(function(c){var e,f=!1;return function(){if(!f){a.na.cancel(e);e=a.na.zb(c);try{f=!0,b.notifySubscribers(n,\"dirty\")}finally{f=\n!1}}}}))},notify:function(a,c){a.equalityComparer=\"always\"==c?null:K}};var W={undefined:1,\"boolean\":1,number:1,string:1};a.b(\"extenders\",a.Ta);a.ic=function(b,c,d){this.da=b;this.lc=c;this.mc=d;this.Ib=!1;this.fb=this.Jb=null;a.L(this,\"dispose\",this.s);a.L(this,\"disposeWhenNodeIsRemoved\",this.l)};a.ic.prototype.s=function(){this.Ib||(this.fb&&a.a.K.yb(this.Jb,this.fb),this.Ib=!0,this.mc(),this.da=this.lc=this.mc=this.Jb=this.fb=null)};a.ic.prototype.l=function(b){this.Jb=b;a.a.K.za(b,this.fb=this.s.bind(this))};\na.T=function(){a.a.Ab(this,D);D.qb(this)};var D={qb:function(a){a.U={change:[]};a.sc=1},subscribe:function(b,c,d){var e=this;d=d||\"change\";var f=new a.ic(e,c?b.bind(c):b,function(){a.a.Pa(e.U[d],f);e.hb&&e.hb(d)});e.Qa&&e.Qa(d);e.U[d]||(e.U[d]=[]);e.U[d].push(f);return f},notifySubscribers:function(b,c){c=c||\"change\";\"change\"===c&&this.Gb();if(this.Wa(c)){var d=\"change\"===c&&this.ed||this.U[c].slice(0);try{a.u.xc();for(var e=0,f;f=d[e];++e)f.Ib||f.lc(b)}finally{a.u.end()}}},ob:function(){return this.sc},\nDd:function(a){return this.ob()!==a},Gb:function(){++this.sc},ub:function(b){var c=this,d=a.O(c),e,f,g,h,m;c.gb||(c.gb=c.notifySubscribers,c.notifySubscribers=Z);var k=b(function(){c.Ja=!1;d&&h===c&&(h=c.nc?c.nc():c());var a=f||m&&c.sb(g,h);m=f=e=!1;a&&c.gb(g=h)});c.qc=function(a,b){b&&c.Ja||(m=!b);c.ed=c.U.change.slice(0);c.Ja=e=!0;h=a;k()};c.pc=function(a){e||(g=a,c.gb(a,\"beforeChange\"))};c.rc=function(){m=!0};c.gd=function(){c.sb(g,c.v(!0))&&(f=!0)}},Wa:function(a){return this.U[a]&&this.U[a].length},\nBd:function(b){if(b)return this.U[b]&&this.U[b].length||0;var c=0;a.a.P(this.U,function(a,b){\"dirty\"!==a&&(c+=b.length)});return c},sb:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},toString:function(){return\"[object Object]\"},extend:function(b){var c=this;b&&a.a.P(b,function(b,e){var f=a.Ta[b];\"function\"==typeof f&&(c=f(c,e)||c)});return c}};a.L(D,\"init\",D.qb);a.L(D,\"subscribe\",D.subscribe);a.L(D,\"extend\",D.extend);a.L(D,\"getSubscriptionsCount\",D.Bd);a.a.Ba&&a.a.setPrototypeOf(D,\nFunction.prototype);a.T.fn=D;a.Qc=function(a){return null!=a&&\"function\"==typeof a.subscribe&&\"function\"==typeof a.notifySubscribers};a.b(\"subscribable\",a.T);a.b(\"isSubscribable\",a.Qc);a.S=a.u=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{xc:b,end:c,cc:function(b){if(e){if(!a.Qc(b))throw Error(\"Only subscribable things can act as dependencies\");e.od.call(e.pd,b,b.fd||(b.fd=++f))}},G:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},qa:function(){if(e)return e.o.qa()},\nVa:function(){if(e)return e.o.Va()},Ya:function(){if(e)return e.Ya},o:function(){if(e)return e.o}}}();a.b(\"computedContext\",a.S);a.b(\"computedContext.getDependenciesCount\",a.S.qa);a.b(\"computedContext.getDependencies\",a.S.Va);a.b(\"computedContext.isInitial\",a.S.Ya);a.b(\"computedContext.registerDependency\",a.S.cc);a.b(\"ignoreDependencies\",a.Yd=a.u.G);var I=a.a.Da(\"_latestValue\");a.ta=function(b){function c(){if(0<arguments.length)return c.sb(c[I],arguments[0])&&(c.ya(),c[I]=arguments[0],c.xa()),this;\na.u.cc(c);return c[I]}c[I]=b;a.a.Ba||a.a.extend(c,a.T.fn);a.T.fn.qb(c);a.a.Ab(c,F);a.options.deferUpdates&&a.Ta.deferred(c,!0);return c};var F={equalityComparer:K,v:function(){return this[I]},xa:function(){this.notifySubscribers(this[I],\"spectate\");this.notifySubscribers(this[I])},ya:function(){this.notifySubscribers(this[I],\"beforeChange\")}};a.a.Ba&&a.a.setPrototypeOf(F,a.T.fn);var G=a.ta.Ma=\"__ko_proto__\";F[G]=a.ta;a.O=function(b){if((b=\"function\"==typeof b&&b[G])&&b!==F[G]&&b!==a.o.fn[G])throw Error(\"Invalid object that looks like an observable; possibly from another Knockout instance\");\nreturn!!b};a.Za=function(b){return\"function\"==typeof b&&(b[G]===F[G]||b[G]===a.o.fn[G]&&b.Nc)};a.b(\"observable\",a.ta);a.b(\"isObservable\",a.O);a.b(\"isWriteableObservable\",a.Za);a.b(\"isWritableObservable\",a.Za);a.b(\"observable.fn\",F);a.L(F,\"peek\",F.v);a.L(F,\"valueHasMutated\",F.xa);a.L(F,\"valueWillMutate\",F.ya);a.Ha=function(b){b=b||[];if(\"object\"!=typeof b||!(\"length\"in b))throw Error(\"The argument passed when initializing an observable array must be an array, or null, or undefined.\");b=a.ta(b);a.a.Ab(b,\na.Ha.fn);return b.extend({trackArrayChanges:!0})};a.Ha.fn={remove:function(b){for(var c=this.v(),d=[],e=\"function\"!=typeof b||a.O(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];if(e(g)){0===d.length&&this.ya();if(c[f]!==g)throw Error(\"Array modified during remove; cannot remove item\");d.push(g);c.splice(f,1);f--}}d.length&&this.xa();return d},removeAll:function(b){if(b===n){var c=this.v(),d=c.slice(0);this.ya();c.splice(0,c.length);this.xa();return d}return b?this.remove(function(c){return 0<=\na.a.A(b,c)}):[]},destroy:function(b){var c=this.v(),d=\"function\"!=typeof b||a.O(b)?function(a){return a===b}:b;this.ya();for(var e=c.length-1;0<=e;e--){var f=c[e];d(f)&&(f._destroy=!0)}this.xa()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.A(b,c)}):[]},indexOf:function(b){var c=this();return a.a.A(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ya(),this.v()[d]=c,this.xa())},sorted:function(a){var c=this().slice(0);\nreturn a?c.sort(a):c.sort()},reversed:function(){return this().slice(0).reverse()}};a.a.Ba&&a.a.setPrototypeOf(a.Ha.fn,a.ta.fn);a.a.D(\"pop push reverse shift sort splice unshift\".split(\" \"),function(b){a.Ha.fn[b]=function(){var a=this.v();this.ya();this.zc(a,b,arguments);var d=a[b].apply(a,arguments);this.xa();return d===a?this:d}});a.a.D([\"slice\"],function(b){a.Ha.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.Pc=function(b){return a.O(b)&&\"function\"==typeof b.remove&&\"function\"==\ntypeof b.push};a.b(\"observableArray\",a.Ha);a.b(\"isObservableArray\",a.Pc);a.Ta.trackArrayChanges=function(b,c){function d(){function c(){if(m){var d=[].concat(b.v()||[]),e;if(b.Wa(\"arrayChange\")){if(!f||1<m)f=a.a.Pb(k,d,b.Ob);e=f}k=d;f=null;m=0;e&&e.length&&b.notifySubscribers(e,\"arrayChange\")}}e?c():(e=!0,h=b.subscribe(function(){++m},null,\"spectate\"),k=[].concat(b.v()||[]),f=null,g=b.subscribe(c))}b.Ob={};c&&\"object\"==typeof c&&a.a.extend(b.Ob,c);b.Ob.sparse=!0;if(!b.zc){var e=!1,f=null,g,h,m=0,\nk,l=b.Qa,p=b.hb;b.Qa=function(a){l&&l.call(b,a);\"arrayChange\"===a&&d()};b.hb=function(a){p&&p.call(b,a);\"arrayChange\"!==a||b.Wa(\"arrayChange\")||(g&&g.s(),h&&h.s(),h=g=null,e=!1,k=n)};b.zc=function(b,c,d){function l(a,b,c){return k[k.length]={status:a,value:b,index:c}}if(e&&!m){var k=[],p=b.length,g=d.length,h=0;switch(c){case \"push\":h=p;case \"unshift\":for(c=0;c<g;c++)l(\"added\",d[c],h+c);break;case \"pop\":h=p-1;case \"shift\":p&&l(\"deleted\",b[h],h);break;case \"splice\":c=Math.min(Math.max(0,0>d[0]?p+d[0]:\nd[0]),p);for(var p=1===g?p:Math.min(c+(d[1]||0),p),g=c+g-2,h=Math.max(p,g),U=[],L=[],n=2;c<h;++c,++n)c<p&&L.push(l(\"deleted\",b[c],c)),c<g&&U.push(l(\"added\",d[n],c));a.a.Kc(L,U);break;default:return}f=k}}}};var r=a.a.Da(\"_state\");a.o=a.$=function(b,c,d){function e(){if(0<arguments.length){if(\"function\"===typeof f)f.apply(g.nb,arguments);else throw Error(\"Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");return this}g.ra||\na.u.cc(e);(g.ka||g.J&&e.Xa())&&e.ha();return g.X}\"object\"===typeof b?d=b:(d=d||{},b&&(d.read=b));if(\"function\"!=typeof d.read)throw Error(\"Pass a function that returns the value of the ko.computed\");var f=d.write,g={X:n,sa:!0,ka:!0,rb:!1,jc:!1,ra:!1,wb:!1,J:!1,Wc:d.read,nb:c||d.owner,l:d.disposeWhenNodeIsRemoved||d.l||null,Sa:d.disposeWhen||d.Sa,Rb:null,I:{},V:0,Ic:null};e[r]=g;e.Nc=\"function\"===typeof f;a.a.Ba||a.a.extend(e,a.T.fn);a.T.fn.qb(e);a.a.Ab(e,C);d.pure?(g.wb=!0,g.J=!0,a.a.extend(e,da)):\nd.deferEvaluation&&a.a.extend(e,ea);a.options.deferUpdates&&a.Ta.deferred(e,!0);g.l&&(g.jc=!0,g.l.nodeType||(g.l=null));g.J||d.deferEvaluation||e.ha();g.l&&e.ja()&&a.a.K.za(g.l,g.Rb=function(){e.s()});return e};var C={equalityComparer:K,qa:function(){return this[r].V},Va:function(){var b=[];a.a.P(this[r].I,function(a,d){b[d.Ka]=d.da});return b},Vb:function(b){if(!this[r].V)return!1;var c=this.Va();return-1!==a.a.A(c,b)?!0:!!a.a.Lb(c,function(a){return a.Vb&&a.Vb(b)})},uc:function(a,c,d){if(this[r].wb&&\nc===this)throw Error(\"A 'pure' computed must not be called recursively\");this[r].I[a]=d;d.Ka=this[r].V++;d.La=c.ob()},Xa:function(){var a,c,d=this[r].I;for(a in d)if(Object.prototype.hasOwnProperty.call(d,a)&&(c=d[a],this.Ia&&c.da.Ja||c.da.Dd(c.La)))return!0},Jd:function(){this.Ia&&!this[r].rb&&this.Ia(!1)},ja:function(){var a=this[r];return a.ka||0<a.V},Rd:function(){this.Ja?this[r].ka&&(this[r].sa=!0):this.Hc()},$c:function(a){if(a.Hb){var c=a.subscribe(this.Jd,this,\"dirty\"),d=a.subscribe(this.Rd,\nthis);return{da:a,s:function(){c.s();d.s()}}}return a.subscribe(this.Hc,this)},Hc:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[r].Ic),this[r].Ic=a.a.setTimeout(function(){b.ha(!0)},c)):b.Ia?b.Ia(!0):b.ha(!0)},ha:function(b){var c=this[r],d=c.Sa,e=!1;if(!c.rb&&!c.ra){if(c.l&&!a.a.Sb(c.l)||d&&d()){if(!c.jc){this.s();return}}else c.jc=!1;c.rb=!0;try{e=this.zd(b)}finally{c.rb=!1}return e}},zd:function(b){var c=this[r],d=!1,e=c.wb?n:!c.V,d={qd:this,mb:c.I,Qb:c.V};a.u.xc({pd:d,\nod:ba,o:this,Ya:e});c.I={};c.V=0;var f=this.yd(c,d);c.V?d=this.sb(c.X,f):(this.s(),d=!0);d&&(c.J?this.Gb():this.notifySubscribers(c.X,\"beforeChange\"),c.X=f,this.notifySubscribers(c.X,\"spectate\"),!c.J&&b&&this.notifySubscribers(c.X),this.rc&&this.rc());e&&this.notifySubscribers(c.X,\"awake\");return d},yd:function(b,c){try{var d=b.Wc;return b.nb?d.call(b.nb):d()}finally{a.u.end(),c.Qb&&!b.J&&a.a.P(c.mb,aa),b.sa=b.ka=!1}},v:function(a){var c=this[r];(c.ka&&(a||!c.V)||c.J&&this.Xa())&&this.ha();return c.X},\nub:function(b){a.T.fn.ub.call(this,b);this.nc=function(){this[r].J||(this[r].sa?this.ha():this[r].ka=!1);return this[r].X};this.Ia=function(a){this.pc(this[r].X);this[r].ka=!0;a&&(this[r].sa=!0);this.qc(this,!a)}},s:function(){var b=this[r];!b.J&&b.I&&a.a.P(b.I,function(a,b){b.s&&b.s()});b.l&&b.Rb&&a.a.K.yb(b.l,b.Rb);b.I=n;b.V=0;b.ra=!0;b.sa=!1;b.ka=!1;b.J=!1;b.l=n;b.Sa=n;b.Wc=n;this.Nc||(b.nb=n)}},da={Qa:function(b){var c=this,d=c[r];if(!d.ra&&d.J&&\"change\"==b){d.J=!1;if(d.sa||c.Xa())d.I=null,d.V=\n0,c.ha()&&c.Gb();else{var e=[];a.a.P(d.I,function(a,b){e[b.Ka]=a});a.a.D(e,function(a,b){var e=d.I[a],m=c.$c(e.da);m.Ka=b;m.La=e.La;d.I[a]=m});c.Xa()&&c.ha()&&c.Gb()}d.ra||c.notifySubscribers(d.X,\"awake\")}},hb:function(b){var c=this[r];c.ra||\"change\"!=b||this.Wa(\"change\")||(a.a.P(c.I,function(a,b){b.s&&(c.I[a]={da:b.da,Ka:b.Ka,La:b.La},b.s())}),c.J=!0,this.notifySubscribers(n,\"asleep\"))},ob:function(){var b=this[r];b.J&&(b.sa||this.Xa())&&this.ha();return a.T.fn.ob.call(this)}},ea={Qa:function(a){\"change\"!=\na&&\"beforeChange\"!=a||this.v()}};a.a.Ba&&a.a.setPrototypeOf(C,a.T.fn);var N=a.ta.Ma;C[N]=a.o;a.Oc=function(a){return\"function\"==typeof a&&a[N]===C[N]};a.Fd=function(b){return a.Oc(b)&&b[r]&&b[r].wb};a.b(\"computed\",a.o);a.b(\"dependentObservable\",a.o);a.b(\"isComputed\",a.Oc);a.b(\"isPureComputed\",a.Fd);a.b(\"computed.fn\",C);a.L(C,\"peek\",C.v);a.L(C,\"dispose\",C.s);a.L(C,\"isActive\",C.ja);a.L(C,\"getDependenciesCount\",C.qa);a.L(C,\"getDependencies\",C.Va);a.xb=function(b,c){if(\"function\"===typeof b)return a.o(b,\nc,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.o(b,c)};a.b(\"pureComputed\",a.xb);(function(){function b(a,f,g){g=g||new d;a=f(a);if(\"object\"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case \"boolean\":case \"number\":case \"string\":case \"function\":h[c]=d;break;case \"object\":case \"undefined\":var l=g.get(d);h[c]=l!==\nn?l:b(d,f,g)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);\"function\"==typeof a.toJSON&&b(\"toJSON\")}else for(c in a)b(c)}function d(){this.keys=[];this.values=[]}a.ad=function(c){if(0==arguments.length)throw Error(\"When calling ko.toJS, pass the object you want to convert.\");return b(c,function(b){for(var c=0;a.O(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.ad(b);return a.a.hc(b,c,d)};d.prototype={constructor:d,save:function(b,c){var d=a.a.A(this.keys,\nb);0<=d?this.values[d]=c:(this.keys.push(b),this.values.push(c))},get:function(b){b=a.a.A(this.keys,b);return 0<=b?this.values[b]:n}}})();a.b(\"toJS\",a.ad);a.b(\"toJSON\",a.toJSON);a.Wd=function(b,c,d){function e(c){var e=a.xb(b,d).extend({ma:\"always\"}),h=e.subscribe(function(a){a&&(h.s(),c(a))});e.notifySubscribers(e.v());return h}return\"function\"!==typeof Promise||c?e(c.bind(d)):new Promise(e)};a.b(\"when\",a.Wd);(function(){a.w={M:function(b){switch(a.a.R(b)){case \"option\":return!0===b.__ko__hasDomDataOptionValue__?\na.a.g.get(b,a.c.options.$b):7>=a.a.W?b.getAttributeNode(\"value\")&&b.getAttributeNode(\"value\").specified?b.value:b.text:b.value;case \"select\":return 0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex]):n;default:return b.value}},cb:function(b,c,d){switch(a.a.R(b)){case \"option\":\"string\"===typeof c?(a.a.g.set(b,a.c.options.$b,n),\"__ko__hasDomDataOptionValue__\"in b&&delete b.__ko__hasDomDataOptionValue__,b.value=c):(a.a.g.set(b,a.c.options.$b,c),b.__ko__hasDomDataOptionValue__=!0,b.value=\"number\"===\ntypeof c?c:\"\");break;case \"select\":if(\"\"===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.w.M(b.options[f]),h==c||\"\"===h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e,6===a.a.W&&a.a.setTimeout(function(){b.selectedIndex=e},0);break;default:if(null===c||c===n)c=\"\";b.value=c}}}})();a.b(\"selectExtensions\",a.w);a.b(\"selectExtensions.readValue\",a.w.M);a.b(\"selectExtensions.writeValue\",a.w.cb);a.m=function(){function b(b){b=a.a.Db(b);123===b.charCodeAt(0)&&(b=b.slice(1,\n-1));b+=\"\\n,\";var c=[],d=b.match(e),p,q=[],h=0;if(1<d.length){for(var x=0,B;B=d[x];++x){var u=B.charCodeAt(0);if(44===u){if(0>=h){c.push(p&&q.length?{key:p,value:q.join(\"\")}:{unknown:p||q.join(\"\")});p=h=0;q=[];continue}}else if(58===u){if(!h&&!p&&1===q.length){p=q.pop();continue}}else if(47===u&&1<B.length&&(47===B.charCodeAt(1)||42===B.charCodeAt(1)))continue;else 47===u&&x&&1<B.length?(u=d[x-1].match(f))&&!g[u[0]]&&(b=b.substr(b.indexOf(B)+1),d=b.match(e),x=-1,B=\"/\"):40===u||123===u||91===u?++h:\n41===u||125===u||93===u?--h:p||q.length||34!==u&&39!==u||(B=B.slice(1,-1));q.push(B)}if(0<h)throw Error(\"Unbalanced parentheses, braces, or brackets\");}return c}var c=[\"true\",\"false\",\"null\",\"undefined\"],d=/^(?:[$_a-z][$\\w]*|(.+)(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i,e=RegExp(\"\\\"(?:\\\\\\\\.|[^\\\"])*\\\"|'(?:\\\\\\\\.|[^'])*'|`(?:\\\\\\\\.|[^`])*`|/\\\\*(?:[^*]|\\\\*+[^*/])*\\\\*+/|//.*\\n|/(?:\\\\\\\\.|[^/])+/w*|[^\\\\s:,/][^,\\\"'`{}()/:[\\\\]]*[^\\\\s,\\\"'`{}()/:[\\\\]]|[^\\\\s]\",\"g\"),f=/[\\])\"'A-Za-z0-9_$]+$/,g={\"in\":1,\"return\":1,\"typeof\":1},\nh={};return{Ra:[],wa:h,ac:b,vb:function(e,f){function l(b,e){var f;if(!x){var k=a.getBindingHandler(b);if(k&&k.preprocess&&!(e=k.preprocess(e,b,l)))return;if(k=h[b])f=e,0<=a.a.A(c,f)?f=!1:(k=f.match(d),f=null===k?!1:k[1]?\"Object(\"+k[1]+\")\"+k[2]:f),k=f;k&&q.push(\"'\"+(\"string\"==typeof h[b]?h[b]:b)+\"':function(_z){\"+f+\"=_z}\")}g&&(e=\"function(){return \"+e+\" }\");p.push(\"'\"+b+\"':\"+e)}f=f||{};var p=[],q=[],g=f.valueAccessors,x=f.bindingParams,B=\"string\"===typeof e?b(e):e;a.a.D(B,function(a){l(a.key||a.unknown,\na.value)});q.length&&l(\"_ko_property_writers\",\"{\"+q.join(\",\")+\" }\");return p.join(\",\")},Id:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},eb:function(b,c,d,e,f){if(b&&a.O(b))!a.Za(b)||f&&b.v()===e||b(e);else if((b=c.get(\"_ko_property_writers\"))&&b[d])b[d](e)}}}();a.b(\"expressionRewriting\",a.m);a.b(\"expressionRewriting.bindingRewriteValidators\",a.m.Ra);a.b(\"expressionRewriting.parseObjectLiteral\",a.m.ac);a.b(\"expressionRewriting.preProcessBindings\",a.m.vb);a.b(\"expressionRewriting._twoWayBindings\",\na.m.wa);a.b(\"jsonExpressionRewriting\",a.m);a.b(\"jsonExpressionRewriting.insertPropertyAccessorsIntoJson\",a.m.vb);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(d,e){for(var f=d,h=1,g=[];f=f.nextSibling;){if(c(f)&&(a.a.g.set(f,k,!0),h--,0===h))return g;g.push(f);b(f)&&h++}if(!e)throw Error(\"Cannot find closing comment tag to match: \"+d.nodeValue);return null}function e(a,b){var c=d(a,b);return c?\n0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=w&&\"\\x3c!--test--\\x3e\"===w.createComment(\"test\").text,g=f?/^\\x3c!--\\s*ko(?:\\s+([\\s\\S]+))?\\s*--\\x3e$/:/^\\s*ko(?:\\s+([\\s\\S]+))?\\s*$/,h=f?/^\\x3c!--\\s*\\/ko\\s*--\\x3e$/:/^\\s*\\/ko\\s*$/,m={ul:!0,ol:!0},k=\"__ko_matchedEndComment__\";a.h={ea:{},childNodes:function(a){return b(a)?d(a):a.childNodes},Ea:function(c){if(b(c)){c=a.h.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.Tb(c)},va:function(c,d){if(b(c)){a.h.Ea(c);for(var e=\nc.nextSibling,f=0,k=d.length;f<k;f++)e.parentNode.insertBefore(d[f],e)}else a.a.va(c,d)},Vc:function(a,c){var d;b(a)?(d=a.nextSibling,a=a.parentNode):d=a.firstChild;d?c!==d&&a.insertBefore(c,d):a.appendChild(c)},Wb:function(c,d,e){e?(e=e.nextSibling,b(c)&&(c=c.parentNode),e?d!==e&&c.insertBefore(d,e):c.appendChild(d)):a.h.Vc(c,d)},firstChild:function(a){if(b(a))return!a.nextSibling||c(a.nextSibling)?null:a.nextSibling;if(a.firstChild&&c(a.firstChild))throw Error(\"Found invalid end comment, as the first child of \"+\na);return a.firstChild},nextSibling:function(d){b(d)&&(d=e(d));if(d.nextSibling&&c(d.nextSibling)){var f=d.nextSibling;if(c(f)&&!a.a.g.get(f,k))throw Error(\"Found end comment without a matching opening comment, as child of \"+d);return null}return d.nextSibling},Cd:b,Vd:function(a){return(a=(f?a.text:a.nodeValue).match(g))?a[1]:null},Sc:function(d){if(m[a.a.R(d)]){var f=d.firstChild;if(f){do if(1===f.nodeType){var k;k=f.firstChild;var h=null;if(k){do if(h)h.push(k);else if(b(k)){var g=e(k,!0);g?k=\ng:h=[k]}else c(k)&&(h=[k]);while(k=k.nextSibling)}if(k=h)for(h=f.nextSibling,g=0;g<k.length;g++)h?d.insertBefore(k[g],h):d.appendChild(k[g])}while(f=f.nextSibling)}}}}})();a.b(\"virtualElements\",a.h);a.b(\"virtualElements.allowedBindings\",a.h.ea);a.b(\"virtualElements.emptyNode\",a.h.Ea);a.b(\"virtualElements.insertAfter\",a.h.Wb);a.b(\"virtualElements.prepend\",a.h.Vc);a.b(\"virtualElements.setDomNodeChildren\",a.h.va);(function(){a.ga=function(){this.nd={}};a.a.extend(a.ga.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=\nb.getAttribute(\"data-bind\")||a.j.getComponentNameForNode(b);case 8:return a.h.Cd(b);default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.j.tc(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.j.tc(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute(\"data-bind\");case 8:return a.h.Vd(b);default:return null}},\nparseBindingsString:function(b,c,d,e){try{var f=this.nd,g=b+(e&&e.valueAccessors||\"\"),h;if(!(h=f[g])){var m,k=\"with($context){with($data||{}){return{\"+a.m.vb(b,e)+\"}}}\";m=new Function(\"$context\",\"$element\",k);h=f[g]=m}return h(c,d)}catch(l){throw l.message=\"Unable to parse bindings.\\nBindings value: \"+b+\"\\nMessage: \"+l.message,l;}}});a.ga.instance=new a.ga})();a.b(\"bindingProvider\",a.ga);(function(){function b(b){var c=(b=a.a.g.get(b,z))&&b.N;c&&(b.N=null,c.Tc())}function c(c,d,e){this.node=c;this.yc=\nd;this.kb=[];this.H=!1;d.N||a.a.K.za(c,b);e&&e.N&&(e.N.kb.push(c),this.Kb=e)}function d(a){return function(){return a}}function e(a){return a()}function f(b){return a.a.Ga(a.u.G(b),function(a,c){return function(){return b()[c]}})}function g(b,c,e){return\"function\"===typeof b?f(b.bind(null,c,e)):a.a.Ga(b,d)}function h(a,b){return f(this.getBindings.bind(this,a,b))}function m(b,c){var d=a.h.firstChild(c);if(d){var e,f=a.ga.instance,l=f.preprocessNode;if(l){for(;e=d;)d=a.h.nextSibling(e),l.call(f,e);\nd=a.h.firstChild(c)}for(;e=d;)d=a.h.nextSibling(e),k(b,e)}a.i.ma(c,a.i.H)}function k(b,c){var d=b,e=1===c.nodeType;e&&a.h.Sc(c);if(e||a.ga.instance.nodeHasBindings(c))d=p(c,null,b).bindingContextForDescendants;d&&!u[a.a.R(c)]&&m(d,c)}function l(b){var c=[],d={},e=[];a.a.P(b,function ca(f){if(!d[f]){var k=a.getBindingHandler(f);k&&(k.after&&(e.push(f),a.a.D(k.after,function(c){if(b[c]){if(-1!==a.a.A(e,c))throw Error(\"Cannot combine the following bindings, because they have a cyclic dependency: \"+e.join(\", \"));\nca(c)}}),e.length--),c.push({key:f,Mc:k}));d[f]=!0}});return c}function p(b,c,d){var f=a.a.g.Ub(b,z,{}),k=f.hd;if(!c){if(k)throw Error(\"You cannot apply bindings multiple times to the same element.\");f.hd=!0}k||(f.context=d);f.Zb||(f.Zb={});var g;if(c&&\"function\"!==typeof c)g=c;else{var p=a.ga.instance,q=p.getBindingAccessors||h,m=a.$(function(){if(g=c?c(d,b):q.call(p,b,d)){if(d[t])d[t]();if(d[B])d[B]()}return g},null,{l:b});g&&m.ja()||(m=null)}var x=d,u;if(g){var J=function(){return a.a.Ga(m?m():\ng,e)},r=m?function(a){return function(){return e(m()[a])}}:function(a){return g[a]};J.get=function(a){return g[a]&&e(r(a))};J.has=function(a){return a in g};a.i.H in g&&a.i.subscribe(b,a.i.H,function(){var c=(0,g[a.i.H])();if(c){var d=a.h.childNodes(b);d.length&&c(d,a.Ec(d[0]))}});a.i.pa in g&&(x=a.i.Cb(b,d),a.i.subscribe(b,a.i.pa,function(){var c=(0,g[a.i.pa])();c&&a.h.firstChild(b)&&c(b)}));f=l(g);a.a.D(f,function(c){var d=c.Mc.init,e=c.Mc.update,f=c.key;if(8===b.nodeType&&!a.h.ea[f])throw Error(\"The binding '\"+\nf+\"' cannot be used with virtual elements\");try{\"function\"==typeof d&&a.u.G(function(){var a=d(b,r(f),J,x.$data,x);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error(\"Multiple bindings (\"+u+\" and \"+f+\") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");u=f}}),\"function\"==typeof e&&a.$(function(){e(b,r(f),J,x.$data,x)},null,{l:b})}catch(k){throw k.message='Unable to process binding \"'+f+\": \"+g[f]+'\"\\nMessage: '+k.message,\nk;}})}f=u===n;return{shouldBindDescendants:f,bindingContextForDescendants:f&&x}}function q(b,c){return b&&b instanceof a.fa?b:new a.fa(b,n,n,c)}var t=a.a.Da(\"_subscribable\"),x=a.a.Da(\"_ancestorBindingInfo\"),B=a.a.Da(\"_dataDependency\");a.c={};var u={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.c[b]};var J={};a.fa=function(b,c,d,e,f){function k(){var b=p?h():h,f=a.a.f(b);c?(a.a.extend(l,c),x in c&&(l[x]=c[x])):(l.$parents=[],l.$root=f,l.ko=a);l[t]=q;g?f=l.$data:(l.$rawData=\nb,l.$data=f);d&&(l[d]=f);e&&e(l,c,f);if(c&&c[t]&&!a.S.o().Vb(c[t]))c[t]();m&&(l[B]=m);return l.$data}var l=this,g=b===J,h=g?n:b,p=\"function\"==typeof h&&!a.O(h),q,m=f&&f.dataDependency;f&&f.exportDependencies?k():(q=a.xb(k),q.v(),q.ja()?q.equalityComparer=null:l[t]=n)};a.fa.prototype.createChildContext=function(b,c,d,e){!e&&c&&\"object\"==typeof c&&(e=c,c=e.as,d=e.extend);if(c&&e&&e.noChildContext){var f=\"function\"==typeof b&&!a.O(b);return new a.fa(J,this,null,function(a){d&&d(a);a[c]=f?b():b},e)}return new a.fa(b,\nthis,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)},e)};a.fa.prototype.extend=function(b,c){return new a.fa(J,this,null,function(c){a.a.extend(c,\"function\"==typeof b?b(c):b)},c)};var z=a.a.g.Z();c.prototype.Tc=function(){this.Kb&&this.Kb.N&&this.Kb.N.sd(this.node)};c.prototype.sd=function(b){a.a.Pa(this.kb,b);!this.kb.length&&this.H&&this.Cc()};c.prototype.Cc=function(){this.H=!0;this.yc.N&&!this.kb.length&&(this.yc.N=\nnull,a.a.K.yb(this.node,b),a.i.ma(this.node,a.i.pa),this.Tc())};a.i={H:\"childrenComplete\",pa:\"descendantsComplete\",subscribe:function(b,c,d,e,f){var k=a.a.g.Ub(b,z,{});k.Fa||(k.Fa=new a.T);f&&f.notifyImmediately&&k.Zb[c]&&a.u.G(d,e,[b]);return k.Fa.subscribe(d,e,c)},ma:function(b,c){var d=a.a.g.get(b,z);if(d&&(d.Zb[c]=!0,d.Fa&&d.Fa.notifySubscribers(b,c),c==a.i.H))if(d.N)d.N.Cc();else if(d.N===n&&d.Fa&&d.Fa.Wa(a.i.pa))throw Error(\"descendantsComplete event not supported for bindings on this node\");\n},Cb:function(b,d){var e=a.a.g.Ub(b,z,{});e.N||(e.N=new c(b,e,d[x]));return d[x]==e?d:d.extend(function(a){a[x]=e})}};a.Td=function(b){return(b=a.a.g.get(b,z))&&b.context};a.ib=function(b,c,d){1===b.nodeType&&a.h.Sc(b);return p(b,c,q(d))};a.ld=function(b,c,d){d=q(d);return a.ib(b,g(c,d,b),d)};a.Oa=function(a,b){1!==b.nodeType&&8!==b.nodeType||m(q(a),b)};a.vc=function(a,b,c){!v&&A.jQuery&&(v=A.jQuery);if(2>arguments.length){if(b=w.body,!b)throw Error(\"ko.applyBindings: could not find document.body; has the document been loaded?\");\n}else if(!b||1!==b.nodeType&&8!==b.nodeType)throw Error(\"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node\");k(q(a,c),b)};a.Dc=function(b){return!b||1!==b.nodeType&&8!==b.nodeType?n:a.Td(b)};a.Ec=function(b){return(b=a.Dc(b))?b.$data:n};a.b(\"bindingHandlers\",a.c);a.b(\"bindingEvent\",a.i);a.b(\"bindingEvent.subscribe\",a.i.subscribe);a.b(\"bindingEvent.startPossiblyAsyncContentBinding\",a.i.Cb);a.b(\"applyBindings\",a.vc);a.b(\"applyBindingsToDescendants\",a.Oa);\na.b(\"applyBindingAccessorsToNode\",a.ib);a.b(\"applyBindingsToNode\",a.ld);a.b(\"contextFor\",a.Dc);a.b(\"dataFor\",a.Ec)})();(function(b){function c(c,e){var k=Object.prototype.hasOwnProperty.call(f,c)?f[c]:b,l;k?k.subscribe(e):(k=f[c]=new a.T,k.subscribe(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Gd:e};delete f[c];l||e?k.notifySubscribers(b):a.na.zb(function(){k.notifySubscribers(b)})}),l=!0)}function d(a,b){e(\"getConfig\",[a],function(c){c?e(\"loadComponent\",[a,c],function(a){b(a,\nc)}):b(null,null)})}function e(c,d,f,l){l||(l=a.j.loaders.slice(0));var g=l.shift();if(g){var q=g[c];if(q){var t=!1;if(q.apply(g,d.concat(function(a){t?f(null):null!==a?f(a):e(c,d,f,l)}))!==b&&(t=!0,!g.suppressLoaderExceptions))throw Error(\"Component loaders must supply values by invoking the callback, not by returning values synchronously.\");}else e(c,d,f,l)}else f(null)}var f={},g={};a.j={get:function(d,e){var f=Object.prototype.hasOwnProperty.call(g,d)?g[d]:b;f?f.Gd?a.u.G(function(){e(f.definition)}):\na.na.zb(function(){e(f.definition)}):c(d,e)},Bc:function(a){delete g[a]},oc:e};a.j.loaders=[];a.b(\"components\",a.j);a.b(\"components.get\",a.j.get);a.b(\"components.clearCachedDefinition\",a.j.Bc)})();(function(){function b(b,c,d,e){function g(){0===--B&&e(h)}var h={},B=2,u=d.template;d=d.viewModel;u?f(c,u,function(c){a.j.oc(\"loadTemplate\",[b,c],function(a){h.template=a;g()})}):g();d?f(c,d,function(c){a.j.oc(\"loadViewModel\",[b,c],function(a){h[m]=a;g()})}):g()}function c(a,b,d){if(\"function\"===typeof b)d(function(a){return new b(a)});\nelse if(\"function\"===typeof b[m])d(b[m]);else if(\"instance\"in b){var e=b.instance;d(function(){return e})}else\"viewModel\"in b?c(a,b.viewModel,d):a(\"Unknown viewModel value: \"+b)}function d(b){switch(a.a.R(b)){case \"script\":return a.a.ua(b.text);case \"textarea\":return a.a.ua(b.value);case \"template\":if(e(b.content))return a.a.Ca(b.content.childNodes)}return a.a.Ca(b.childNodes)}function e(a){return A.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){\"string\"===typeof b.require?\nT||A.require?(T||A.require)([b.require],function(a){a&&\"object\"===typeof a&&a.Xd&&a[\"default\"]&&(a=a[\"default\"]);c(a)}):a(\"Uses require, but no AMD loader is present\"):c(b)}function g(a){return function(b){throw Error(\"Component '\"+a+\"': \"+b);}}var h={};a.j.register=function(b,c){if(!c)throw Error(\"Invalid configuration for \"+b);if(a.j.tb(b))throw Error(\"Component \"+b+\" is already registered\");h[b]=c};a.j.tb=function(a){return Object.prototype.hasOwnProperty.call(h,a)};a.j.unregister=function(b){delete h[b];\na.j.Bc(b)};a.j.Fc={getConfig:function(b,c){c(a.j.tb(b)?h[b]:null)},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if(\"string\"===typeof c)f(a.a.ua(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.la(c.childNodes));else if(c.element)if(c=c.element,A.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if(\"string\"===typeof c){var h=w.getElementById(c);h?f(d(h)):b(\"Cannot find element with ID \"+c)}else b(\"Unknown element type: \"+\nc);else b(\"Unknown template value: \"+c)},loadViewModel:function(a,b,d){c(g(a),b,d)}};var m=\"createViewModel\";a.b(\"components.register\",a.j.register);a.b(\"components.isRegistered\",a.j.tb);a.b(\"components.unregister\",a.j.unregister);a.b(\"components.defaultLoader\",a.j.Fc);a.j.loaders.push(a.j.Fc);a.j.dd=h})();(function(){function b(b,e){var f=b.getAttribute(\"params\");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ga(f,function(c){return a.o(c,null,{l:b})}),g=a.a.Ga(f,\nfunction(c){var e=c.v();return c.ja()?a.o({read:function(){return a.a.f(c())},write:a.Za(e)&&function(a){c()(a)},l:b}):e});Object.prototype.hasOwnProperty.call(g,\"$raw\")||(g.$raw=f);return g}return{$raw:{}}}a.j.getComponentNameForNode=function(b){var c=a.a.R(b);if(a.j.tb(c)&&(-1!=c.indexOf(\"-\")||\"[object HTMLUnknownElement]\"==\"\"+b||8>=a.a.W&&b.tagName===c))return c};a.j.tc=function(c,e,f,g){if(1===e.nodeType){var h=a.j.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the \"component\" binding on a custom element matching a component');\nvar m={name:h,params:b(e,f)};c.component=g?function(){return m}:m}}return c};var c=new a.ga;9>a.a.W&&(a.j.register=function(a){return function(b){return a.apply(this,arguments)}}(a.j.register),w.createDocumentFragment=function(b){return function(){var c=b(),f=a.j.dd,g;for(g in f);return c}}(w.createDocumentFragment))})();(function(){function b(b,c,d){c=c.template;if(!c)throw Error(\"Component '\"+b+\"' has no template\");b=a.a.Ca(c);a.h.va(d,b)}function c(a,b,c){var d=a.createViewModel;return d?d.call(a,\nb,c):b}var d=0;a.c.component={init:function(e,f,g,h,m){function k(){var a=l&&l.dispose;\"function\"===typeof a&&a.call(l);q&&q.s();p=l=q=null}var l,p,q,t=a.a.la(a.h.childNodes(e));a.h.Ea(e);a.a.K.za(e,k);a.o(function(){var g=a.a.f(f()),h,u;\"string\"===typeof g?h=g:(h=a.a.f(g.name),u=a.a.f(g.params));if(!h)throw Error(\"No component name specified\");var n=a.i.Cb(e,m),z=p=++d;a.j.get(h,function(d){if(p===z){k();if(!d)throw Error(\"Unknown component '\"+h+\"'\");b(h,d,e);var f=c(d,u,{element:e,templateNodes:t});\nd=n.createChildContext(f,{extend:function(a){a.$component=f;a.$componentTemplateNodes=t}});f&&f.koDescendantsComplete&&(q=a.i.subscribe(e,a.i.pa,f.koDescendantsComplete,f));l=f;a.Oa(d,e)}})},null,{l:e});return{controlsDescendantBindings:!0}}};a.h.ea.component=!0})();var V={\"class\":\"className\",\"for\":\"htmlFor\"};a.c.attr={update:function(b,c){var d=a.a.f(c())||{};a.a.P(d,function(c,d){d=a.a.f(d);var g=c.indexOf(\":\"),g=\"lookupNamespaceURI\"in b&&0<g&&b.lookupNamespaceURI(c.substr(0,g)),h=!1===d||null===\nd||d===n;h?g?b.removeAttributeNS(g,c):b.removeAttribute(c):d=d.toString();8>=a.a.W&&c in V?(c=V[c],h?b.removeAttribute(c):b[c]=d):h||(g?b.setAttributeNS(g,c,d):b.setAttribute(c,d));\"name\"===c&&a.a.Yc(b,h?\"\":d)})}};(function(){a.c.checked={after:[\"value\",\"attr\"],init:function(b,c,d){function e(){var e=b.checked,f=g();if(!a.S.Ya()&&(e||!m&&!a.S.qa())){var k=a.u.G(c);if(l){var q=p?k.v():k,z=t;t=f;z!==f?e&&(a.a.Na(q,f,!0),a.a.Na(q,z,!1)):a.a.Na(q,f,e);p&&a.Za(k)&&k(q)}else h&&(f===n?f=e:e||(f=n)),a.m.eb(k,\nd,\"checked\",f,!0)}}function f(){var d=a.a.f(c()),e=g();l?(b.checked=0<=a.a.A(d,e),t=e):b.checked=h&&e===n?!!d:g()===d}var g=a.xb(function(){if(d.has(\"checkedValue\"))return a.a.f(d.get(\"checkedValue\"));if(q)return d.has(\"value\")?a.a.f(d.get(\"value\")):b.value}),h=\"checkbox\"==b.type,m=\"radio\"==b.type;if(h||m){var k=c(),l=h&&a.a.f(k)instanceof Array,p=!(l&&k.push&&k.splice),q=m||l,t=l?g():n;m&&!b.name&&a.c.uniqueName.init(b,function(){return!0});a.o(e,null,{l:b});a.a.B(b,\"click\",e);a.o(f,null,{l:b});\nk=n}}};a.m.wa.checked=!0;a.c.checkedValue={update:function(b,c){b.value=a.a.f(c())}}})();a.c[\"class\"]={update:function(b,c){var d=a.a.Db(a.a.f(c()));a.a.Eb(b,b.__ko__cssValue,!1);b.__ko__cssValue=d;a.a.Eb(b,d,!0)}};a.c.css={update:function(b,c){var d=a.a.f(c());null!==d&&\"object\"==typeof d?a.a.P(d,function(c,d){d=a.a.f(d);a.a.Eb(b,c,d)}):a.c[\"class\"].update(b,c)}};a.c.enable={update:function(b,c){var d=a.a.f(c());d&&b.disabled?b.removeAttribute(\"disabled\"):d||b.disabled||(b.disabled=!0)}};a.c.disable=\n{update:function(b,c){a.c.enable.update(b,function(){return!a.a.f(c())})}};a.c.event={init:function(b,c,d,e,f){var g=c()||{};a.a.P(g,function(g){\"string\"==typeof g&&a.a.B(b,g,function(b){var k,l=c()[g];if(l){try{var p=a.a.la(arguments);e=f.$data;p.unshift(e);k=l.apply(e,p)}finally{!0!==k&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===d.get(g+\"Bubble\")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.c.foreach={Rc:function(b){return function(){var c=b(),d=a.a.bc(c);\nif(!d||\"number\"==typeof d.length)return{foreach:c,templateEngine:a.ba.Ma};a.a.f(c);return{foreach:d.data,as:d.as,noChildContext:d.noChildContext,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.ba.Ma}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.Rc(c))},update:function(b,c,d,e,f){return a.c.template.update(b,a.c.foreach.Rc(c),d,e,f)}};a.m.Ra.foreach=!1;a.h.ea.foreach=\n!0;a.c.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if(\"activeElement\"in f){var g;try{g=f.activeElement}catch(l){g=f.body}e=g===b}f=c();a.m.eb(f,d,\"hasfocus\",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.B(b,\"focus\",f);a.a.B(b,\"focusin\",f);a.a.B(b,\"blur\",g);a.a.B(b,\"focusout\",g);b.__ko_hasfocusLastValue=!1},update:function(b,c){var d=!!a.a.f(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===\nd||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.u.G(a.a.Fb,null,[b,d?\"focusin\":\"focusout\"]))}};a.m.wa.hasfocus=!0;a.c.hasFocus=a.c.hasfocus;a.m.wa.hasFocus=\"hasfocus\";a.c.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.fc(b,c())}};(function(){function b(b,d,e){a.c[b]={init:function(b,c,h,m,k){var l,p,q={},t,x,n;if(d){m=h.get(\"as\");var u=h.get(\"noChildContext\");n=!(m&&u);q={as:m,noChildContext:u,exportDependencies:n}}x=(t=\n\"render\"==h.get(\"completeOn\"))||h.has(a.i.pa);a.o(function(){var h=a.a.f(c()),m=!e!==!h,u=!p,r;if(n||m!==l){x&&(k=a.i.Cb(b,k));if(m){if(!d||n)q.dataDependency=a.S.o();r=d?k.createChildContext(\"function\"==typeof h?h:c,q):a.S.qa()?k.extend(null,q):k}u&&a.S.qa()&&(p=a.a.Ca(a.h.childNodes(b),!0));m?(u||a.h.va(b,a.a.Ca(p)),a.Oa(r,b)):(a.h.Ea(b),t||a.i.ma(b,a.i.H));l=m}},null,{l:b});return{controlsDescendantBindings:!0}}};a.m.Ra[b]=!1;a.h.ea[b]=!0}b(\"if\");b(\"ifnot\",!1,!0);b(\"with\",!0)})();a.c.let={init:function(b,\nc,d,e,f){c=f.extend(c);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.let=!0;var Q={};a.c.options={init:function(b){if(\"select\"!==a.a.R(b))throw Error(\"options binding applies only to SELECT elements\");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.jb(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return\"function\"==d?b(a):\"string\"==d?a[b]:c}function g(c,d){if(x&&l)a.i.ma(b,a.i.H);else if(t.length){var e=\n0<=a.a.A(t,a.w.M(d[0]));a.a.Zc(d[0],e);x&&!e&&a.u.G(a.a.Fb,null,[b,\"change\"])}}var h=b.multiple,m=0!=b.length&&h?b.scrollTop:null,k=a.a.f(c()),l=d.get(\"valueAllowUnset\")&&d.has(\"value\"),p=d.get(\"optionsIncludeDestroyed\");c={};var q,t=[];l||(h?t=a.a.Mb(e(),a.w.M):0<=b.selectedIndex&&t.push(a.w.M(b.options[b.selectedIndex])));k&&(\"undefined\"==typeof k.length&&(k=[k]),q=a.a.jb(k,function(b){return p||b===n||null===b||!a.a.f(b._destroy)}),d.has(\"optionsCaption\")&&(k=a.a.f(d.get(\"optionsCaption\")),null!==\nk&&k!==n&&q.unshift(Q)));var x=!1;c.beforeRemove=function(a){b.removeChild(a)};k=g;d.has(\"optionsAfterRender\")&&\"function\"==typeof d.get(\"optionsAfterRender\")&&(k=function(b,c){g(0,c);a.u.G(d.get(\"optionsAfterRender\"),null,[c[0],b!==Q?b:n])});a.a.ec(b,q,function(c,e,g){g.length&&(t=!l&&g[0].selected?[a.w.M(g[0])]:[],x=!0);e=b.ownerDocument.createElement(\"option\");c===Q?(a.a.Bb(e,d.get(\"optionsCaption\")),a.w.cb(e,n)):(g=f(c,d.get(\"optionsValue\"),c),a.w.cb(e,a.a.f(g)),c=f(c,d.get(\"optionsText\"),g),\na.a.Bb(e,c));return[e]},c,k);if(!l){var B;h?B=t.length&&e().length<t.length:B=t.length&&0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex])!==t[0]:t.length||0<=b.selectedIndex;B&&a.u.G(a.a.Fb,null,[b,\"change\"])}(l||a.S.Ya())&&a.i.ma(b,a.i.H);a.a.wd(b);m&&20<Math.abs(m-b.scrollTop)&&(b.scrollTop=m)}};a.c.options.$b=a.a.g.Z();a.c.selectedOptions={init:function(b,c,d){function e(){var e=c(),f=[];a.a.D(b.getElementsByTagName(\"option\"),function(b){b.selected&&f.push(a.w.M(b))});a.m.eb(e,d,\"selectedOptions\",\nf)}function f(){var d=a.a.f(c()),e=b.scrollTop;d&&\"number\"==typeof d.length&&a.a.D(b.getElementsByTagName(\"option\"),function(b){var c=0<=a.a.A(d,a.w.M(b));b.selected!=c&&a.a.Zc(b,c)});b.scrollTop=e}if(\"select\"!=a.a.R(b))throw Error(\"selectedOptions binding applies only to SELECT elements\");var g;a.i.subscribe(b,a.i.H,function(){g?e():(a.a.B(b,\"change\",e),g=a.o(f,null,{l:b}))},null,{notifyImmediately:!0})},update:function(){}};a.m.wa.selectedOptions=!0;a.c.style={update:function(b,c){var d=a.a.f(c()||\n{});a.a.P(d,function(c,d){d=a.a.f(d);if(null===d||d===n||!1===d)d=\"\";if(v)v(b).css(c,d);else if(/^--/.test(c))b.style.setProperty(c,d);else{c=c.replace(/-(\\w)/g,function(a,b){return b.toUpperCase()});var g=b.style[c];b.style[c]=d;d===g||b.style[c]!=g||isNaN(d)||(b.style[c]=d+\"px\")}})}};a.c.submit={init:function(b,c,d,e,f){if(\"function\"!=typeof c())throw Error(\"The value for a submit binding must be a function\");a.a.B(b,\"submit\",function(a){var d,e=c();try{d=e.call(f.$data,b)}finally{!0!==d&&(a.preventDefault?\na.preventDefault():a.returnValue=!1)}})}};a.c.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Bb(b,c())}};a.h.ea.text=!0;(function(){if(A&&A.navigator){var b=function(a){if(a)return parseFloat(a[1])},c=A.navigator.userAgent,d,e,f,g,h;(d=A.opera&&A.opera.version&&parseInt(A.opera.version()))||(h=b(c.match(/Edge\\/([^ ]+)$/)))||b(c.match(/Chrome\\/([^ ]+)/))||(e=b(c.match(/Version\\/([^ ]+) Safari/)))||(f=b(c.match(/Firefox\\/([^ ]+)/)))||(g=a.a.W||b(c.match(/MSIE ([^ ]+)/)))||\n(g=b(c.match(/rv:([^ )]+)/)))}if(8<=g&&10>g)var m=a.a.g.Z(),k=a.a.g.Z(),l=function(b){var c=this.activeElement;(c=c&&a.a.g.get(c,k))&&c(b)},p=function(b,c){var d=b.ownerDocument;a.a.g.get(d,m)||(a.a.g.set(d,m,!0),a.a.B(d,\"selectionchange\",l));a.a.g.set(b,k,c)};a.c.textInput={init:function(b,c,k){function l(c,d){a.a.B(b,c,d)}function m(){var d=a.a.f(c());if(null===d||d===n)d=\"\";L!==n&&d===L?a.a.setTimeout(m,4):b.value!==d&&(y=!0,b.value=d,y=!1,v=b.value)}function r(){w||(L=b.value,w=a.a.setTimeout(z,\n4))}function z(){clearTimeout(w);L=w=n;var d=b.value;v!==d&&(v=d,a.m.eb(c(),k,\"textInput\",d))}var v=b.value,w,L,A=9==a.a.W?r:z,y=!1;g&&l(\"keypress\",z);11>g&&l(\"propertychange\",function(a){y||\"value\"!==a.propertyName||A(a)});8==g&&(l(\"keyup\",z),l(\"keydown\",z));p&&(p(b,A),l(\"dragend\",r));(!g||9<=g)&&l(\"input\",A);5>e&&\"textarea\"===a.a.R(b)?(l(\"keydown\",r),l(\"paste\",r),l(\"cut\",r)):11>d?l(\"keydown\",r):4>f?(l(\"DOMAutoComplete\",z),l(\"dragdrop\",z),l(\"drop\",z)):h&&\"number\"===b.type&&l(\"keydown\",r);l(\"change\",\nz);l(\"blur\",z);a.o(m,null,{l:b})}};a.m.wa.textInput=!0;a.c.textinput={preprocess:function(a,b,c){c(\"textInput\",a)}}})();a.c.uniqueName={init:function(b,c){if(c()){var d=\"ko_unique_\"+ ++a.c.uniqueName.rd;a.a.Yc(b,d)}}};a.c.uniqueName.rd=0;a.c.using={init:function(b,c,d,e,f){var g;d.has(\"as\")&&(g={as:d.get(\"as\"),noChildContext:d.get(\"noChildContext\")});c=f.createChildContext(c,g);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.using=!0;a.c.value={init:function(b,c,d){var e=a.a.R(b),f=\"input\"==\ne;if(!f||\"checkbox\"!=b.type&&\"radio\"!=b.type){var g=[],h=d.get(\"valueUpdate\"),m=!1,k=null;h&&(\"string\"==typeof h?g=[h]:g=a.a.wc(h),a.a.Pa(g,\"change\"));var l=function(){k=null;m=!1;var e=c(),f=a.w.M(b);a.m.eb(e,d,\"value\",f)};!a.a.W||!f||\"text\"!=b.type||\"off\"==b.autocomplete||b.form&&\"off\"==b.form.autocomplete||-1!=a.a.A(g,\"propertychange\")||(a.a.B(b,\"propertychange\",function(){m=!0}),a.a.B(b,\"focus\",function(){m=!1}),a.a.B(b,\"blur\",function(){m&&l()}));a.a.D(g,function(c){var d=l;a.a.Ud(c,\"after\")&&\n(d=function(){k=a.w.M(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.B(b,c,d)});var p;p=f&&\"file\"==b.type?function(){var d=a.a.f(c());null===d||d===n||\"\"===d?b.value=\"\":a.u.G(l)}:function(){var f=a.a.f(c()),g=a.w.M(b);if(null!==k&&f===k)a.a.setTimeout(p,0);else if(f!==g||g===n)\"select\"===e?(g=d.get(\"valueAllowUnset\"),a.w.cb(b,f,g),g||f===a.w.M(b)||a.u.G(l)):a.w.cb(b,f)};if(\"select\"===e){var q;a.i.subscribe(b,a.i.H,function(){q?d.get(\"valueAllowUnset\")?p():l():(a.a.B(b,\"change\",l),q=a.o(p,null,{l:b}))},\nnull,{notifyImmediately:!0})}else a.a.B(b,\"change\",l),a.o(p,null,{l:b})}else a.ib(b,{checkedValue:c})},update:function(){}};a.m.wa.value=!0;a.c.visible={update:function(b,c){var d=a.a.f(c()),e=\"none\"!=b.style.display;d&&!e?b.style.display=\"\":!d&&e&&(b.style.display=\"none\")}};a.c.hidden={update:function(b,c){a.c.visible.update(b,function(){return!a.a.f(c())})}};(function(b){a.c[b]={init:function(c,d,e,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})(\"click\");\na.ca=function(){};a.ca.prototype.renderTemplateSource=function(){throw Error(\"Override renderTemplateSource\");};a.ca.prototype.createJavaScriptEvaluatorBlock=function(){throw Error(\"Override createJavaScriptEvaluatorBlock\");};a.ca.prototype.makeTemplateSource=function(b,c){if(\"string\"==typeof b){c=c||w;var d=c.getElementById(b);if(!d)throw Error(\"Cannot find template with ID \"+b);return new a.C.F(d)}if(1==b.nodeType||8==b.nodeType)return new a.C.ia(b);throw Error(\"Unknown template type: \"+b);};a.ca.prototype.renderTemplate=\nfunction(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.ca.prototype.isTemplateRewritten=function(a,c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data(\"isRewritten\")};a.ca.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data(\"isRewritten\",!0)};a.b(\"templateEngine\",a.ca);a.kc=function(){function b(b,c,d,h){b=a.m.ac(b);for(var m=a.m.Ra,k=0;k<b.length;k++){var l=b[k].key;if(Object.prototype.hasOwnProperty.call(m,\nl)){var p=m[l];if(\"function\"===typeof p){if(l=p(b[k].value))throw Error(l);}else if(!p)throw Error(\"This template engine does not support the '\"+l+\"' binding within its templates\");}}d=\"ko.__tr_ambtns(function($context,$element){return(function(){return{ \"+a.m.vb(b,{valueAccessors:!0})+\" } })()},'\"+d.toLowerCase()+\"')\";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\\d*)(?:\\s+(?!data-bind\\s*=\\s*)[a-z0-9\\-]+(?:=(?:\\\"[^\\\"]*\\\"|\\'[^\\']*\\'|[^>]*))?)*\\s+)data-bind\\s*=\\s*([\"'])([\\s\\S]*?)\\3/gi,\nd=/\\x3c!--\\s*ko\\b\\s*([\\s\\S]*?)\\s*--\\x3e/g;return{xd:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.kc.Ld(b,c)},d)},Ld:function(a,f){return a.replace(c,function(a,c,d,e,l){return b(l,c,d,f)}).replace(d,function(a,c){return b(c,\"\\x3c!-- ko --\\x3e\",\"#comment\",f)})},md:function(b,c){return a.aa.Xb(function(d,h){var m=d.nextSibling;m&&m.nodeName.toLowerCase()===c&&a.ib(m,b,h)})}}}();a.b(\"__tr_ambtns\",a.kc.md);(function(){a.C={};a.C.F=function(b){if(this.F=b){var c=\na.a.R(b);this.ab=\"script\"===c?1:\"textarea\"===c?2:\"template\"==c&&b.content&&11===b.content.nodeType?3:4}};a.C.F.prototype.text=function(){var b=1===this.ab?\"text\":2===this.ab?\"value\":\"innerHTML\";if(0==arguments.length)return this.F[b];var c=arguments[0];\"innerHTML\"===b?a.a.fc(this.F,c):this.F[b]=c};var b=a.a.g.Z()+\"_\";a.C.F.prototype.data=function(c){if(1===arguments.length)return a.a.g.get(this.F,b+c);a.a.g.set(this.F,b+c,arguments[1])};var c=a.a.g.Z();a.C.F.prototype.nodes=function(){var b=this.F;\nif(0==arguments.length){var e=a.a.g.get(b,c)||{},f=e.lb||(3===this.ab?b.content:4===this.ab?b:n);if(!f||e.jd){var g=this.text();g&&g!==e.bb&&(f=a.a.Md(g,b.ownerDocument),a.a.g.set(b,c,{lb:f,bb:g,jd:!0}))}return f}e=arguments[0];this.ab!==n&&this.text(\"\");a.a.g.set(b,c,{lb:e})};a.C.ia=function(a){this.F=a};a.C.ia.prototype=new a.C.F;a.C.ia.prototype.constructor=a.C.ia;a.C.ia.prototype.text=function(){if(0==arguments.length){var b=a.a.g.get(this.F,c)||{};b.bb===n&&b.lb&&(b.bb=b.lb.innerHTML);return b.bb}a.a.g.set(this.F,\nc,{bb:arguments[0]})};a.b(\"templateSources\",a.C);a.b(\"templateSources.domElement\",a.C.F);a.b(\"templateSources.anonymousTemplate\",a.C.ia)})();(function(){function b(b,c,d){var e;for(c=a.h.nextSibling(c);b&&(e=b)!==c;)b=a.h.nextSibling(e),d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=a.ga.instance,m=h.preprocessNode;if(m){b(e,f,function(a,b){var c=a.previousSibling,d=m.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):\n(c.push(e,f),a.a.Ua(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.vc(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.aa.cd(b,[d])});a.a.Ua(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,m){m=m||{};var n=(b&&d(b)||f||{}).ownerDocument,B=m.templateEngine||g;a.kc.xd(f,B,n);f=B.renderTemplate(f,h,m,n);if(\"number\"!=typeof f.length||0<f.length&&\"number\"!=typeof f[0].nodeType)throw Error(\"Template engine must return an array of DOM nodes\");n=!1;switch(e){case \"replaceChildren\":a.h.va(b,\nf);n=!0;break;case \"replaceNode\":a.a.Xc(b,f);n=!0;break;case \"ignoreTargetNode\":break;default:throw Error(\"Unknown renderMode: \"+e);}n&&(c(f,h),m.afterRender&&a.u.G(m.afterRender,null,[f,h[m.as||\"$data\"]]),\"replaceChildren\"==e&&a.i.ma(b,a.i.H));return f}function f(b,c,d){return a.O(b)?b():\"function\"===typeof b?b(c,d):b}var g;a.gc=function(b){if(b!=n&&!(b instanceof a.ca))throw Error(\"templateEngine must inherit from ko.templateEngine\");g=b};a.dc=function(b,c,h,m,t){h=h||{};if((h.templateEngine||g)==\nn)throw Error(\"Set a template engine before calling renderTemplate\");t=t||\"replaceChildren\";if(m){var x=d(m);return a.$(function(){var g=c&&c instanceof a.fa?c:new a.fa(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(m,t,n,g,h);\"replaceNode\"==t&&(m=g,x=d(m))},null,{Sa:function(){return!x||!a.a.Sb(x)},l:x&&\"replaceNode\"==t?x.parentNode:x})}return a.aa.Xb(function(d){a.dc(b,c,h,d,\"replaceNode\")})};a.Qd=function(b,d,g,h,m){function x(b,c){a.u.G(a.a.ec,null,[h,b,u,g,r,c]);a.i.ma(h,a.i.H)}\nfunction r(a,b){c(b,v);g.afterRender&&g.afterRender(b,a);v=null}function u(a,c){v=m.createChildContext(a,{as:z,noChildContext:g.noChildContext,extend:function(a){a.$index=c;z&&(a[z+\"Index\"]=c)}});var d=f(b,a,v);return e(h,\"ignoreTargetNode\",d,v,g)}var v,z=g.as,w=!1===g.includeDestroyed||a.options.foreachHidesDestroyed&&!g.includeDestroyed;if(w||g.beforeRemove||!a.Pc(d))return a.$(function(){var b=a.a.f(d)||[];\"undefined\"==typeof b.length&&(b=[b]);w&&(b=a.a.jb(b,function(b){return b===n||null===b||\n!a.a.f(b._destroy)}));x(b)},null,{l:h});x(d.v());var A=d.subscribe(function(a){x(d(),a)},null,\"arrayChange\");A.l(h);return A};var h=a.a.g.Z(),m=a.a.g.Z();a.c.template={init:function(b,c){var d=a.a.f(c());if(\"string\"==typeof d||\"name\"in d)a.h.Ea(b);else if(\"nodes\"in d){d=d.nodes||[];if(a.O(d))throw Error('The \"nodes\" option must be a plain, non-observable array.');var e=d[0]&&d[0].parentNode;e&&a.a.g.get(e,m)||(e=a.a.Yb(d),a.a.g.set(e,m,!0));(new a.C.ia(b)).nodes(e)}else if(d=a.h.childNodes(b),0<d.length)e=\na.a.Yb(d),(new a.C.ia(b)).nodes(e);else throw Error(\"Anonymous template defined, but no template content was provided\");return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.f(g);d=!0;e=null;\"string\"==typeof c?c={}:(g=\"name\"in c?c.name:b,\"if\"in c&&(d=a.a.f(c[\"if\"])),d&&\"ifnot\"in c&&(d=!a.a.f(c.ifnot)),d&&!g&&(d=!1));\"foreach\"in c?e=a.Qd(g,d&&c.foreach||[],c,b,f):d?(d=f,\"data\"in c&&(d=f.createChildContext(c.data,{as:c.as,noChildContext:c.noChildContext,exportDependencies:!0})),\ne=a.dc(g,d,c,b)):a.h.Ea(b);f=e;(c=a.a.g.get(b,h))&&\"function\"==typeof c.s&&c.s();a.a.g.set(b,h,!f||f.ja&&!f.ja()?n:f)}};a.m.Ra.template=function(b){b=a.m.ac(b);return 1==b.length&&b[0].unknown||a.m.Id(b,\"name\")?null:\"This template engine does not support anonymous templates nested within its templates\"};a.h.ea.template=!0})();a.b(\"setTemplateEngine\",a.gc);a.b(\"renderTemplate\",a.dc);a.a.Kc=function(a,c,d){if(a.length&&c.length){var e,f,g,h,m;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;m=c[g];++g)if(h.value===\nm.value){h.moved=m.index;m.moved=h.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.Pb=function(){function b(b,d,e,f,g){var h=Math.min,m=Math.max,k=[],l,p=b.length,q,n=d.length,r=n-p||1,v=p+n+1,u,w,z;for(l=0;l<=p;l++)for(w=u,k.push(u=[]),z=h(n,l+r),q=m(0,l-1);q<=z;q++)u[q]=q?l?b[l-1]===d[q-1]?w[q-1]:h(w[q]||v,u[q-1]||v)+1:q+1:l+1;h=[];m=[];r=[];l=p;for(q=n;l||q;)n=k[l][q]-1,q&&n===k[l][q-1]?m.push(h[h.length]={status:e,value:d[--q],index:q}):l&&n===k[l-1][q]?r.push(h[h.length]={status:f,value:b[--l],index:l}):\n(--q,--l,g.sparse||h.push({status:\"retained\",value:d[q]}));a.a.Kc(r,m,!g.dontLimitMoves&&10*p);return h.reverse()}return function(a,d,e){e=\"boolean\"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,\"added\",\"deleted\",e):b(d,a,\"deleted\",\"added\",e)}}();a.b(\"utils.compareArrays\",a.a.Pb);(function(){function b(b,c,d,h,m){var k=[],l=a.$(function(){var l=c(d,m,a.a.Ua(k,b))||[];0<k.length&&(a.a.Xc(k,l),h&&a.u.G(h,null,[d,l,m]));k.length=0;a.a.Nb(k,l)},null,{l:b,Sa:function(){return!a.a.kd(k)}});\nreturn{Y:k,$:l.ja()?l:n}}var c=a.a.g.Z(),d=a.a.g.Z();a.a.ec=function(e,f,g,h,m,k){function l(b){y={Aa:b,pb:a.ta(w++)};v.push(y);r||F.push(y)}function p(b){y=t[b];w!==y.pb.v()&&D.push(y);y.pb(w++);a.a.Ua(y.Y,e);v.push(y)}function q(b,c){if(b)for(var d=0,e=c.length;d<e;d++)a.a.D(c[d].Y,function(a){b(a,d,c[d].Aa)})}f=f||[];\"undefined\"==typeof f.length&&(f=[f]);h=h||{};var t=a.a.g.get(e,c),r=!t,v=[],u=0,w=0,z=[],A=[],C=[],D=[],F=[],y,I=0;if(r)a.a.D(f,l);else{if(!k||t&&t._countWaitingForRemove){var E=\na.a.Mb(t,function(a){return a.Aa});k=a.a.Pb(E,f,{dontLimitMoves:h.dontLimitMoves,sparse:!0})}for(var E=0,G,H,K;G=k[E];E++)switch(H=G.moved,K=G.index,G.status){case \"deleted\":for(;u<K;)p(u++);H===n&&(y=t[u],y.$&&(y.$.s(),y.$=n),a.a.Ua(y.Y,e).length&&(h.beforeRemove&&(v.push(y),I++,y.Aa===d?y=null:C.push(y)),y&&z.push.apply(z,y.Y)));u++;break;case \"added\":for(;w<K;)p(u++);H!==n?(A.push(v.length),p(H)):l(G.value)}for(;w<f.length;)p(u++);v._countWaitingForRemove=I}a.a.g.set(e,c,v);q(h.beforeMove,D);a.a.D(z,\nh.beforeRemove?a.oa:a.removeNode);var M,O,P;try{P=e.ownerDocument.activeElement}catch(N){}if(A.length)for(;(E=A.shift())!=n;){y=v[E];for(M=n;E;)if((O=v[--E].Y)&&O.length){M=O[O.length-1];break}for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M)}for(E=0;y=v[E];E++){y.Y||a.a.extend(y,b(e,g,y.Aa,m,y.pb));for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);!y.Ed&&m&&(m(y.Aa,y.Y,y.pb),y.Ed=!0,M=y.Y[y.Y.length-1])}P&&e.ownerDocument.activeElement!=P&&P.focus();q(h.beforeRemove,C);for(E=0;E<C.length;++E)C[E].Aa=d;q(h.afterMove,D);\nq(h.afterAdd,F)}})();a.b(\"utils.setDomNodeChildrenFromArrayMapping\",a.a.ec);a.ba=function(){this.allowTemplateRewriting=!1};a.ba.prototype=new a.ca;a.ba.prototype.constructor=a.ba;a.ba.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.W?0:b.nodes)?b.nodes():null)return a.a.la(c.cloneNode(!0).childNodes);b=b.text();return a.a.ua(b,e)};a.ba.Ma=new a.ba;a.gc(a.ba.Ma);a.b(\"nativeTemplateEngine\",a.ba);(function(){a.$a=function(){var a=this.Hd=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf(\"__\"))return 2}catch(a){}return 1}();\nthis.renderTemplateSource=function(b,e,f,g){g=g||w;f=f||{};if(2>a)throw Error(\"Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.\");var h=b.data(\"precompiled\");h||(h=b.text()||\"\",h=v.template(null,\"{{ko_with $item.koBindingContext}}\"+h+\"{{/ko_with}}\"),b.data(\"precompiled\",h));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(h,b,e);e.appendTo(g.createElement(\"div\"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return\"{{ko_code ((function() { return \"+\na+\" })()) }}\"};this.addTemplate=function(a,b){w.write(\"<script type='text/html' id='\"+a+\"'>\"+b+\"\\x3c/script>\")};0<a&&(v.tmpl.tag.ko_code={open:\"__.push($1 || '');\"},v.tmpl.tag.ko_with={open:\"with($1) {\",close:\"} \"})};a.$a.prototype=new a.ca;a.$a.prototype.constructor=a.$a;var b=new a.$a;0<b.Hd&&a.gc(b);a.b(\"jqueryTmplTemplateEngine\",a.$a)})()})})();})();\n\n})();\n\n// Avoid polluting the global scope.\nvar knockout = ko;\nif (typeof window !== 'undefined') {\n    ko = window.ko;\n    if (typeof oldValue !== 'undefined') {\n        window.ko = oldValue;\n    } else {\n        delete window.ko;\n    }\n} else {\n    ko = global.ko;\n    if (typeof oldValue !== 'undefined') {\n        global.ko = oldValue;\n    } else {\n        delete global.ko;\n    }\n}\n\n/* harmony default export */ const knockout_3_5_1 = (knockout);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/ThirdParty/knockout-es5.js\n/**\n * @license\n * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5\n * Copyright (c) Steve Sanderson\n * MIT license\n */\n\n    var OBSERVABLES_PROPERTY = '__knockoutObservables';\n    var SUBSCRIBABLE_PROPERTY = '__knockoutSubscribable';\n\n    // Model tracking\n    // --------------\n    //\n    // This is the central feature of Knockout-ES5. We augment model objects by converting properties\n    // into ES5 getter/setter pairs that read/write an underlying Knockout observable. This means you can\n    // use plain JavaScript syntax to read/write the property while still getting the full benefits of\n    // Knockout's automatic dependency detection and notification triggering.\n    //\n    // For comparison, here's Knockout ES3-compatible syntax:\n    //\n    //     var firstNameLength = myModel.user().firstName().length; // Read\n    //     myModel.user().firstName('Bert'); // Write\n    //\n    // ... versus Knockout-ES5 syntax:\n    //\n    //     var firstNameLength = myModel.user.firstName.length; // Read\n    //     myModel.user.firstName = 'Bert'; // Write\n\n    // `ko.track(model)` converts each property on the given model object into a getter/setter pair that\n    // wraps a Knockout observable. Optionally specify an array of property names to wrap; otherwise we\n    // wrap all properties. If any of the properties are already observables, we replace them with\n    // ES5 getter/setter pairs that wrap your original observable instances. In the case of readonly\n    // ko.computed properties, we simply do not define a setter (so attempted writes will be ignored,\n    // which is how ES5 readonly properties normally behave).\n    //\n    // By design, this does *not* recursively walk child object properties, because making literally\n    // everything everywhere independently observable is usually unhelpful. When you do want to track\n    // child object properties independently, define your own class for those child objects and put\n    // a separate ko.track call into its constructor --- this gives you far more control.\n    function track(obj, propertyNames) {\n        if (!obj /*|| typeof obj !== 'object'*/) {\n            throw new Error('When calling ko.track, you must pass an object as the first parameter.');\n        }\n\n        var ko = this,\n            allObservablesForObject = getAllObservablesForObject(obj, true);\n        propertyNames = propertyNames || Object.getOwnPropertyNames(obj);\n\n        propertyNames.forEach(function(propertyName) {\n            // Skip storage properties\n            if (propertyName === OBSERVABLES_PROPERTY || propertyName === SUBSCRIBABLE_PROPERTY) {\n                return;\n            }\n            // Skip properties that are already tracked\n            if (propertyName in allObservablesForObject) {\n                return;\n            }\n\n            var origValue = obj[propertyName],\n                isArray = origValue instanceof Array,\n                observable = ko.isObservable(origValue) ? origValue\n                                              : isArray ? ko.observableArray(origValue)\n                                                        : ko.observable(origValue);\n\n            Object.defineProperty(obj, propertyName, {\n                configurable: true,\n                enumerable: true,\n                get: observable,\n                set: ko.isWriteableObservable(observable) ? observable : undefined\n            });\n\n            allObservablesForObject[propertyName] = observable;\n\n            if (isArray) {\n                notifyWhenPresentOrFutureArrayValuesMutate(ko, observable);\n            }\n        });\n\n        return obj;\n    }\n\n    // Gets or creates the hidden internal key-value collection of observables corresponding to\n    // properties on the model object.\n    function getAllObservablesForObject(obj, createIfNotDefined) {\n        var result = obj[OBSERVABLES_PROPERTY];\n        if (!result && createIfNotDefined) {\n            result = {};\n            Object.defineProperty(obj, OBSERVABLES_PROPERTY, {\n                value : result\n            });\n        }\n        return result;\n    }\n\n    // Computed properties\n    // -------------------\n    //\n    // The preceding code is already sufficient to upgrade ko.computed model properties to ES5\n    // getter/setter pairs (or in the case of readonly ko.computed properties, just a getter).\n    // These then behave like a regular property with a getter function, except they are smarter:\n    // your evaluator is only invoked when one of its dependencies changes. The result is cached\n    // and used for all evaluations until the next time a dependency changes).\n    //\n    // However, instead of forcing developers to declare a ko.computed property explicitly, it's\n    // nice to offer a utility function that declares a computed getter directly.\n\n    // Implements `ko.defineProperty`\n    function defineComputedProperty(obj, propertyName, evaluatorOrOptions) {\n        var ko = this,\n            computedOptions = { owner: obj, deferEvaluation: true };\n\n        if (typeof evaluatorOrOptions === 'function') {\n            computedOptions.read = evaluatorOrOptions;\n        } else {\n            if ('value' in evaluatorOrOptions) {\n                throw new Error('For ko.defineProperty, you must not specify a \"value\" for the property. You must provide a \"get\" function.');\n            }\n\n            if (typeof evaluatorOrOptions.get !== 'function') {\n                throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called \"get\".');\n            }\n\n            computedOptions.read = evaluatorOrOptions.get;\n            computedOptions.write = evaluatorOrOptions.set;\n        }\n\n        obj[propertyName] = ko.computed(computedOptions);\n        track.call(ko, obj, [propertyName]);\n        return obj;\n    }\n\n    // Array handling\n    // --------------\n    //\n    // Arrays are special, because unlike other property types, they have standard mutator functions\n    // (`push`/`pop`/`splice`/etc.) and it's desirable to trigger a change notification whenever one of\n    // those mutator functions is invoked.\n    //\n    // Traditionally, Knockout handles this by putting special versions of `push`/`pop`/etc. on observable\n    // arrays that mutate the underlying array and then trigger a notification. That approach doesn't\n    // work for Knockout-ES5 because properties now return the underlying arrays, so the mutator runs\n    // in the context of the underlying array, not any particular observable:\n    //\n    //     // Operates on the underlying array value\n    //     myModel.someCollection.push('New value');\n    //\n    // To solve this, Knockout-ES5 detects array values, and modifies them as follows:\n    //  1. Associates a hidden subscribable with each array instance that it encounters\n    //  2. Intercepts standard mutators (`push`/`pop`/etc.) and makes them trigger the subscribable\n    // Then, for model properties whose values are arrays, the property's underlying observable\n    // subscribes to the array subscribable, so it can trigger a change notification after mutation.\n\n    // Given an observable that underlies a model property, watch for any array value that might\n    // be assigned as the property value, and hook into its change events\n    function notifyWhenPresentOrFutureArrayValuesMutate(ko, observable) {\n        var watchingArraySubscription = null;\n        ko.computed(function () {\n            // Unsubscribe to any earlier array instance\n            if (watchingArraySubscription) {\n                watchingArraySubscription.dispose();\n                watchingArraySubscription = null;\n            }\n\n            // Subscribe to the new array instance\n            var newArrayInstance = observable();\n            if (newArrayInstance instanceof Array) {\n                watchingArraySubscription = startWatchingArrayInstance(ko, observable, newArrayInstance);\n            }\n        });\n    }\n\n    // Listens for array mutations, and when they happen, cause the observable to fire notifications.\n    // This is used to make model properties of type array fire notifications when the array changes.\n    // Returns a subscribable that can later be disposed.\n    function startWatchingArrayInstance(ko, observable, arrayInstance) {\n        var subscribable = getSubscribableForArray(ko, arrayInstance);\n        return subscribable.subscribe(observable);\n    }\n\n    // Gets or creates a subscribable that fires after each array mutation\n    function getSubscribableForArray(ko, arrayInstance) {\n        var subscribable = arrayInstance[SUBSCRIBABLE_PROPERTY];\n        if (!subscribable) {\n            subscribable = new ko.subscribable();\n            Object.defineProperty(arrayInstance, SUBSCRIBABLE_PROPERTY, {\n                value : subscribable\n            });\n\n            var notificationPauseSignal = {};\n            wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal);\n            addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal);\n        }\n\n        return subscribable;\n    }\n\n    // After each array mutation, fires a notification on the given subscribable\n    function wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal) {\n        ['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'].forEach(function(fnName) {\n            var origMutator = arrayInstance[fnName];\n            arrayInstance[fnName] = function() {\n                var result = origMutator.apply(this, arguments);\n                if (notificationPauseSignal.pause !== true) {\n                    subscribable.notifySubscribers(this);\n                }\n                return result;\n            };\n        });\n    }\n\n    // Adds Knockout's additional array mutation functions to the array\n    function addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal) {\n        ['remove', 'removeAll', 'destroy', 'destroyAll', 'replace'].forEach(function(fnName) {\n            // Make it a non-enumerable property for consistency with standard Array functions\n            Object.defineProperty(arrayInstance, fnName, {\n                enumerable: false,\n                value: function() {\n                    var result;\n\n                    // These additional array mutators are built using the underlying push/pop/etc.\n                    // mutators, which are wrapped to trigger notifications. But we don't want to\n                    // trigger multiple notifications, so pause the push/pop/etc. wrappers and\n                    // delivery only one notification at the end of the process.\n                    notificationPauseSignal.pause = true;\n                    try {\n                        // Creates a temporary observableArray that can perform the operation.\n                        result = ko.observableArray.fn[fnName].apply(ko.observableArray(arrayInstance), arguments);\n                    }\n                    finally {\n                        notificationPauseSignal.pause = false;\n                    }\n                    subscribable.notifySubscribers(arrayInstance);\n                    return result;\n                }\n            });\n        });\n    }\n\n    // Static utility functions\n    // ------------------------\n    //\n    // Since Knockout-ES5 sets up properties that return values, not observables, you can't\n    // trivially subscribe to the underlying observables (e.g., `someProperty.subscribe(...)`),\n    // or tell them that object values have mutated, etc. To handle this, we set up some\n    // extra utility functions that can return or work with the underlying observables.\n\n    // Returns the underlying observable associated with a model property (or `null` if the\n    // model or property doesn't exist, or isn't associated with an observable). This means\n    // you can subscribe to the property, e.g.:\n    //\n    //     ko.getObservable(model, 'propertyName')\n    //       .subscribe(function(newValue) { ... });\n    function getObservable(obj, propertyName) {\n        if (!obj /*|| typeof obj !== 'object'*/) {\n            return null;\n        }\n\n        var allObservablesForObject = getAllObservablesForObject(obj, false);\n        return (allObservablesForObject && allObservablesForObject[propertyName]) || null;\n    }\n\n    // Causes a property's associated observable to fire a change notification. Useful when\n    // the property value is a complex object and you've modified a child property.\n    function valueHasMutated(obj, propertyName) {\n        var observable = getObservable(obj, propertyName);\n\n        if (observable) {\n            observable.valueHasMutated();\n        }\n    }\n\n    // Extends a Knockout instance with Knockout-ES5 functionality\n    function attachToKo(ko) {\n        ko.track = track;\n        ko.getObservable = getObservable;\n        ko.valueHasMutated = valueHasMutated;\n        ko.defineProperty = defineComputedProperty;\n    }\n\n    /* harmony default export */ const knockout_es5 = ({\n        attachToKo : attachToKo\n    });\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Widgets/SvgPathBindingHandler.js\nconst svgNS = \"http://www.w3.org/2000/svg\";\nconst svgClassName = \"cesium-svgPath-svg\";\n\n/**\n * A Knockout binding handler that creates a DOM element for a single SVG path.\n * This binding handler will be registered as cesiumSvgPath.\n *\n * <p>\n * The parameter to this binding is an object with the following properties:\n * </p>\n *\n * <ul>\n * <li>path: The SVG path as a string.</li>\n * <li>width: The width of the SVG path with no transformations applied.</li>\n * <li>height: The height of the SVG path with no transformations applied.</li>\n * <li>css: Optional. A string containing additional CSS classes to apply to the SVG. 'cesium-svgPath-svg' is always applied.</li>\n * </ul>\n *\n * @namespace SvgPathBindingHandler\n *\n * @example\n * // Create an SVG as a child of a div\n * <div data-bind=\"cesiumSvgPath: { path: 'M 100 100 L 300 100 L 200 300 z', width: 28, height: 28 }\"></div>\n *\n * // parameters can be observable from the view model\n * <div data-bind=\"cesiumSvgPath: { path: currentPath, width: currentWidth, height: currentHeight }\"></div>\n *\n * // or the whole object can be observable from the view model\n * <div data-bind=\"cesiumSvgPath: svgPathOptions\"></div>\n */\nconst SvgPathBindingHandler = {\n  /**\n   * @function\n   */\n  register: function (knockout) {\n    knockout.bindingHandlers.cesiumSvgPath = {\n      init: function (element, valueAccessor) {\n        const svg = document.createElementNS(svgNS, \"svg:svg\");\n        svg.setAttribute(\"class\", svgClassName);\n\n        const pathElement = document.createElementNS(svgNS, \"path\");\n        svg.appendChild(pathElement);\n\n        knockout.virtualElements.setDomNodeChildren(element, [svg]);\n\n        knockout.computed({\n          read: function () {\n            const value = knockout.unwrap(valueAccessor());\n\n            pathElement.setAttribute(\"d\", knockout.unwrap(value.path));\n\n            const pathWidth = knockout.unwrap(value.width);\n            const pathHeight = knockout.unwrap(value.height);\n\n            svg.setAttribute(\"width\", pathWidth);\n            svg.setAttribute(\"height\", pathHeight);\n            svg.setAttribute(\"viewBox\", `0 0 ${pathWidth} ${pathHeight}`);\n\n            if (value.css) {\n              svg.setAttribute(\n                \"class\",\n                `${svgClassName} ${knockout.unwrap(value.css)}`\n              );\n            }\n          },\n          disposeWhenNodeIsRemoved: element,\n        });\n\n        return {\n          controlsDescendantBindings: true,\n        };\n      },\n    };\n\n    knockout.virtualElements.allowedBindings.cesiumSvgPath = true;\n  },\n};\n/* harmony default export */ const Widgets_SvgPathBindingHandler = (SvgPathBindingHandler);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/ThirdParty/knockout.js\n\n\n\n\n// install the Knockout-ES5 plugin\nknockout_es5.attachToKo(knockout_3_5_1);\n\n// Register all Cesium binding handlers\nWidgets_SvgPathBindingHandler.register(knockout_3_5_1);\n\n/* harmony default export */ const ThirdParty_knockout = (knockout_3_5_1);\n\n// EXTERNAL MODULE: ./node_modules/markdown-it-sanitizer/index.js\nvar markdown_it_sanitizer = __webpack_require__(\"./node_modules/markdown-it-sanitizer/index.js\");\nvar markdown_it_sanitizer_default = /*#__PURE__*/__webpack_require__.n(markdown_it_sanitizer);\n// EXTERNAL MODULE: ./node_modules/markdown-it/index.js\nvar markdown_it = __webpack_require__(\"./node_modules/markdown-it/index.js\");\nvar markdown_it_default = /*#__PURE__*/__webpack_require__.n(markdown_it);\n;// CONCATENATED MODULE: ./core/KnockoutMarkdownBinding.js\n/* eslint-disable no-unused-vars */\n\n\nvar htmlTagRegex = /<html(.|\\s)*>(.|\\s)*<\\/html>/im;\nvar md = new (markdown_it_default())({\n  html: true,\n  linkify: true\n});\nmd.use((markdown_it_sanitizer_default()), {\n  imageClass: '',\n  removeUnbalanced: false,\n  removeUnknown: false\n});\nvar KnockoutMarkdownBinding = {\n  register: function register(Knockout) {\n    Knockout.bindingHandlers.markdown = {\n      'init': function init() {\n        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)\n        return {\n          'controlsDescendantBindings': true\n        };\n      },\n      'update': function update(element, valueAccessor) {\n        // Remove existing children of this element.\n        while (element.firstChild) {\n          Knockout.removeNode(element.firstChild);\n        }\n        var rawText = Knockout.unwrap(valueAccessor());\n\n        // If the text contains an <html> tag, don't try to interpret it as Markdown because\n        // we'll probably break it in the process.\n        var html;\n        if (htmlTagRegex.test(rawText)) {\n          html = rawText;\n        } else {\n          html = md.render(rawText);\n        }\n        var nodes = Knockout.utils.parseHtmlFragment(html, element);\n        element.className = element.className + ' markdown';\n        for (var i = 0; i < nodes.length; ++i) {\n          var node = nodes[i];\n          setAnchorTargets(node);\n          element.appendChild(node);\n        }\n      }\n    };\n  }\n};\nfunction setAnchorTargets(element) {\n  if (element instanceof HTMLAnchorElement) {\n    element.target = '_blank';\n  }\n  if (element.childNodes && element.childNodes.length > 0) {\n    for (var i = 0; i < element.childNodes.length; ++i) {\n      setAnchorTargets(element.childNodes[i]);\n    }\n  }\n}\n/* harmony default export */ const core_KnockoutMarkdownBinding = (KnockoutMarkdownBinding);\n// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js\nvar hammer = __webpack_require__(\"./node_modules/hammerjs/hammer.js\");\nvar hammer_default = /*#__PURE__*/__webpack_require__.n(hammer);\n;// CONCATENATED MODULE: ./core/KnockoutHammerBinding.js\n/* eslint-disable no-unused-vars */\n\n\nvar Knockout = ThirdParty_knockout;\nvar KnockoutHammerBinding = {\n  register: function register(Knockout) {\n    Knockout.bindingHandlers.swipeLeft = {\n      init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var f = Knockout.unwrap(valueAccessor());\n        new (hammer_default())(element).on('swipeleft', function (e) {\n          var viewModel = bindingContext.$data;\n          f.apply(viewModel, arguments);\n        });\n      }\n    };\n    Knockout.bindingHandlers.swipeRight = {\n      init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var f = Knockout.unwrap(valueAccessor());\n        new (hammer_default())(element).on('swiperight', function (e) {\n          var viewModel = bindingContext.$data;\n          f.apply(viewModel, arguments);\n        });\n      }\n    };\n  }\n};\n/* harmony default export */ const core_KnockoutHammerBinding = (KnockoutHammerBinding);\n;// CONCATENATED MODULE: ./core/registerKnockoutBindings.js\n/* eslint-disable no-unused-vars */\n\n\n\nvar registerKnockoutBindings_Knockout = ThirdParty_knockout;\nvar registerKnockoutBindings = function registerKnockoutBindings() {\n  Widgets_SvgPathBindingHandler.register(registerKnockoutBindings_Knockout);\n  core_KnockoutMarkdownBinding.register(registerKnockoutBindings_Knockout);\n  core_KnockoutHammerBinding.register(registerKnockoutBindings_Knockout);\n  registerKnockoutBindings_Knockout.bindingHandlers.embeddedComponent = {\n    init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {\n      var component = registerKnockoutBindings_Knockout.unwrap(valueAccessor());\n      component.show(element);\n      return {\n        controlsDescendantBindings: true\n      };\n    },\n    update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {}\n  };\n};\n/* harmony default export */ const core_registerKnockoutBindings = (registerKnockoutBindings);\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/EventHelper.js\n\n\n\n/**\n * A convenience object that simplifies the common pattern of attaching event listeners\n * to several events, then removing all those listeners at once later, for example, in\n * a destroy method.\n *\n * @alias EventHelper\n * @constructor\n *\n *\n * @example\n * const helper = new Cesium.EventHelper();\n *\n * helper.add(someObject.event, listener1, this);\n * helper.add(otherObject.event, listener2, this);\n *\n * // later...\n * helper.removeAll();\n *\n * @see Event\n */\nfunction EventHelper() {\n  this._removalFunctions = [];\n}\n\n/**\n * Adds a listener to an event, and records the registration to be cleaned up later.\n *\n * @param {Event} event The event to attach to.\n * @param {Function} listener The function to be executed when the event is raised.\n * @param {Object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {EventHelper.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#addEventListener\n */\nEventHelper.prototype.add = function (event, listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(event)) {\n    throw new Core_DeveloperError(\"event is required\");\n  }\n  //>>includeEnd('debug');\n\n  const removalFunction = event.addEventListener(listener, scope);\n  this._removalFunctions.push(removalFunction);\n\n  const that = this;\n  return function () {\n    removalFunction();\n    const removalFunctions = that._removalFunctions;\n    removalFunctions.splice(removalFunctions.indexOf(removalFunction), 1);\n  };\n};\n\n/**\n * Unregisters all previously added listeners.\n *\n * @see Event#removeEventListener\n */\nEventHelper.prototype.removeAll = function () {\n  const removalFunctions = this._removalFunctions;\n  for (let i = 0, len = removalFunctions.length; i < len; ++i) {\n    removalFunctions[i]();\n  }\n  removalFunctions.length = 0;\n};\n\n/**\n * A function that removes a listener.\n * @callback EventHelper.RemoveCallback\n */\n/* harmony default export */ const Core_EventHelper = (EventHelper);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/defaultValue.js\n/**\n * Returns the first parameter if not undefined, otherwise the second parameter.\n * Useful for setting a default value for a parameter.\n *\n * @function\n *\n * @param {*} a\n * @param {*} b\n * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.\n *\n * @example\n * param = Cesium.defaultValue(param, 'default');\n */\nfunction defaultValue(a, b) {\n  if (a !== undefined && a !== null) {\n    return a;\n  }\n  return b;\n}\n\n/**\n * A frozen empty object that can be used as the default value for options passed as\n * an object literal.\n * @type {Object}\n * @memberof defaultValue\n */\ndefaultValue.EMPTY_OBJECT = Object.freeze({});\n\n/* harmony default export */ const Core_defaultValue = (defaultValue);\n\n// EXTERNAL MODULE: ./node_modules/mersenne-twister/src/mersenne-twister.js\nvar mersenne_twister = __webpack_require__(\"./node_modules/mersenne-twister/src/mersenne-twister.js\");\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Math.js\n\n\n\n\n\n\n/**\n * Math functions.\n *\n * @exports CesiumMath\n * @alias Math\n */\nconst CesiumMath = {};\n\n/**\n * 0.1\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON1 = 0.1;\n\n/**\n * 0.01\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON2 = 0.01;\n\n/**\n * 0.001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON3 = 0.001;\n\n/**\n * 0.0001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON4 = 0.0001;\n\n/**\n * 0.00001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON5 = 0.00001;\n\n/**\n * 0.000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON6 = 0.000001;\n\n/**\n * 0.0000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON7 = 0.0000001;\n\n/**\n * 0.00000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON8 = 0.00000001;\n\n/**\n * 0.000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON9 = 0.000000001;\n\n/**\n * 0.0000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON10 = 0.0000000001;\n\n/**\n * 0.00000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON11 = 0.00000000001;\n\n/**\n * 0.000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON12 = 0.000000000001;\n\n/**\n * 0.0000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON13 = 0.0000000000001;\n\n/**\n * 0.00000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON14 = 0.00000000000001;\n\n/**\n * 0.000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON15 = 0.000000000000001;\n\n/**\n * 0.0000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON16 = 0.0000000000000001;\n\n/**\n * 0.00000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON17 = 0.00000000000000001;\n\n/**\n * 0.000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON18 = 0.000000000000000001;\n\n/**\n * 0.0000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON19 = 0.0000000000000000001;\n\n/**\n * 0.00000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON20 = 0.00000000000000000001;\n\n/**\n * 0.000000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON21 = 0.000000000000000000001;\n\n/**\n * The gravitational parameter of the Earth in meters cubed\n * per second squared as defined by the WGS84 model: 3.986004418e14\n * @type {Number}\n * @constant\n */\nCesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n\n/**\n * Radius of the sun in meters: 6.955e8\n * @type {Number}\n * @constant\n */\nCesiumMath.SOLAR_RADIUS = 6.955e8;\n\n/**\n * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n * Celestial Mechanics 82: 83-110, 2002.\n * @type {Number}\n * @constant\n */\nCesiumMath.LUNAR_RADIUS = 1737400.0;\n\n/**\n * 64 * 1024\n * @type {Number}\n * @constant\n */\nCesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n\n/**\n * 4 * 1024 * 1024 * 1024\n * @type {Number}\n * @constant\n */\nCesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;\n\n/**\n * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n * negative, or 0 if the value is 0.\n *\n * @function\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\n// eslint-disable-next-line es/no-math-sign\nCesiumMath.sign = Core_defaultValue(Math.sign, function sign(value) {\n  value = +value; // coerce to number\n  if (value === 0 || value !== value) {\n    // zero or NaN\n    return value;\n  }\n  return value > 0 ? 1 : -1;\n});\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\nCesiumMath.signNotZero = function (value) {\n  return value < 0.0 ? -1.0 : 1.0;\n};\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {Number} value The scalar value in the range [-1.0, 1.0]\n * @param {Number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nCesiumMath.toSNorm = function (value, rangeMaximum) {\n  rangeMaximum = Core_defaultValue(rangeMaximum, 255);\n  return Math.round(\n    (CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum\n  );\n};\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {Number} value SNORM value in the range [0, rangeMaximum]\n * @param {Number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {Number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nCesiumMath.fromSNorm = function (value, rangeMaximum) {\n  rangeMaximum = Core_defaultValue(rangeMaximum, 255);\n  return (\n    (CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0\n  );\n};\n\n/**\n * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]\n * @param {Number} value The scalar value in the range [rangeMinimum, rangeMaximum]\n * @param {Number} rangeMinimum The minimum value in the mapped range.\n * @param {Number} rangeMaximum The maximum value in the mapped range.\n * @returns {Number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.\n */\nCesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {\n  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);\n  return rangeMaximum === 0.0\n    ? 0.0\n    : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);\n};\n\n/**\n * Returns the hyperbolic sine of a number.\n * The hyperbolic sine of <em>value</em> is defined to be\n * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is an infinity\n *     with the same sign as the argument.</li>\n *\n *     <li>If the argument is zero, then the result is a zero with the\n *     same sign as the argument.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic sine is to be returned.\n * @returns {Number} The hyperbolic sine of <code>value</code>.\n */\n// eslint-disable-next-line es/no-math-sinh\nCesiumMath.sinh = Core_defaultValue(Math.sinh, function sinh(value) {\n  return (Math.exp(value) - Math.exp(-value)) / 2.0;\n});\n\n/**\n * Returns the hyperbolic cosine of a number.\n * The hyperbolic cosine of <strong>value</strong> is defined to be\n * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is positive infinity.</li>\n *\n *     <li>If the argument is zero, then the result is 1.0.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic cosine is to be returned.\n * @returns {Number} The hyperbolic cosine of <code>value</code>.\n */\n// eslint-disable-next-line es/no-math-cosh\nCesiumMath.cosh = Core_defaultValue(Math.cosh, function cosh(value) {\n  return (Math.exp(value) + Math.exp(-value)) / 2.0;\n});\n\n/**\n * Computes the linear interpolation of two values.\n *\n * @param {Number} p The start value to interpolate.\n * @param {Number} q The end value to interpolate.\n * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n * @returns {Number} The linearly interpolated value.\n *\n * @example\n * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n */\nCesiumMath.lerp = function (p, q, time) {\n  return (1.0 - time) * p + time * q;\n};\n\n/**\n * pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI = Math.PI;\n\n/**\n * 1/pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n\n/**\n * pi/2\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_TWO = Math.PI / 2.0;\n\n/**\n * pi/3\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n\n/**\n * pi/4\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n\n/**\n * pi/6\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n\n/**\n * 3pi/2\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) / 2.0;\n\n/**\n * 2pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.TWO_PI = 2.0 * Math.PI;\n\n/**\n * 1/2pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n\n/**\n * The number of radians in a degree.\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n\n/**\n * The number of degrees in a radian.\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n\n/**\n * The number of radians in an arc second.\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n\n/**\n * Converts degrees to radians.\n * @param {Number} degrees The angle to convert in degrees.\n * @returns {Number} The corresponding angle in radians.\n */\nCesiumMath.toRadians = function (degrees) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(degrees)) {\n    throw new Core_DeveloperError(\"degrees is required.\");\n  }\n  //>>includeEnd('debug');\n  return degrees * CesiumMath.RADIANS_PER_DEGREE;\n};\n\n/**\n * Converts radians to degrees.\n * @param {Number} radians The angle to convert in radians.\n * @returns {Number} The corresponding angle in degrees.\n */\nCesiumMath.toDegrees = function (radians) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(radians)) {\n    throw new Core_DeveloperError(\"radians is required.\");\n  }\n  //>>includeEnd('debug');\n  return radians * CesiumMath.DEGREES_PER_RADIAN;\n};\n\n/**\n * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @example\n * // Convert 270 degrees to -90 degrees longitude\n * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n */\nCesiumMath.convertLongitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(angle)) {\n    throw new Core_DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  const twoPi = CesiumMath.TWO_PI;\n\n  const simplified = angle - Math.floor(angle / twoPi) * twoPi;\n\n  if (simplified < -Math.PI) {\n    return simplified + twoPi;\n  }\n  if (simplified >= Math.PI) {\n    return simplified - twoPi;\n  }\n\n  return simplified;\n};\n\n/**\n * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * Useful for sanitizing data before use in objects requiring correct range.\n *\n * @param {Number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * @returns {Number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n *\n * @example\n * // Clamp 108 degrees latitude to 90 degrees latitude\n * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));\n */\nCesiumMath.clampToLatitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(angle)) {\n    throw new Core_DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return CesiumMath.clamp(\n    angle,\n    -1 * CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n};\n\n/**\n * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n */\nCesiumMath.negativePiToPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(angle)) {\n    throw new Core_DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;\n};\n\n/**\n * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n */\nCesiumMath.zeroToTwoPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(angle)) {\n    throw new Core_DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= 0 && angle <= CesiumMath.TWO_PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  const mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);\n  if (\n    Math.abs(mod) < CesiumMath.EPSILON14 &&\n    Math.abs(angle) > CesiumMath.EPSILON14\n  ) {\n    return CesiumMath.TWO_PI;\n  }\n  return mod;\n};\n\n/**\n * The modulo operation that also works for negative dividends.\n *\n * @param {Number} m The dividend.\n * @param {Number} n The divisor.\n * @returns {Number} The remainder.\n */\nCesiumMath.mod = function (m, n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(m)) {\n    throw new Core_DeveloperError(\"m is required.\");\n  }\n  if (!Core_defined(n)) {\n    throw new Core_DeveloperError(\"n is required.\");\n  }\n  if (n === 0.0) {\n    throw new Core_DeveloperError(\"divisor cannot be 0.\");\n  }\n  //>>includeEnd('debug');\n  if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {\n    // Early exit if the input does not need to be modded. This avoids\n    // unnecessary math which could introduce floating point error.\n    return m;\n  }\n\n  return ((m % n) + n) % n;\n};\n\n/**\n * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n * Use this test if you are unsure of the magnitudes of left and right.\n *\n * @param {Number} left The first value to compare.\n * @param {Number} right The other value to compare.\n * @param {Number} [relativeEpsilon=0] The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n *\n * @example\n * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n */\nCesiumMath.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"left is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  relativeEpsilon = Core_defaultValue(relativeEpsilon, 0.0);\n  absoluteEpsilon = Core_defaultValue(absoluteEpsilon, relativeEpsilon);\n  const absDiff = Math.abs(left - right);\n  return (\n    absDiff <= absoluteEpsilon ||\n    absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right))\n  );\n};\n\n/**\n * Determines if the left value is less than the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two\n *          values are nearly equal.\n */\nCesiumMath.lessThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"first is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"second is required.\");\n  }\n  if (!Core_defined(absoluteEpsilon)) {\n    throw new Core_DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < -absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is less than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"first is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"second is required.\");\n  }\n  if (!Core_defined(absoluteEpsilon)) {\n    throw new Core_DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two\n *          values are nearly equal.\n */\nCesiumMath.greaterThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"first is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"second is required.\");\n  }\n  if (!Core_defined(absoluteEpsilon)) {\n    throw new Core_DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"first is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"second is required.\");\n  }\n  if (!Core_defined(absoluteEpsilon)) {\n    throw new Core_DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > -absoluteEpsilon;\n};\n\nconst factorials = [1];\n\n/**\n * Computes the factorial of the provided number.\n *\n * @param {Number} n The number whose factorial is to be computed.\n * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n *\n * @example\n * //Compute 7!, which is equal to 5040\n * const computedFactorial = Cesium.Math.factorial(7);\n *\n * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n */\nCesiumMath.factorial = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new Core_DeveloperError(\n      \"A number greater than or equal to 0 is required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = factorials.length;\n  if (n >= length) {\n    let sum = factorials[length - 1];\n    for (let i = length; i <= n; i++) {\n      const next = sum * i;\n      factorials.push(next);\n      sum = next;\n    }\n  }\n  return factorials[n];\n};\n\n/**\n * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n *\n * @param {Number} [n] The number to be incremented.\n * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n * @returns {Number} The incremented number.\n *\n * @exception {DeveloperError} Maximum value must be greater than minimum value.\n *\n * @example\n * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n */\nCesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {\n  minimumValue = Core_defaultValue(minimumValue, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(n)) {\n    throw new Core_DeveloperError(\"n is required.\");\n  }\n  if (maximumValue <= minimumValue) {\n    throw new Core_DeveloperError(\"maximumValue must be greater than minimumValue.\");\n  }\n  //>>includeEnd('debug');\n\n  ++n;\n  if (n > maximumValue) {\n    n = minimumValue;\n  }\n  return n;\n};\n\n/**\n * Determines if a non-negative integer is a power of two.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {Number} n The integer to test in the range [0, (2^32)-1].\n * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const t = Cesium.Math.isPowerOfTwo(16); // true\n * const f = Cesium.Math.isPowerOfTwo(20); // false\n */\nCesiumMath.isPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new Core_DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return n !== 0 && (n & (n - 1)) === 0;\n};\n\n/**\n * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.\n * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {Number} n The integer to test in the range [0, 2^31].\n * @returns {Number} The next power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and 2^31 is required.\n *\n * @example\n * const n = Cesium.Math.nextPowerOfTwo(29); // 32\n * const m = Cesium.Math.nextPowerOfTwo(32); // 32\n */\nCesiumMath.nextPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 2147483648) {\n    throw new Core_DeveloperError(\"A number between 0 and 2^31 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  ++n;\n\n  return n;\n};\n\n/**\n * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {Number} n The integer to test in the range [0, (2^32)-1].\n * @returns {Number} The previous power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const n = Cesium.Math.previousPowerOfTwo(29); // 16\n * const m = Cesium.Math.previousPowerOfTwo(32); // 32\n */\nCesiumMath.previousPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new Core_DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n\n  // The previous bitwise operations implicitly convert to signed 32-bit. Use `>>>` to convert to unsigned\n  n = (n >>> 0) - (n >>> 1);\n\n  return n;\n};\n\n/**\n * Constraint a value to lie between two values.\n *\n * @param {Number} value The value to clamp.\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} The clamped value such that min <= result <= max.\n */\nCesiumMath.clamp = function (value, min, max) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"value\", value);\n  Core_Check.typeOf.number(\"min\", min);\n  Core_Check.typeOf.number(\"max\", max);\n  //>>includeEnd('debug');\n\n  return value < min ? min : value > max ? max : value;\n};\n\nlet randomNumberGenerator = new mersenne_twister();\n\n/**\n * Sets the seed used by the random number generator\n * in {@link CesiumMath#nextRandomNumber}.\n *\n * @param {Number} seed An integer used as the seed.\n */\nCesiumMath.setRandomNumberSeed = function (seed) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(seed)) {\n    throw new Core_DeveloperError(\"seed is required.\");\n  }\n  //>>includeEnd('debug');\n\n  randomNumberGenerator = new mersenne_twister(seed);\n};\n\n/**\n * Generates a random floating point number in the range of [0.0, 1.0)\n * using a Mersenne twister.\n *\n * @returns {Number} A random number in the range of [0.0, 1.0).\n *\n * @see CesiumMath.setRandomNumberSeed\n * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n */\nCesiumMath.nextRandomNumber = function () {\n  return randomNumberGenerator.random();\n};\n\n/**\n * Generates a random number between two numbers.\n *\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} A random number between the min and max.\n */\nCesiumMath.randomBetween = function (min, max) {\n  return CesiumMath.nextRandomNumber() * (max - min) + min;\n};\n\n/**\n * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute acos.\n * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.acosClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(value)) {\n    throw new Core_DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute asin.\n * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.asinClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(value)) {\n    throw new Core_DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Finds the chord length between two points given the circle's radius and the angle between the points.\n *\n * @param {Number} angle The angle between the two points.\n * @param {Number} radius The radius of the circle.\n * @returns {Number} The chord length.\n */\nCesiumMath.chordLength = function (angle, radius) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(angle)) {\n    throw new Core_DeveloperError(\"angle is required.\");\n  }\n  if (!Core_defined(radius)) {\n    throw new Core_DeveloperError(\"radius is required.\");\n  }\n  //>>includeEnd('debug');\n  return 2.0 * radius * Math.sin(angle * 0.5);\n};\n\n/**\n * Finds the logarithm of a number to a base.\n *\n * @param {Number} number The number.\n * @param {Number} base The base.\n * @returns {Number} The result.\n */\nCesiumMath.logBase = function (number, base) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(number)) {\n    throw new Core_DeveloperError(\"number is required.\");\n  }\n  if (!Core_defined(base)) {\n    throw new Core_DeveloperError(\"base is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.log(number) / Math.log(base);\n};\n\n/**\n * Finds the cube root of a number.\n * Returns NaN if <code>number</code> is not provided.\n *\n * @function\n * @param {Number} [number] The number.\n * @returns {Number} The result.\n */\n// eslint-disable-next-line es/no-math-cbrt\nCesiumMath.cbrt = Core_defaultValue(Math.cbrt, function cbrt(number) {\n  const result = Math.pow(Math.abs(number), 1.0 / 3.0);\n  return number < 0.0 ? -result : result;\n});\n\n/**\n * Finds the base 2 logarithm of a number.\n *\n * @function\n * @param {Number} number The number.\n * @returns {Number} The result.\n */\n// eslint-disable-next-line es/no-math-log2\nCesiumMath.log2 = Core_defaultValue(Math.log2, function log2(number) {\n  return Math.log(number) * Math.LOG2E;\n});\n\n/**\n * @private\n */\nCesiumMath.fog = function (distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n};\n\n/**\n * Computes a fast approximation of Atan for input in the range [-1, 1].\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs,\n * which in turn is based on \"Efficient approximations for the arctangent function,\"\n * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * @param {Number} x An input number in the range [-1, 1]\n * @returns {Number} An approximation of atan(x)\n */\nCesiumMath.fastApproximateAtan = function (x) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"x\", x);\n  //>>includeEnd('debug');\n\n  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);\n};\n\n/**\n * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.\n *\n * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html\n *\n * @param {Number} x An input number that isn't zero if y is zero.\n * @param {Number} y An input number that isn't zero if x is zero.\n * @returns {Number} An approximation of atan2(x, y)\n */\nCesiumMath.fastApproximateAtan2 = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"x\", x);\n  Core_Check.typeOf.number(\"y\", y);\n  //>>includeEnd('debug');\n\n  // atan approximations are usually only reliable over [-1, 1]\n  // So reduce the range by flipping whether x or y is on top based on which is bigger.\n  let opposite;\n  let t = Math.abs(x); // t used as swap and atan result.\n  opposite = Math.abs(y);\n  const adjacent = Math.max(t, opposite);\n  opposite = Math.min(t, opposite);\n\n  const oppositeOverAdjacent = opposite / adjacent;\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(oppositeOverAdjacent)) {\n    throw new Core_DeveloperError(\"either x or y must be nonzero\");\n  }\n  //>>includeEnd('debug');\n  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);\n\n  // Undo range reduction\n  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;\n  t = x < 0.0 ? CesiumMath.PI - t : t;\n  t = y < 0.0 ? -t : t;\n  return t;\n};\n/* harmony default export */ const Core_Math = (CesiumMath);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Cartesian3.js\n\n\n\n\n\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = Core_defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = Core_defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = Core_defaultValue(z, 0.0);\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const clock = spherical.clock;\n  const cone = spherical.cone;\n  const magnitude = Core_defaultValue(spherical.magnitude, 1.0);\n  const radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!Core_defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!Core_defined(cartesian)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {Number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 3;\n  if (!Core_defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new Core_DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 3 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new Core_DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"first\", first);\n  Core_Check.typeOf.object(\"second\", second);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"first\", first);\n  Core_Check.typeOf.object(\"second\", second);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian3} cartesian The value to clamp.\n * @param {Cartesian3} min The minimum bound.\n * @param {Cartesian3} max The maximum bound.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} The clamped value such that min <= value <= max.\n */\nCartesian3.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.typeOf.object(\"min\", min);\n  Core_Check.typeOf.object(\"max\", max);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = Core_Math.clamp(value.x, min.x, max.x);\n  const y = Core_Math.clamp(value.y, min.y, max.y);\n  const z = Core_Math.clamp(value.z, min.z, max.z);\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new Core_DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nconst lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"start\", start);\n  Core_Check.typeOf.object(\"end\", end);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nconst angleBetweenScratch = new Cartesian3();\nconst angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  const cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  const sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch\n    )\n  );\n  return Math.atan2(sine, cosine);\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"a\", a);\n  Core_Check.defined(\"b\", b);\n  Core_Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Core_Math.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n\n  const x = leftY * rightZ - leftZ * rightY;\n  const y = leftZ * rightX - leftX * rightZ;\n  const z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {Number} longitude The longitude, in degrees\n * @param {Number} latitude The latitude, in degrees\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"longitude\", longitude);\n  Core_Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = Core_Math.toRadians(longitude);\n  latitude = Core_Math.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nlet scratchN = new Cartesian3();\nlet scratchK = new Cartesian3();\nconst wgs84RadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {Number} longitude The longitude, in radians\n * @param {Number} latitude The latitude, in radians\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"longitude\", longitude);\n  Core_Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = Core_defaultValue(height, 0.0);\n  const radiiSquared = Core_defined(ellipsoid)\n    ? ellipsoid.radiiSquared\n    : wgs84RadiiSquared;\n\n  const cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!Core_defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new Core_DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new Core_DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new Core_DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new Core_DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z})`;\n};\n/* harmony default export */ const Core_Cartesian3 = (Cartesian3);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/scaleToGeodeticSurface.js\n\n\n\n\n\nconst scaleToGeodeticSurfaceIntersection = new Core_Cartesian3();\nconst scaleToGeodeticSurfaceGradient = new Core_Cartesian3();\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @function scaleToGeodeticSurface\n *\n * @private\n */\nfunction scaleToGeodeticSurface(\n  cartesian,\n  oneOverRadii,\n  oneOverRadiiSquared,\n  centerToleranceSquared,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required.\");\n  }\n  if (!Core_defined(oneOverRadii)) {\n    throw new Core_DeveloperError(\"oneOverRadii is required.\");\n  }\n  if (!Core_defined(oneOverRadiiSquared)) {\n    throw new Core_DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n  if (!Core_defined(centerToleranceSquared)) {\n    throw new Core_DeveloperError(\"centerToleranceSquared is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = Core_Cartesian3.multiplyByScalar(\n    cartesian,\n    ratio,\n    scaleToGeodeticSurfaceIntersection\n  );\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio)\n      ? undefined\n      : Core_Cartesian3.clone(intersection, result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda =\n    ((1.0 - ratio) * Core_Cartesian3.magnitude(cartesian)) /\n    (0.5 * Core_Cartesian3.magnitude(gradient));\n  let correction = 0.0;\n\n  let func;\n  let denominator;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let xMultiplier2;\n  let yMultiplier2;\n  let zMultiplier2;\n  let xMultiplier3;\n  let yMultiplier3;\n  let zMultiplier3;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > Core_Math.EPSILON12);\n\n  if (!Core_defined(result)) {\n    return new Core_Cartesian3(\n      positionX * xMultiplier,\n      positionY * yMultiplier,\n      positionZ * zMultiplier\n    );\n  }\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\n/* harmony default export */ const Core_scaleToGeodeticSurface = (scaleToGeodeticSurface);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Cartographic.js\n\n\n\n\n\n\n\n/**\n * A position defined by longitude, latitude, and height.\n * @alias Cartographic\n * @constructor\n *\n * @param {Number} [longitude=0.0] The longitude, in radians.\n * @param {Number} [latitude=0.0] The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n *\n * @see Ellipsoid\n */\nfunction Cartographic(longitude, latitude, height) {\n  /**\n   * The longitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.longitude = Core_defaultValue(longitude, 0.0);\n\n  /**\n   * The latitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.latitude = Core_defaultValue(latitude, 0.0);\n\n  /**\n   * The height, in meters, above the ellipsoid.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.height = Core_defaultValue(height, 0.0);\n}\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in radians.\n *\n * @param {Number} longitude The longitude, in radians.\n * @param {Number} latitude The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromRadians = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"longitude\", longitude);\n  Core_Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = Core_defaultValue(height, 0.0);\n\n  if (!Core_defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in degrees.  The values in the resulting object will\n * be in radians.\n *\n * @param {Number} longitude The longitude, in degrees.\n * @param {Number} latitude The latitude, in degrees.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"longitude\", longitude);\n  Core_Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n  longitude = Core_Math.toRadians(longitude);\n  latitude = Core_Math.toRadians(latitude);\n\n  return Cartographic.fromRadians(longitude, latitude, height, result);\n};\n\nconst cartesianToCartographicN = new Core_Cartesian3();\nconst cartesianToCartographicP = new Core_Cartesian3();\nconst cartesianToCartographicH = new Core_Cartesian3();\nconst wgs84OneOverRadii = new Core_Cartesian3(\n  1.0 / 6378137.0,\n  1.0 / 6378137.0,\n  1.0 / 6356752.3142451793\n);\nconst wgs84OneOverRadiiSquared = new Core_Cartesian3(\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6356752.3142451793 * 6356752.3142451793)\n);\nconst wgs84CenterToleranceSquared = Core_Math.EPSILON1;\n\n/**\n * Creates a new Cartographic instance from a Cartesian position. The values in the\n * resulting object will be in radians.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n */\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\n  const oneOverRadii = Core_defined(ellipsoid)\n    ? ellipsoid.oneOverRadii\n    : wgs84OneOverRadii;\n  const oneOverRadiiSquared = Core_defined(ellipsoid)\n    ? ellipsoid.oneOverRadiiSquared\n    : wgs84OneOverRadiiSquared;\n  const centerToleranceSquared = Core_defined(ellipsoid)\n    ? ellipsoid._centerToleranceSquared\n    : wgs84CenterToleranceSquared;\n\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  const p = Core_scaleToGeodeticSurface(\n    cartesian,\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared,\n    cartesianToCartographicP\n  );\n\n  if (!Core_defined(p)) {\n    return undefined;\n  }\n\n  let n = Core_Cartesian3.multiplyComponents(\n    p,\n    oneOverRadiiSquared,\n    cartesianToCartographicN\n  );\n  n = Core_Cartesian3.normalize(n, n);\n\n  const h = Core_Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  const longitude = Math.atan2(n.y, n.x);\n  const latitude = Math.asin(n.z);\n  const height =\n    Core_Math.sign(Core_Cartesian3.dot(h, cartesian)) * Core_Cartesian3.magnitude(h);\n\n  if (!Core_defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\n * object should be in radians.\n *\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n */\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  return Core_Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    cartographic.height,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Duplicates a Cartographic instance.\n *\n * @param {Cartographic} cartographic The cartographic to duplicate.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n */\nCartographic.clone = function (cartographic, result) {\n  if (!Core_defined(cartographic)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new Cartographic(\n      cartographic.longitude,\n      cartographic.latitude,\n      cartographic.height\n    );\n  }\n  result.longitude = cartographic.longitude;\n  result.latitude = cartographic.latitude;\n  result.height = cartographic.height;\n  return result;\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.longitude === right.longitude &&\n      left.latitude === right.latitude &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = Core_defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Math.abs(left.longitude - right.longitude) <= epsilon &&\n      Math.abs(left.latitude - right.latitude) <= epsilon &&\n      Math.abs(left.height - right.height) <= epsilon)\n  );\n};\n\n/**\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartographic}\n * @constant\n */\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\n\n/**\n * Duplicates this instance.\n *\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.prototype.clone = function (result) {\n  return Cartographic.clone(this, result);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.prototype.equals = function (right) {\n  return Cartographic.equals(this, right);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\n  return Cartographic.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\n *\n * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\n */\nCartographic.prototype.toString = function () {\n  return `(${this.longitude}, ${this.latitude}, ${this.height})`;\n};\n/* harmony default export */ const Core_Cartographic = (Cartographic);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Ellipsoid.js\n\n\n\n\n\n\n\n\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = Core_defaultValue(x, 0.0);\n  y = Core_defaultValue(y, 0.0);\n  z = Core_defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Core_Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Core_Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Core_Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z\n  );\n\n  ellipsoid._oneOverRadii = new Core_Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Core_Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = Core_Math.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!Core_defined(ellipsoid)) {\n    return undefined;\n  }\n  const radii = ellipsoid._radii;\n\n  if (!Core_defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Core_Cartesian3.clone(radii, result._radii);\n  Core_Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Core_Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Core_Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Core_Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!Core_defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!Core_defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    Core_Math.LUNAR_RADIUS,\n    Core_Math.LUNAR_RADIUS,\n    Core_Math.LUNAR_RADIUS\n  )\n);\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoid.packedLength = Core_Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  Core_Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  const radii = Core_Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Core_Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  const longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n  const cosLatitude = Math.cos(latitude);\n\n  const x = cosLatitude * Math.cos(longitude);\n  const y = cosLatitude * Math.sin(longitude);\n  const z = Math.sin(latitude);\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Core_Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (\n    Core_Cartesian3.equalsEpsilon(cartesian, Core_Cartesian3.ZERO, Core_Math.EPSILON14)\n  ) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n  result = Core_Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result\n  );\n  return Core_Cartesian3.normalize(result, result);\n};\n\nconst cartographicToCartesianNormal = new Core_Cartesian3();\nconst cartographicToCartesianK = new Core_Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  const n = cartographicToCartesianNormal;\n  const k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Core_Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  const gamma = Math.sqrt(Core_Cartesian3.dot(n, k));\n  Core_Cartesian3.divideByScalar(k, gamma, k);\n  Core_Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n  return Core_Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  const length = cartographics.length;\n  if (!Core_defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nconst Ellipsoid_cartesianToCartographicN = new Core_Cartesian3();\nconst Ellipsoid_cartesianToCartographicP = new Core_Cartesian3();\nconst Ellipsoid_cartesianToCartographicH = new Core_Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  const p = this.scaleToGeodeticSurface(cartesian, Ellipsoid_cartesianToCartographicP);\n\n  if (!Core_defined(p)) {\n    return undefined;\n  }\n\n  const n = this.geodeticSurfaceNormal(p, Ellipsoid_cartesianToCartographicN);\n  const h = Core_Cartesian3.subtract(cartesian, p, Ellipsoid_cartesianToCartographicH);\n\n  const longitude = Math.atan2(n.y, n.x);\n  const latitude = Math.asin(n.z);\n  const height =\n    Core_Math.sign(Core_Cartesian3.dot(h, cartesian)) * Core_Cartesian3.magnitude(h);\n\n  if (!Core_defined(result)) {\n    return new Core_Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!Core_defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return Core_scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  const beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z\n    );\n\n  return Core_Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result\n) {\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  return Core_Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result\n) {\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  return Core_Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (Core_defined(right) && Core_Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"position\", position);\n\n  if (\n    !Core_Math.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      Core_Math.EPSILON15\n    )\n  ) {\n    throw new Core_DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n\n  Core_Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = Core_defaultValue(buffer, 0.0);\n\n  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst abscissas = [\n  0.14887433898163,\n  0.43339539412925,\n  0.67940956829902,\n  0.86506336668898,\n  0.97390652851717,\n  0.0,\n];\nconst weights = [\n  0.29552422471475,\n  0.26926671930999,\n  0.21908636251598,\n  0.14945134915058,\n  0.066671344308684,\n  0.0,\n];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {Number} a The lower bound for the integration.\n * @param {Number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {Number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"a\", a);\n  Core_Check.typeOf.number(\"b\", b);\n  Core_Check.typeOf.func(\"func\", func);\n  //>>includeEnd('debug');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  const xMean = 0.5 * (b + a);\n  const xRange = 0.5 * (b - a);\n\n  let sum = 0.0;\n  for (let i = 0; i < 5; i++) {\n    const dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {Number} x The value used to evaluate the function.\n * @returns {Number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {Number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  const minLongitude = rectangle.west;\n  let maxLongitude = rectangle.east;\n  const minLatitude = rectangle.south;\n  const maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += Core_Math.TWO_PI;\n  }\n\n  const radiiSquared = this._radiiSquared;\n  const a2 = radiiSquared.x;\n  const b2 = radiiSquared.y;\n  const c2 = radiiSquared.z;\n  const a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    const sinPhi = Math.cos(lat);\n    const cosPhi = Math.sin(lat);\n    return (\n      Math.cos(lat) *\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n        const cosTheta = Math.cos(lon);\n        const sinTheta = Math.sin(lon);\n        return Math.sqrt(\n          a2b2 * cosPhi * cosPhi +\n            c2 *\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\n              sinPhi *\n              sinPhi\n        );\n      })\n    );\n  });\n};\n\n/* harmony default export */ const Core_Ellipsoid = (Ellipsoid);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/EllipsoidGeodesic.js\n\n\n\n\n\n\n\n\nfunction setConstants(ellipsoidGeodesic) {\n  const uSquared = ellipsoidGeodesic._uSquared;\n  const a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  const b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  const f = (a - b) / a;\n\n  const cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  const sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n\n  const tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n\n  const cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  const sineU = cosineU * tanU;\n\n  const sigma = Math.atan2(tanU, cosineHeading);\n\n  const sineAlpha = cosineU * sineHeading;\n  const sineSquaredAlpha = sineAlpha * sineAlpha;\n\n  const cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  const cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n\n  const u2Over4 = uSquared / 4.0;\n  const u4Over16 = u2Over4 * u2Over4;\n  const u6Over64 = u4Over16 * u2Over4;\n  const u8Over256 = u4Over16 * u4Over16;\n\n  const a0 =\n    1.0 +\n    u2Over4 -\n    (3.0 * u4Over16) / 4.0 +\n    (5.0 * u6Over64) / 4.0 -\n    (175.0 * u8Over256) / 64.0;\n  const a1 = 1.0 - u2Over4 + (15.0 * u4Over16) / 8.0 - (35.0 * u6Over64) / 8.0;\n  const a2 = 1.0 - 3.0 * u2Over4 + (35.0 * u4Over16) / 4.0;\n  const a3 = 1.0 - 5.0 * u2Over4;\n\n  const distanceRatio =\n    a0 * sigma -\n    (a1 * Math.sin(2.0 * sigma) * u2Over4) / 2.0 -\n    (a2 * Math.sin(4.0 * sigma) * u4Over16) / 16.0 -\n    (a3 * Math.sin(6.0 * sigma) * u6Over64) / 48.0 -\n    (Math.sin(8.0 * sigma) * 5.0 * u8Over256) / 512;\n\n  const constants = ellipsoidGeodesic._constants;\n\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\n\nfunction computeC(f, cosineSquaredAlpha) {\n  return (\n    (f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha))) /\n    16.0\n  );\n}\n\nfunction computeDeltaLambda(\n  f,\n  sineAlpha,\n  cosineSquaredAlpha,\n  sigma,\n  sineSigma,\n  cosineSigma,\n  cosineTwiceSigmaMidpoint\n) {\n  const C = computeC(f, cosineSquaredAlpha);\n\n  return (\n    (1.0 - C) *\n    f *\n    sineAlpha *\n    (sigma +\n      C *\n        sineSigma *\n        (cosineTwiceSigmaMidpoint +\n          C *\n            cosineSigma *\n            (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)))\n  );\n}\n\nfunction vincentyInverseFormula(\n  ellipsoidGeodesic,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  const eff = (major - minor) / major;\n  const l = secondLongitude - firstLongitude;\n\n  const u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  const u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n\n  const cosineU1 = Math.cos(u1);\n  const sineU1 = Math.sin(u1);\n  const cosineU2 = Math.cos(u2);\n  const sineU2 = Math.sin(u2);\n\n  const cc = cosineU1 * cosineU2;\n  const cs = cosineU1 * sineU2;\n  const ss = sineU1 * sineU2;\n  const sc = sineU1 * cosineU2;\n\n  let lambda = l;\n  let lambdaDot = Core_Math.TWO_PI;\n\n  let cosineLambda = Math.cos(lambda);\n  let sineLambda = Math.sin(lambda);\n\n  let sigma;\n  let cosineSigma;\n  let sineSigma;\n  let cosineSquaredAlpha;\n  let cosineTwiceSigmaMidpoint;\n\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n\n    const temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(\n      cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp\n    );\n    cosineSigma = ss + cc * cosineLambda;\n\n    sigma = Math.atan2(sineSigma, cosineSigma);\n\n    let sineAlpha;\n\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = (cc * sineLambda) / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n\n    lambdaDot = lambda;\n\n    cosineTwiceSigmaMidpoint = cosineSigma - (2.0 * ss) / cosineSquaredAlpha;\n\n    if (!isFinite(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n\n    lambda =\n      l +\n      computeDeltaLambda(\n        eff,\n        sineAlpha,\n        cosineSquaredAlpha,\n        sigma,\n        sineSigma,\n        cosineSigma,\n        cosineTwiceSigmaMidpoint\n      );\n  } while (Math.abs(lambda - lambdaDot) > Core_Math.EPSILON12);\n\n  const uSquared =\n    (cosineSquaredAlpha * (major * major - minor * minor)) / (minor * minor);\n  const A =\n    1.0 +\n    (uSquared *\n      (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0))) /\n      16384.0;\n  const B =\n    (uSquared *\n      (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0))) /\n    1024.0;\n\n  const cosineSquaredTwiceSigmaMidpoint =\n    cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  const deltaSigma =\n    B *\n    sineSigma *\n    (cosineTwiceSigmaMidpoint +\n      (B *\n        (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) -\n          (B *\n            cosineTwiceSigmaMidpoint *\n            (4.0 * sineSigma * sineSigma - 3.0) *\n            (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0)) /\n            6.0)) /\n        4.0);\n\n  const distance = minor * A * (sigma - deltaSigma);\n\n  const startHeading = Math.atan2(\n    cosineU2 * sineLambda,\n    cs - sc * cosineLambda\n  );\n  const endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\n\nconst scratchCart1 = new Core_Cartesian3();\nconst scratchCart2 = new Core_Cartesian3();\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  const firstCartesian = Core_Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  const lastCartesian = Core_Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Core_Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd('debug');\n\n  vincentyInverseFormula(\n    ellipsoidGeodesic,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n\n  ellipsoidGeodesic._start = Core_Cartographic.clone(\n    start,\n    ellipsoidGeodesic._start\n  );\n  ellipsoidGeodesic._end = Core_Cartographic.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n\n  setConstants(ellipsoidGeodesic);\n}\n\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.\n */\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  const e = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n  this._ellipsoid = e;\n  this._start = new Core_Cartographic();\n  this._end = new Core_Cartographic();\n\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n\n  if (Core_defined(start) && Core_defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Core_Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  startHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Core_Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._startHeading;\n    },\n  },\n\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  endHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Core_Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._endHeading;\n    },\n  },\n});\n\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"start\", start);\n  Core_Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    this._distance * fraction,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the geodesic\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"distance\", this._distance);\n  //>>includeEnd('debug');\n\n  const constants = this._constants;\n\n  const s = constants.distanceRatio + distance / constants.b;\n\n  const cosine2S = Math.cos(2.0 * s);\n  const cosine4S = Math.cos(4.0 * s);\n  const cosine6S = Math.cos(6.0 * s);\n  const sine2S = Math.sin(2.0 * s);\n  const sine4S = Math.sin(4.0 * s);\n  const sine6S = Math.sin(6.0 * s);\n  const sine8S = Math.sin(8.0 * s);\n\n  const s2 = s * s;\n  const s3 = s * s2;\n\n  const u8Over256 = constants.u8Over256;\n  const u2Over4 = constants.u2Over4;\n  const u6Over64 = constants.u6Over64;\n  const u4Over16 = constants.u4Over16;\n  let sigma =\n    (2.0 * s3 * u8Over256 * cosine2S) / 3.0 +\n    s *\n      (1.0 -\n        u2Over4 +\n        (7.0 * u4Over16) / 4.0 -\n        (15.0 * u6Over64) / 4.0 +\n        (579.0 * u8Over256) / 64.0 -\n        (u4Over16 - (15.0 * u6Over64) / 4.0 + (187.0 * u8Over256) / 16.0) *\n          cosine2S -\n        ((5.0 * u6Over64) / 4.0 - (115.0 * u8Over256) / 16.0) * cosine4S -\n        (29.0 * u8Over256 * cosine6S) / 16.0) +\n    (u2Over4 / 2.0 -\n      u4Over16 +\n      (71.0 * u6Over64) / 32.0 -\n      (85.0 * u8Over256) / 16.0) *\n      sine2S +\n    ((5.0 * u4Over16) / 16.0 -\n      (5.0 * u6Over64) / 4.0 +\n      (383.0 * u8Over256) / 96.0) *\n      sine4S -\n    s2 *\n      ((u6Over64 - (11.0 * u8Over256) / 2.0) * sine2S +\n        (5.0 * u8Over256 * sine4S) / 2.0) +\n    ((29.0 * u6Over64) / 96.0 - (29.0 * u8Over256) / 16.0) * sine6S +\n    (539.0 * u8Over256 * sine8S) / 1536.0;\n\n  const theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  const latitude = Math.atan((constants.a / constants.b) * Math.tan(theta));\n\n  // Redefine in terms of relative argument of latitude.\n  sigma = sigma - constants.sigma;\n\n  const cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n\n  const sineSigma = Math.sin(sigma);\n  const cosineSigma = Math.cos(sigma);\n\n  const cc = constants.cosineU * cosineSigma;\n  const ss = constants.sineU * sineSigma;\n\n  const lambda = Math.atan2(\n    sineSigma * constants.sineHeading,\n    cc - ss * constants.cosineHeading\n  );\n\n  const l =\n    lambda -\n    computeDeltaLambda(\n      constants.f,\n      constants.sineAlpha,\n      constants.cosineSquaredAlpha,\n      sigma,\n      sineSigma,\n      cosineSigma,\n      cosineTwiceSigmaMidpoint\n    );\n\n  if (Core_defined(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n\n  return new Core_Cartographic(this._start.longitude + l, latitude, 0.0);\n};\n/* harmony default export */ const Core_EllipsoidGeodesic = (EllipsoidGeodesic);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/getTimestamp.js\n/**\n * Gets a timestamp that can be used in measuring the time between events.  Timestamps\n * are expressed in milliseconds, but it is not specified what the milliseconds are\n * measured from.  This function uses performance.now() if it is available, or Date.now()\n * otherwise.\n *\n * @function getTimestamp\n *\n * @returns {Number} The timestamp in milliseconds since some unspecified reference time.\n */\nlet getTimestamp;\n\nif (\n  typeof performance !== \"undefined\" &&\n  typeof performance.now === \"function\" &&\n  isFinite(performance.now())\n) {\n  getTimestamp = function () {\n    return performance.now();\n  };\n} else {\n  getTimestamp = function () {\n    return Date.now();\n  };\n}\n/* harmony default export */ const Core_getTimestamp = (getTimestamp);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Cartesian2.js\n\n\n\n\n\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = Core_defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = Core_defaultValue(y, 0.0);\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!Core_defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!Core_defined(cartesian)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian2s into an array of components.\n *\n * @param {Cartesian2[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n * @returns {Number[]} The packed array.\n */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 2;\n  if (!Core_defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new Core_DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 2 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian2s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new Core_DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"first\", first);\n  Core_Check.typeOf.object(\"second\", second);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"first\", first);\n  Core_Check.typeOf.object(\"second\", second);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian2} value The value to clamp.\n * @param {Cartesian2} min The minimum bound.\n * @param {Cartesian2} max The maximum bound.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} The clamped value such that min <= result <= max.\n */\nCartesian2.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.typeOf.object(\"min\", min);\n  Core_Check.typeOf.object(\"max\", max);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = Core_Math.clamp(value.x, min.x, max.x);\n  const y = Core_Math.clamp(value.y, min.y, max.y);\n\n  result.x = x;\n  result.y = y;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nconst Cartesian2_distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, Cartesian2_distanceScratch);\n  return Cartesian2.magnitude(Cartesian2_distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, Cartesian2_distanceScratch);\n  return Cartesian2.magnitudeSquared(Cartesian2_distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new Core_DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nconst Cartesian2_lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"start\", start);\n  Core_Check.typeOf.object(\"end\", end);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, Cartesian2_lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(Cartesian2_lerpScratch, result, result);\n};\n\nconst Cartesian2_angleBetweenScratch = new Cartesian2();\nconst Cartesian2_angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, Cartesian2_angleBetweenScratch);\n  Cartesian2.normalize(right, Cartesian2_angleBetweenScratch2);\n  return Core_Math.acosClamped(\n    Cartesian2.dot(Cartesian2_angleBetweenScratch, Cartesian2_angleBetweenScratch2)\n  );\n};\n\nconst Cartesian2_mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian2.normalize(cartesian, Cartesian2_mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Core_Math.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return `(${this.x}, ${this.y})`;\n};\n/* harmony default export */ const Core_Cartesian2 = (Cartesian2);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Widgets/getElement.js\n\n\n/**\n * If element is a string, look up the element in the DOM by ID.  Otherwise return element.\n *\n * @private\n *\n * @exception {DeveloperError} Element with id \"id\" does not exist in the document.\n */\nfunction getElement(element) {\n  if (typeof element === \"string\") {\n    const foundElement = document.getElementById(element);\n\n    //>>includeStart('debug', pragmas.debug);\n    if (foundElement === null) {\n      throw new Core_DeveloperError(\n        `Element with id \"${element}\" does not exist in the document.`\n      );\n    }\n    //>>includeEnd('debug');\n\n    element = foundElement;\n  }\n  return element;\n}\n/* harmony default export */ const Widgets_getElement = (getElement);\n\n;// CONCATENATED MODULE: ./core/createFragmentFromTemplate.js\nvar createFragmentFromTemplate = function createFragmentFromTemplate(htmlString) {\n  var holder = document.createElement('div');\n  holder.innerHTML = htmlString;\n  var fragment = document.createDocumentFragment();\n  while (holder.firstChild) {\n    fragment.appendChild(holder.firstChild);\n  }\n  return fragment;\n};\n/* harmony default export */ const core_createFragmentFromTemplate = (createFragmentFromTemplate);\n;// CONCATENATED MODULE: ./core/loadView.js\n/* eslint-disable no-unused-vars */\n\n\nvar loadView_Knockout = ThirdParty_knockout;\nvar loadView = function loadView(htmlString, container, viewModel) {\n  container = Widgets_getElement(container);\n  var fragment = core_createFragmentFromTemplate(htmlString);\n\n  // Sadly, fragment.childNodes doesn't have a slice function.\n  // This code could be replaced with Array.prototype.slice.call(fragment.childNodes)\n  // but that seems slightly error prone.\n  var nodes = [];\n  var i;\n  for (i = 0; i < fragment.childNodes.length; ++i) {\n    nodes.push(fragment.childNodes[i]);\n  }\n  container.appendChild(fragment);\n  for (i = 0; i < nodes.length; ++i) {\n    var node = nodes[i];\n    if (node.nodeType === 1 || node.nodeType === 8) {\n      loadView_Knockout.applyBindings(viewModel, node);\n    }\n  }\n  return nodes;\n};\n/* harmony default export */ const core_loadView = (loadView);\n;// CONCATENATED MODULE: ./viewModels/DistanceLegendViewModel.js\n/* eslint-disable no-unused-vars */\n\n\nvar DistanceLegendViewModel_Knockout = ThirdParty_knockout;\nvar DistanceLegendViewModel = function DistanceLegendViewModel(options) {\n  if (!Core_defined(options) || !Core_defined(options.terria)) {\n    throw new Core_DeveloperError('options.terria is required.');\n  }\n  this.terria = options.terria;\n  this._removeSubscription = undefined;\n  this._lastLegendUpdate = undefined;\n  this.eventHelper = new Core_EventHelper();\n  this.distanceLabel = undefined;\n  this.barWidth = undefined;\n  this.enableDistanceLegend = Core_defined(options.enableDistanceLegend) ? options.enableDistanceLegend : true;\n  DistanceLegendViewModel_Knockout.track(this, ['distanceLabel', 'barWidth']);\n  this.eventHelper.add(this.terria.afterWidgetChanged, function () {\n    if (Core_defined(this._removeSubscription)) {\n      this._removeSubscription();\n      this._removeSubscription = undefined;\n    }\n  }, this);\n  //        this.terria.beforeWidgetChanged.addEventListener(function () {\n  //            if (defined(this._removeSubscription)) {\n  //                this._removeSubscription();\n  //                this._removeSubscription = undefined;\n  //            }\n  //        }, this);\n\n  var that = this;\n  function addUpdateSubscription() {\n    if (Core_defined(that.terria)) {\n      var scene = that.terria.scene;\n      that._removeSubscription = scene.postRender.addEventListener(function () {\n        updateDistanceLegendCesium(this, scene);\n      }, that);\n    }\n  }\n  addUpdateSubscription();\n  this.eventHelper.add(this.terria.afterWidgetChanged, function () {\n    addUpdateSubscription();\n  }, this);\n  // this.terria.afterWidgetChanged.addEventListener(function() {\n  //    addUpdateSubscription();\n  // }, this);\n};\n\nDistanceLegendViewModel.prototype.destroy = function () {\n  this.eventHelper.removeAll();\n};\nDistanceLegendViewModel.prototype.show = function (container) {\n  var testing;\n  if (this.enableDistanceLegend) {\n    testing = '<div class=\"distance-legend\" data-bind=\"visible: distanceLabel && barWidth\">' + '<div class=\"distance-legend-label\" data-bind=\"text: distanceLabel\"></div>' + '<div class=\"distance-legend-scale-bar\" data-bind=\"style: { width: barWidth + \\'px\\', left: (5 + (125 - barWidth) / 2) + \\'px\\' }\"></div>' + '</div>';\n  } else {\n    testing = '<div class=\"distance-legend\"  style=\"display: none;\" data-bind=\"visible: distanceLabel && barWidth\">' + '<div class=\"distance-legend-label\"  data-bind=\"text: distanceLabel\"></div>' + '<div class=\"distance-legend-scale-bar\"  data-bind=\"style: { width: barWidth + \\'px\\', left: (5 + (125 - barWidth) / 2) + \\'px\\' }\"></div>' + '</div>';\n  }\n  core_loadView(testing, container, this);\n  // loadView(distanceLegendTemplate, container, this);\n  // loadView(require('fs').readFileSync(__dirname + '/../Views/DistanceLegend.html', 'utf8'), container, this);\n};\n\nDistanceLegendViewModel.create = function (options) {\n  var result = new DistanceLegendViewModel(options);\n  result.show(options.container);\n  return result;\n};\nvar geodesic = new Core_EllipsoidGeodesic();\nvar distances = [1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 20000, 30000, 50000, 100000, 200000, 300000, 500000, 1000000, 2000000, 3000000, 5000000, 10000000, 20000000, 30000000, 50000000];\nfunction updateDistanceLegendCesium(viewModel, scene) {\n  if (!viewModel.enableDistanceLegend) {\n    viewModel.barWidth = undefined;\n    viewModel.distanceLabel = undefined;\n    return;\n  }\n  var now = Core_getTimestamp();\n  if (now < viewModel._lastLegendUpdate + 250) {\n    return;\n  }\n  viewModel._lastLegendUpdate = now;\n\n  // Find the distance between two pixels at the bottom center of the screen.\n  var width = scene.canvas.clientWidth;\n  var height = scene.canvas.clientHeight;\n  var left = scene.camera.getPickRay(new Core_Cartesian2(width / 2 | 0, height - 1));\n  var right = scene.camera.getPickRay(new Core_Cartesian2(1 + width / 2 | 0, height - 1));\n  var globe = scene.globe;\n  var leftPosition = globe.pick(left, scene);\n  var rightPosition = globe.pick(right, scene);\n  if (!Core_defined(leftPosition) || !Core_defined(rightPosition)) {\n    viewModel.barWidth = undefined;\n    viewModel.distanceLabel = undefined;\n    return;\n  }\n  var leftCartographic = globe.ellipsoid.cartesianToCartographic(leftPosition);\n  var rightCartographic = globe.ellipsoid.cartesianToCartographic(rightPosition);\n  geodesic.setEndPoints(leftCartographic, rightCartographic);\n  var pixelDistance = geodesic.surfaceDistance;\n\n  // Find the first distance that makes the scale bar less than 100 pixels.\n  var maxBarWidth = 100;\n  var distance;\n  for (var i = distances.length - 1; !Core_defined(distance) && i >= 0; --i) {\n    if (distances[i] / pixelDistance < maxBarWidth) {\n      distance = distances[i];\n    }\n  }\n  if (Core_defined(distance)) {\n    var label;\n    if (distance >= 1000) {\n      label = (distance / 1000).toString() + ' km';\n    } else {\n      label = distance.toString() + ' m';\n    }\n    viewModel.barWidth = distance / pixelDistance | 0;\n    viewModel.distanceLabel = label;\n  } else {\n    viewModel.barWidth = undefined;\n    viewModel.distanceLabel = undefined;\n  }\n}\n/* harmony default export */ const viewModels_DistanceLegendViewModel = (DistanceLegendViewModel);\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Scene/SceneMode.js\n/**\n * Indicates if the scene is viewed in 3D, 2D, or 2.5D Columbus view.\n *\n * @enum {Number}\n * @see Scene#mode\n */\nconst SceneMode = {\n  /**\n   * Morphing between mode, e.g., 3D to 2D.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MORPHING: 0,\n\n  /**\n   * Columbus View mode.  A 2.5D perspective view where the map is laid out\n   * flat and objects with non-zero height are drawn above it.\n   *\n   * @type {Number}\n   * @constant\n   */\n  COLUMBUS_VIEW: 1,\n\n  /**\n   * 2D mode.  The map is viewed top-down with an orthographic projection.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SCENE2D: 2,\n\n  /**\n   * 3D mode.  A traditional 3D perspective view of the globe.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SCENE3D: 3,\n};\n\n/**\n * Returns the morph time for the given scene mode.\n *\n * @param {SceneMode} value The scene mode\n * @returns {Number} The morph time\n */\nSceneMode.getMorphTime = function (value) {\n  if (value === SceneMode.SCENE3D) {\n    return 1.0;\n  } else if (value === SceneMode.MORPHING) {\n    return undefined;\n  }\n  return 0.0;\n};\n/* harmony default export */ const Scene_SceneMode = (Object.freeze(SceneMode));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Cartesian4.js\n\n\n\n\n\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = Core_defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = Core_defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = Core_defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = Core_defaultValue(w, 0.0);\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!Core_defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n  if (!Core_defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!Core_defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian4s into an array of components.\n *\n * @param {Cartesian4[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {Number[]} The packed array.\n */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!Core_defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new Core_DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new Core_DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * const v = [1.0, 2.0, 3.0, 4.0];\n * const p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * const p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"first\", first);\n  Core_Check.typeOf.object(\"second\", second);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"first\", first);\n  Core_Check.typeOf.object(\"second\", second);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian4} value The value to clamp.\n * @param {Cartesian4} min The minimum bound.\n * @param {Cartesian4} max The maximum bound.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} The clamped value such that min <= result <= max.\n */\nCartesian4.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.typeOf.object(\"min\", min);\n  Core_Check.typeOf.object(\"max\", max);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = Core_Math.clamp(value.x, min.x, max.x);\n  const y = Core_Math.clamp(value.y, min.y, max.y);\n  const z = Core_Math.clamp(value.z, min.z, max.z);\n  const w = Core_Math.clamp(value.w, min.w, max.w);\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z +\n    cartesian.w * cartesian.w\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nconst Cartesian4_distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, Cartesian4_distanceScratch);\n  return Cartesian4.magnitude(Cartesian4_distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, Cartesian4_distanceScratch);\n  return Cartesian4.magnitudeSquared(Cartesian4_distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian4.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isNaN(result.x) ||\n    isNaN(result.y) ||\n    isNaN(result.z) ||\n    isNaN(result.w)\n  ) {\n    throw new Core_DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nconst Cartesian4_lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"start\", start);\n  Core_Check.typeOf.object(\"end\", end);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, Cartesian4_lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(Cartesian4_lerpScratch, result, result);\n};\n\nconst Cartesian4_mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian4.normalize(cartesian, Cartesian4_mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2] &&\n    cartesian.w === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Core_Math.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.w,\n        right.w,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian4.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\nCartesian4.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\n\n// scratchU8Array and scratchF32Array are views into the same buffer\nconst scratchF32Array = new Float32Array(1);\nconst scratchU8Array = new Uint8Array(scratchF32Array.buffer);\n\nconst testU32 = new Uint32Array([0x11223344]);\nconst testU8 = new Uint8Array(testU32.buffer);\nconst littleEndian = testU8[0] === 0x44;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {Number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Cartesian4();\n  }\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  scratchF32Array[0] = value;\n\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {Number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"packedFloat\", packedFloat);\n  //>>includeEnd('debug');\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n  return scratchF32Array[0];\n};\n/* harmony default export */ const Core_Cartesian4 = (Cartesian4);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Matrix3.js\n\n\n\n\n\n\n\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromArray\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromHeadingPitchRoll\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.fromCrossProduct\n * @see Matrix3.fromRotationX\n * @see Matrix3.fromRotationY\n * @see Matrix3.fromRotationZ\n * @see Matrix2\n * @see Matrix4\n */\nfunction Matrix3(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2\n) {\n  this[0] = Core_defaultValue(column0Row0, 0.0);\n  this[1] = Core_defaultValue(column0Row1, 0.0);\n  this[2] = Core_defaultValue(column0Row2, 0.0);\n  this[3] = Core_defaultValue(column1Row0, 0.0);\n  this[4] = Core_defaultValue(column1Row1, 0.0);\n  this[5] = Core_defaultValue(column1Row2, 0.0);\n  this[6] = Core_defaultValue(column2Row0, 0.0);\n  this[7] = Core_defaultValue(column2Row1, 0.0);\n  this[8] = Core_defaultValue(column2Row2, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix3.packedLength = 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix3s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix3[]} array The array of matrices to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.\n * @returns {Number[]} The packed array.\n */\nMatrix3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 9;\n  if (!Core_defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new Core_DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 9 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix3.pack(array[i], result, i * 9);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Matrix3[]} [result] The array onto which to store the result.\n * @returns {Matrix3[]} The unpacked array.\n */\nMatrix3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 9);\n  if (array.length % 9 !== 0) {\n    throw new Core_DeveloperError(\"array length must be a multiple of 9.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 9);\n  } else {\n    result.length = length / 9;\n  }\n\n  for (let i = 0; i < length; i += 9) {\n    const index = i / 9;\n    result[index] = Matrix3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix3.clone = function (matrix, result) {\n  if (!Core_defined(matrix)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new Matrix3(\n      matrix[0],\n      matrix[3],\n      matrix[6],\n      matrix[1],\n      matrix[4],\n      matrix[7],\n      matrix[2],\n      matrix[5],\n      matrix[8]\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @function\n * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\nMatrix3.fromArray = Matrix3.unpack;\n\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Matrix3(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8]\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  const x2 = quaternion.x * quaternion.x;\n  const xy = quaternion.x * quaternion.y;\n  const xz = quaternion.x * quaternion.z;\n  const xw = quaternion.x * quaternion.w;\n  const y2 = quaternion.y * quaternion.y;\n  const yz = quaternion.y * quaternion.z;\n  const yw = quaternion.y * quaternion.w;\n  const z2 = quaternion.z * quaternion.z;\n  const zw = quaternion.z * quaternion.w;\n  const w2 = quaternion.w * quaternion.w;\n\n  const m00 = x2 - y2 - z2 + w2;\n  const m01 = 2.0 * (xy - zw);\n  const m02 = 2.0 * (xz + yw);\n\n  const m10 = 2.0 * (xy + zw);\n  const m11 = -x2 + y2 - z2 + w2;\n  const m12 = 2.0 * (yz - xw);\n\n  const m20 = 2.0 * (xz - yw);\n  const m21 = 2.0 * (yz + xw);\n  const m22 = -x2 - y2 + z2 + w2;\n\n  if (!Core_defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const cosTheta = Math.cos(-headingPitchRoll.pitch);\n  const cosPsi = Math.cos(-headingPitchRoll.heading);\n  const cosPhi = Math.cos(headingPitchRoll.roll);\n  const sinTheta = Math.sin(-headingPitchRoll.pitch);\n  const sinPsi = Math.sin(-headingPitchRoll.heading);\n  const sinPhi = Math.sin(headingPitchRoll.roll);\n\n  const m00 = cosTheta * cosPsi;\n  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n\n  const m10 = cosTheta * sinPsi;\n  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n\n  const m20 = -sinTheta;\n  const m21 = sinPhi * cosTheta;\n  const m22 = cosPhi * cosTheta;\n\n  if (!Core_defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * const m = Cesium.Matrix3.fromUniformScale(2.0);\n */\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"vector\", vector);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Matrix3(\n      0.0,\n      -vector.z,\n      vector.y,\n      vector.z,\n      0.0,\n      -vector.x,\n      -vector.y,\n      vector.x,\n      0.0\n    );\n  }\n\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!Core_defined(result)) {\n    return new Matrix3(\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle\n    );\n  }\n\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!Core_defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      0.0,\n      sinAngle,\n      0.0,\n      1.0,\n      0.0,\n      -sinAngle,\n      0.0,\n      cosAngle\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!Core_defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} column The zero-based index of the column.\n * @param {Number} row The zero-based index of the row.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * const myMatrix = new Cesium.Matrix3();\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\n  //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 3;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  const z = matrix[startIndex + 2];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  const startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 3];\n  const z = matrix[index + 6];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\n\nconst scaleScratch1 = new Core_Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  const scaleRatioZ = scale.z / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scaleScratch2 = new Core_Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  const scaleRatioZ = scale / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scratchColumn = new Core_Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n */\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Core_Cartesian3.magnitude(\n    Core_Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\n  );\n  result.y = Core_Cartesian3.magnitude(\n    Core_Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn)\n  );\n  result.z = Core_Cartesian3.magnitude(\n    Core_Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn)\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Core_Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scaleScratch3);\n  return Core_Cartesian3.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Core_Cartesian3();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} rotation The rotation matrix.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.getRotation\n */\nMatrix3.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.x;\n  result[3] = rotation[3] * scale.y;\n  result[4] = rotation[4] * scale.y;\n  result[5] = rotation[5] * scale.y;\n  result[6] = rotation[6] * scale.z;\n  result[7] = rotation[7] * scale.z;\n  result[8] = rotation[8] * scale.z;\n\n  return result;\n};\n\nconst scaleScratch5 = new Core_Cartesian3();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setRotation\n */\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.x;\n  result[3] = matrix[3] / scale.y;\n  result[4] = matrix[4] / scale.y;\n  result[5] = matrix[5] / scale.y;\n  result[6] = matrix[6] / scale.z;\n  result[7] = matrix[7] / scale.z;\n  result[8] = matrix[8] / scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 =\n    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  const column0Row1 =\n    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  const column0Row2 =\n    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n\n  const column1Row0 =\n    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  const column1Row1 =\n    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  const column1Row2 =\n    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n\n  const column2Row0 =\n    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  const column2Row1 =\n    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  const column2Row2 =\n    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Number} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Number} scale The uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n  result[4] = matrix[4] * scale;\n  result[5] = matrix[5] * scale;\n  result[6] = matrix[6] * scale;\n  result[7] = matrix[7] * scale;\n  result[8] = matrix[8] * scale;\n\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[3];\n  const column0Row2 = matrix[6];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[4];\n  const column1Row2 = matrix[7];\n  const column2Row0 = matrix[2];\n  const column2Row1 = matrix[5];\n  const column2Row2 = matrix[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n\n  const tolerance = Core_Math.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(\n      matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]\n    );\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  let c = 1.0;\n  let s = 0.0;\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[Matrix3.getElementIndex(q, q)];\n    const pp = matrix[Matrix3.getElementIndex(p, p)];\n    const qp = matrix[Matrix3.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n\n  result[Matrix3.getElementIndex(p, p)] = result[\n    Matrix3.getElementIndex(q, q)\n  ] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symetric matrix\n * const result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  const tolerance = Core_Math.EPSILON20;\n  const maxSweeps = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  if (!Core_defined(result)) {\n    result = {};\n  }\n\n  const unitaryMatrix = (result.unitary = Matrix3.clone(\n    Matrix3.IDENTITY,\n    result.unitary\n  ));\n  const diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));\n\n  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n\n  return result;\n};\n\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {Number} The value of the determinant of the matrix.\n */\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[3];\n  const m31 = matrix[6];\n  const m12 = matrix[1];\n  const m22 = matrix[4];\n  const m32 = matrix[7];\n  const m13 = matrix[2];\n  const m23 = matrix[5];\n  const m33 = matrix[8];\n\n  return (\n    m11 * (m22 * m33 - m23 * m32) +\n    m12 * (m23 * m31 - m21 * m33) +\n    m13 * (m21 * m32 - m22 * m31)\n  );\n};\n\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[1];\n  const m31 = matrix[2];\n  const m12 = matrix[3];\n  const m22 = matrix[4];\n  const m32 = matrix[5];\n  const m13 = matrix[6];\n  const m23 = matrix[7];\n  const m33 = matrix[8];\n\n  const determinant = Matrix3.determinant(matrix);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Math.abs(determinant) <= Core_Math.EPSILON15) {\n    throw new Core_DeveloperError(\"matrix is not invertible\");\n  }\n  //>>includeEnd('debug');\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n\n  const scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\n\nconst scratchTransposeMatrix = new Matrix3();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose and invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix3.inverse(\n    Matrix3.transpose(matrix, scratchTransposeMatrix),\n    result\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix3.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[7] === right[7] &&\n      left[8] === right[8])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = Core_defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.IDENTITY = Object.freeze(\n  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n);\n\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.ZERO = Object.freeze(\n  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n);\n\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW0 = 3;\n\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW1 = 4;\n\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW2 = 5;\n\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW0 = 6;\n\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW1 = 7;\n\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW2 = 8;\n\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\nMatrix3.prototype.toString = function () {\n  return (\n    `(${this[0]}, ${this[3]}, ${this[6]})\\n` +\n    `(${this[1]}, ${this[4]}, ${this[7]})\\n` +\n    `(${this[2]}, ${this[5]}, ${this[8]})`\n  );\n};\n/* harmony default export */ const Core_Matrix3 = (Matrix3);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/RuntimeError.js\n\n\n/**\n * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,\n * out of memory, could not compile shader, etc.  If a function may throw this\n * exception, the calling code should be prepared to catch it.\n * <br /><br />\n * On the other hand, a {@link DeveloperError} indicates an exception due\n * to a developer error, e.g., invalid argument, that usually indicates a bug in the\n * calling code.\n *\n * @alias RuntimeError\n * @constructor\n * @extends Error\n *\n * @param {String} [message] The error message for this exception.\n *\n * @see DeveloperError\n */\nfunction RuntimeError(message) {\n  /**\n   * 'RuntimeError' indicating that this exception was thrown due to a runtime error.\n   * @type {String}\n   * @readonly\n   */\n  this.name = \"RuntimeError\";\n\n  /**\n   * The explanation for why this exception was thrown.\n   * @type {String}\n   * @readonly\n   */\n  this.message = message;\n\n  //Browsers such as IE don't have a stack property until you actually throw the error.\n  let stack;\n  try {\n    throw new Error();\n  } catch (e) {\n    stack = e.stack;\n  }\n\n  /**\n   * The stack trace of this exception, if available.\n   * @type {String}\n   * @readonly\n   */\n  this.stack = stack;\n}\n\nif (Core_defined(Object.create)) {\n  RuntimeError.prototype = Object.create(Error.prototype);\n  RuntimeError.prototype.constructor = RuntimeError;\n}\n\nRuntimeError.prototype.toString = function () {\n  let str = `${this.name}: ${this.message}`;\n\n  if (Core_defined(this.stack)) {\n    str += `\\n${this.stack.toString()}`;\n  }\n\n  return str;\n};\n/* harmony default export */ const Core_RuntimeError = (RuntimeError);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Matrix4.js\n\n\n\n\n\n\n\n\n\n\n/**\n * A 4x4 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix4\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column3Row0=0.0] The value for column 3, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column3Row1=0.0] The value for column 3, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n * @param {Number} [column3Row2=0.0] The value for column 3, row 2.\n * @param {Number} [column0Row3=0.0] The value for column 0, row 3.\n * @param {Number} [column1Row3=0.0] The value for column 1, row 3.\n * @param {Number} [column2Row3=0.0] The value for column 2, row 3.\n * @param {Number} [column3Row3=0.0] The value for column 3, row 3.\n *\n * @see Matrix4.fromArray\n * @see Matrix4.fromColumnMajorArray\n * @see Matrix4.fromRowMajorArray\n * @see Matrix4.fromRotationTranslation\n * @see Matrix4.fromTranslationQuaternionRotationScale\n * @see Matrix4.fromTranslationRotationScale\n * @see Matrix4.fromTranslation\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.fromRotation\n * @see Matrix4.fromCamera\n * @see Matrix4.computePerspectiveFieldOfView\n * @see Matrix4.computeOrthographicOffCenter\n * @see Matrix4.computePerspectiveOffCenter\n * @see Matrix4.computeInfinitePerspectiveOffCenter\n * @see Matrix4.computeViewportTransformation\n * @see Matrix4.computeView\n * @see Matrix2\n * @see Matrix3\n * @see Packable\n */\nfunction Matrix4(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column3Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column3Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2,\n  column3Row2,\n  column0Row3,\n  column1Row3,\n  column2Row3,\n  column3Row3\n) {\n  this[0] = Core_defaultValue(column0Row0, 0.0);\n  this[1] = Core_defaultValue(column0Row1, 0.0);\n  this[2] = Core_defaultValue(column0Row2, 0.0);\n  this[3] = Core_defaultValue(column0Row3, 0.0);\n  this[4] = Core_defaultValue(column1Row0, 0.0);\n  this[5] = Core_defaultValue(column1Row1, 0.0);\n  this[6] = Core_defaultValue(column1Row2, 0.0);\n  this[7] = Core_defaultValue(column1Row3, 0.0);\n  this[8] = Core_defaultValue(column2Row0, 0.0);\n  this[9] = Core_defaultValue(column2Row1, 0.0);\n  this[10] = Core_defaultValue(column2Row2, 0.0);\n  this[11] = Core_defaultValue(column2Row3, 0.0);\n  this[12] = Core_defaultValue(column3Row0, 0.0);\n  this[13] = Core_defaultValue(column3Row1, 0.0);\n  this[14] = Core_defaultValue(column3Row2, 0.0);\n  this[15] = Core_defaultValue(column3Row3, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix4.packedLength = 16;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n  array[startingIndex++] = value[9];\n  array[startingIndex++] = value[10];\n  array[startingIndex++] = value[11];\n  array[startingIndex++] = value[12];\n  array[startingIndex++] = value[13];\n  array[startingIndex++] = value[14];\n  array[startingIndex] = value[15];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix4} [result] The object into which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n */\nMatrix4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  result[9] = array[startingIndex++];\n  result[10] = array[startingIndex++];\n  result[11] = array[startingIndex++];\n  result[12] = array[startingIndex++];\n  result[13] = array[startingIndex++];\n  result[14] = array[startingIndex++];\n  result[15] = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix4s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix4[]} array The array of matrices to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 16 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 16) elements.\n * @returns {Number[]} The packed array.\n */\nMatrix4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 16;\n  if (!Core_defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new Core_DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 16 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix4.pack(array[i], result, i * 16);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Matrix4[]} [result] The array onto which to store the result.\n * @returns {Matrix4[]} The unpacked array.\n */\nMatrix4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 16);\n  if (array.length % 16 !== 0) {\n    throw new Core_DeveloperError(\"array length must be a multiple of 16.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!Core_defined(result)) {\n    result = new Array(length / 16);\n  } else {\n    result.length = length / 16;\n  }\n\n  for (let i = 0; i < length; i += 16) {\n    const index = i / 16;\n    result[index] = Matrix4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix4 instance.\n *\n * @param {Matrix4} matrix The matrix to duplicate.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix4.clone = function (matrix, result) {\n  if (!Core_defined(matrix)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new Matrix4(\n      matrix[0],\n      matrix[4],\n      matrix[8],\n      matrix[12],\n      matrix[1],\n      matrix[5],\n      matrix[9],\n      matrix[13],\n      matrix[2],\n      matrix[6],\n      matrix[10],\n      matrix[14],\n      matrix[3],\n      matrix[7],\n      matrix[11],\n      matrix[15]\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Creates a Matrix4 from 16 consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Create the Matrix4:\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n *\n * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m = Cesium.Matrix4.fromArray(v);\n *\n * // Create same Matrix4 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m2 = Cesium.Matrix4.fromArray(v2, 2);\n */\nMatrix4.fromArray = Matrix4.unpack;\n\n/**\n * Computes a Matrix4 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix4.clone(values, result);\n};\n\n/**\n * Computes a Matrix4 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Matrix4(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8],\n      values[9],\n      values[10],\n      values[11],\n      values[12],\n      values[13],\n      values[14],\n      values[15]\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[4];\n  result[2] = values[8];\n  result[3] = values[12];\n  result[4] = values[1];\n  result[5] = values[5];\n  result[6] = values[9];\n  result[7] = values[13];\n  result[8] = values[2];\n  result[9] = values[6];\n  result[10] = values[10];\n  result[11] = values[14];\n  result[12] = values[3];\n  result[13] = values[7];\n  result[14] = values[11];\n  result[15] = values[15];\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance from a Matrix3 representing the rotation\n * and a Cartesian3 representing the translation.\n *\n * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.\n * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRotationTranslation = function (rotation, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rotation\", rotation);\n  //>>includeEnd('debug');\n\n  translation = Core_defaultValue(translation, Core_Cartesian3.ZERO);\n\n  if (!Core_defined(result)) {\n    return new Matrix4(\n      rotation[0],\n      rotation[3],\n      rotation[6],\n      translation.x,\n      rotation[1],\n      rotation[4],\n      rotation[7],\n      translation.y,\n      rotation[2],\n      rotation[5],\n      rotation[8],\n      translation.z,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = rotation[0];\n  result[1] = rotation[1];\n  result[2] = rotation[2];\n  result[3] = 0.0;\n  result[4] = rotation[3];\n  result[5] = rotation[4];\n  result[6] = rotation[5];\n  result[7] = 0.0;\n  result[8] = rotation[6];\n  result[9] = rotation[7];\n  result[10] = rotation[8];\n  result[11] = 0.0;\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)\n * representation with the rotation represented as a quaternion.\n *\n * @param {Cartesian3} translation The translation transformation.\n * @param {Quaternion} rotation The rotation transformation.\n * @param {Cartesian3} scale The non-uniform scale transformation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * const result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(\n *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation\n *   Cesium.Quaternion.IDENTITY,           // rotation\n *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale\n *   result);\n */\nMatrix4.fromTranslationQuaternionRotationScale = function (\n  translation,\n  rotation,\n  scale,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"translation\", translation);\n  Core_Check.typeOf.object(\"rotation\", rotation);\n  Core_Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Matrix4();\n  }\n\n  const scaleX = scale.x;\n  const scaleY = scale.y;\n  const scaleZ = scale.z;\n\n  const x2 = rotation.x * rotation.x;\n  const xy = rotation.x * rotation.y;\n  const xz = rotation.x * rotation.z;\n  const xw = rotation.x * rotation.w;\n  const y2 = rotation.y * rotation.y;\n  const yz = rotation.y * rotation.z;\n  const yw = rotation.y * rotation.w;\n  const z2 = rotation.z * rotation.z;\n  const zw = rotation.z * rotation.w;\n  const w2 = rotation.w * rotation.w;\n\n  const m00 = x2 - y2 - z2 + w2;\n  const m01 = 2.0 * (xy - zw);\n  const m02 = 2.0 * (xz + yw);\n\n  const m10 = 2.0 * (xy + zw);\n  const m11 = -x2 + y2 - z2 + w2;\n  const m12 = 2.0 * (yz - xw);\n\n  const m20 = 2.0 * (xz - yw);\n  const m21 = 2.0 * (yz + xw);\n  const m22 = -x2 - y2 + z2 + w2;\n\n  result[0] = m00 * scaleX;\n  result[1] = m10 * scaleX;\n  result[2] = m20 * scaleX;\n  result[3] = 0.0;\n  result[4] = m01 * scaleY;\n  result[5] = m11 * scaleY;\n  result[6] = m21 * scaleY;\n  result[7] = 0.0;\n  result[8] = m02 * scaleZ;\n  result[9] = m12 * scaleZ;\n  result[10] = m22 * scaleZ;\n  result[11] = 0.0;\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.\n *\n * @param {TranslationRotationScale} translationRotationScale The instance.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromTranslationRotationScale = function (\n  translationRotationScale,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"translationRotationScale\", translationRotationScale);\n  //>>includeEnd('debug');\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    translationRotationScale.translation,\n    translationRotationScale.rotation,\n    translationRotationScale.scale,\n    result\n  );\n};\n\n/**\n * Creates a Matrix4 instance from a Cartesian3 representing the translation.\n *\n * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @see Matrix4.multiplyByTranslation\n */\nMatrix4.fromTranslation = function (translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"translation\", translation);\n  //>>includeEnd('debug');\n\n  return Matrix4.fromRotationTranslation(Core_Matrix3.IDENTITY, translation, result);\n};\n\n/**\n * Computes a Matrix4 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0, 0.0]\n * //   [0.0, 0.0, 9.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix4.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Matrix4(\n      scale.x,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale.y,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale.z,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = scale.y;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = scale.z;\n  result[11] = 0.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0, 0.0]\n * //   [0.0, 0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromUniformScale(2.0);\n */\nMatrix4.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Matrix4(\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = scale;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = scale;\n  result[11] = 0.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {Matrix3} rotation The rotation matrix.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRotation = function (rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rotation\", rotation);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Matrix4();\n  }\n  result[0] = rotation[0];\n  result[1] = rotation[1];\n  result[2] = rotation[2];\n  result[3] = 0.0;\n\n  result[4] = rotation[3];\n  result[5] = rotation[4];\n  result[6] = rotation[5];\n  result[7] = 0.0;\n\n  result[8] = rotation[6];\n  result[9] = rotation[7];\n  result[10] = rotation[8];\n  result[11] = 0.0;\n\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n\n  return result;\n};\n\nconst fromCameraF = new Core_Cartesian3();\nconst fromCameraR = new Core_Cartesian3();\nconst fromCameraU = new Core_Cartesian3();\n\n/**\n * Computes a Matrix4 instance from a Camera.\n *\n * @param {Camera} camera The camera to use.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromCamera = function (camera, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"camera\", camera);\n  //>>includeEnd('debug');\n\n  const position = camera.position;\n  const direction = camera.direction;\n  const up = camera.up;\n\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"camera.position\", position);\n  Core_Check.typeOf.object(\"camera.direction\", direction);\n  Core_Check.typeOf.object(\"camera.up\", up);\n  //>>includeEnd('debug');\n\n  Core_Cartesian3.normalize(direction, fromCameraF);\n  Core_Cartesian3.normalize(\n    Core_Cartesian3.cross(fromCameraF, up, fromCameraR),\n    fromCameraR\n  );\n  Core_Cartesian3.normalize(\n    Core_Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU),\n    fromCameraU\n  );\n\n  const sX = fromCameraR.x;\n  const sY = fromCameraR.y;\n  const sZ = fromCameraR.z;\n  const fX = fromCameraF.x;\n  const fY = fromCameraF.y;\n  const fZ = fromCameraF.z;\n  const uX = fromCameraU.x;\n  const uY = fromCameraU.y;\n  const uZ = fromCameraU.z;\n  const positionX = position.x;\n  const positionY = position.y;\n  const positionZ = position.z;\n  const t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;\n  const t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;\n  const t2 = fX * positionX + fY * positionY + fZ * positionZ;\n\n  // The code below this comment is an optimized\n  // version of the commented lines.\n  // Rather that create two matrices and then multiply,\n  // we just bake in the multiplcation as part of creation.\n  // const rotation = new Matrix4(\n  //                 sX,  sY,  sZ, 0.0,\n  //                 uX,  uY,  uZ, 0.0,\n  //                -fX, -fY, -fZ, 0.0,\n  //                 0.0,  0.0,  0.0, 1.0);\n  // const translation = new Matrix4(\n  //                 1.0, 0.0, 0.0, -position.x,\n  //                 0.0, 1.0, 0.0, -position.y,\n  //                 0.0, 0.0, 1.0, -position.z,\n  //                 0.0, 0.0, 0.0, 1.0);\n  // return rotation.multiply(translation);\n  if (!Core_defined(result)) {\n    return new Matrix4(\n      sX,\n      sY,\n      sZ,\n      t0,\n      uX,\n      uY,\n      uZ,\n      t1,\n      -fX,\n      -fY,\n      -fZ,\n      t2,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n  result[0] = sX;\n  result[1] = uX;\n  result[2] = -fX;\n  result[3] = 0.0;\n  result[4] = sY;\n  result[5] = uY;\n  result[6] = -fY;\n  result[7] = 0.0;\n  result[8] = sZ;\n  result[9] = uZ;\n  result[10] = -fZ;\n  result[11] = 0.0;\n  result[12] = t0;\n  result[13] = t1;\n  result[14] = t2;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing a perspective transformation matrix.\n *\n * @param {Number} fovY The field of view along the Y axis in radians.\n * @param {Number} aspectRatio The aspect ratio.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} fovY must be in (0, PI].\n * @exception {DeveloperError} aspectRatio must be greater than zero.\n * @exception {DeveloperError} near must be greater than zero.\n * @exception {DeveloperError} far must be greater than zero.\n */\nMatrix4.computePerspectiveFieldOfView = function (\n  fovY,\n  aspectRatio,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number.greaterThan(\"fovY\", fovY, 0.0);\n  Core_Check.typeOf.number.lessThan(\"fovY\", fovY, Math.PI);\n  Core_Check.typeOf.number.greaterThan(\"near\", near, 0.0);\n  Core_Check.typeOf.number.greaterThan(\"far\", far, 0.0);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const bottom = Math.tan(fovY * 0.5);\n\n  const column1Row1 = 1.0 / bottom;\n  const column0Row0 = column1Row1 / aspectRatio;\n  const column2Row2 = (far + near) / (near - far);\n  const column3Row2 = (2.0 * far * near) / (near - far);\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = column2Row2;\n  result[11] = -1.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an orthographic transformation matrix.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeOrthographicOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"left\", left);\n  Core_Check.typeOf.number(\"right\", right);\n  Core_Check.typeOf.number(\"bottom\", bottom);\n  Core_Check.typeOf.number(\"top\", top);\n  Core_Check.typeOf.number(\"near\", near);\n  Core_Check.typeOf.number(\"far\", far);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let a = 1.0 / (right - left);\n  let b = 1.0 / (top - bottom);\n  let c = 1.0 / (far - near);\n\n  const tx = -(right + left) * a;\n  const ty = -(top + bottom) * b;\n  const tz = -(far + near) * c;\n  a *= 2.0;\n  b *= 2.0;\n  c *= -2.0;\n\n  result[0] = a;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = b;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = c;\n  result[11] = 0.0;\n  result[12] = tx;\n  result[13] = ty;\n  result[14] = tz;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an off center perspective transformation.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computePerspectiveOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"left\", left);\n  Core_Check.typeOf.number(\"right\", right);\n  Core_Check.typeOf.number(\"bottom\", bottom);\n  Core_Check.typeOf.number(\"top\", top);\n  Core_Check.typeOf.number(\"near\", near);\n  Core_Check.typeOf.number(\"far\", far);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = (2.0 * near) / (right - left);\n  const column1Row1 = (2.0 * near) / (top - bottom);\n  const column2Row0 = (right + left) / (right - left);\n  const column2Row1 = (top + bottom) / (top - bottom);\n  const column2Row2 = -(far + near) / (far - near);\n  const column2Row3 = -1.0;\n  const column3Row2 = (-2.0 * far * near) / (far - near);\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an infinite off center perspective transformation.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeInfinitePerspectiveOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number(\"left\", left);\n  Core_Check.typeOf.number(\"right\", right);\n  Core_Check.typeOf.number(\"bottom\", bottom);\n  Core_Check.typeOf.number(\"top\", top);\n  Core_Check.typeOf.number(\"near\", near);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = (2.0 * near) / (right - left);\n  const column1Row1 = (2.0 * near) / (top - bottom);\n  const column2Row0 = (right + left) / (right - left);\n  const column2Row1 = (top + bottom) / (top - bottom);\n  const column2Row2 = -1.0;\n  const column2Row3 = -1.0;\n  const column3Row2 = -2.0 * near;\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.\n *\n * @param {Object} [viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.\n * @param {Number} [nearDepthRange=0.0] The near plane distance in window coordinates.\n * @param {Number} [farDepthRange=1.0] The far plane distance in window coordinates.\n * @param {Matrix4} [result] The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Create viewport transformation using an explicit viewport and depth range.\n * const m = Cesium.Matrix4.computeViewportTransformation({\n *     x : 0.0,\n *     y : 0.0,\n *     width : 1024.0,\n *     height : 768.0\n * }, 0.0, 1.0, new Cesium.Matrix4());\n */\nMatrix4.computeViewportTransformation = function (\n  viewport,\n  nearDepthRange,\n  farDepthRange,\n  result\n) {\n  if (!Core_defined(result)) {\n    result = new Matrix4();\n  }\n\n  viewport = Core_defaultValue(viewport, Core_defaultValue.EMPTY_OBJECT);\n  const x = Core_defaultValue(viewport.x, 0.0);\n  const y = Core_defaultValue(viewport.y, 0.0);\n  const width = Core_defaultValue(viewport.width, 0.0);\n  const height = Core_defaultValue(viewport.height, 0.0);\n  nearDepthRange = Core_defaultValue(nearDepthRange, 0.0);\n  farDepthRange = Core_defaultValue(farDepthRange, 1.0);\n\n  const halfWidth = width * 0.5;\n  const halfHeight = height * 0.5;\n  const halfDepth = (farDepthRange - nearDepthRange) * 0.5;\n\n  const column0Row0 = halfWidth;\n  const column1Row1 = halfHeight;\n  const column2Row2 = halfDepth;\n  const column3Row0 = x + halfWidth;\n  const column3Row1 = y + halfHeight;\n  const column3Row2 = nearDepthRange + halfDepth;\n  const column3Row3 = 1.0;\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = column3Row3;\n\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance that transforms from world space to view space.\n *\n * @param {Cartesian3} position The position of the camera.\n * @param {Cartesian3} direction The forward direction.\n * @param {Cartesian3} up The up direction.\n * @param {Cartesian3} right The right direction.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeView = function (position, direction, up, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"position\", position);\n  Core_Check.typeOf.object(\"direction\", direction);\n  Core_Check.typeOf.object(\"up\", up);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = right.x;\n  result[1] = up.x;\n  result[2] = -direction.x;\n  result[3] = 0.0;\n  result[4] = right.y;\n  result[5] = up.y;\n  result[6] = -direction.y;\n  result[7] = 0.0;\n  result[8] = right.z;\n  result[9] = up.z;\n  result[10] = -direction.z;\n  result[11] = 0.0;\n  result[12] = -Core_Cartesian3.dot(right, position);\n  result[13] = -Core_Cartesian3.dot(up, position);\n  result[14] = Core_Cartesian3.dot(direction, position);\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes an Array from the provided Matrix4 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix4} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n *\n * @example\n * //create an array from an instance of Matrix4\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n * const a = Cesium.Matrix4.toArray(m);\n *\n * // m remains the same\n * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]\n */\nMatrix4.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n      matrix[9],\n      matrix[10],\n      matrix[11],\n      matrix[12],\n      matrix[13],\n      matrix[14],\n      matrix[15],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, 2, or 3.\n * @exception {DeveloperError} column must be 0, 1, 2, or 3.\n *\n * @example\n * const myMatrix = new Cesium.Matrix4();\n * const column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index];\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix4.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"row\", row, 3);\n\n  Core_Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"column\", column, 3);\n  //>>includeEnd('debug');\n\n  return column * 4 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Creates an instance of Cartesian\n * const a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());\n *\n * @example\n * //Example 2: Sets values for Cartesian instance\n * const a = new Cesium.Cartesian4();\n * Cesium.Matrix4.getColumn(m, 2, a);\n *\n * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;\n */\nMatrix4.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 4;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  const z = matrix[startIndex + 2];\n  const w = matrix[startIndex + 3];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //creates a new Matrix4 instance with new column values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 99.0, 13.0]\n * //     [14.0, 15.0, 98.0, 17.0]\n * //     [18.0, 19.0, 97.0, 21.0]\n * //     [22.0, 23.0, 96.0, 25.0]\n */\nMatrix4.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix4.clone(matrix, result);\n  const startIndex = index * 4;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  result[startIndex + 3] = cartesian.w;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Returns an instance of Cartesian\n * const a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());\n *\n * @example\n * //Example 2: Sets values for a Cartesian instance\n * const a = new Cesium.Cartesian4();\n * Cesium.Matrix4.getRow(m, 2, a);\n *\n * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;\n */\nMatrix4.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 4];\n  const z = matrix[index + 8];\n  const w = matrix[index + 12];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //create a new Matrix4 instance with new row values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [99.0, 98.0, 97.0, 96.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n */\nMatrix4.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n\n  Core_Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix4.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 4] = cartesian.y;\n  result[index + 8] = cartesian.z;\n  result[index + 12] = cartesian.w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the translation in the rightmost column of the provided\n * matrix with the provided translation. This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.setTranslation = function (matrix, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"translation\", translation);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst Matrix4_scaleScratch1 = new Core_Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @see Matrix4.setUniformScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.multiplyByScale\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix4.getScale(matrix, Matrix4_scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  const scaleRatioZ = scale.z / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3];\n\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioY;\n  result[7] = matrix[7];\n\n  result[8] = matrix[8] * scaleRatioZ;\n  result[9] = matrix[9] * scaleRatioZ;\n  result[10] = matrix[10] * scaleRatioZ;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst Matrix4_scaleScratch2 = new Core_Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @see Matrix4.setScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.multiplyByScale\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix4.getScale(matrix, Matrix4_scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  const scaleRatioZ = scale / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3];\n\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioY;\n  result[7] = matrix[7];\n\n  result[8] = matrix[8] * scaleRatioZ;\n  result[9] = matrix[9] * scaleRatioZ;\n  result[10] = matrix[10] * scaleRatioZ;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst Matrix4_scratchColumn = new Core_Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter\n *\n * @see Matrix4.multiplyByScale\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.setScale\n * @see Matrix4.setUniformScale\n */\nMatrix4.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Core_Cartesian3.magnitude(\n    Core_Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], Matrix4_scratchColumn)\n  );\n  result.y = Core_Cartesian3.magnitude(\n    Core_Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], Matrix4_scratchColumn)\n  );\n  result.z = Core_Cartesian3.magnitude(\n    Core_Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], Matrix4_scratchColumn)\n  );\n  return result;\n};\n\nconst Matrix4_scaleScratch3 = new Core_Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors in the upper-left\n * 3x3 matrix.\n *\n * @param {Matrix4} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix4.getMaximumScale = function (matrix) {\n  Matrix4.getScale(matrix, Matrix4_scaleScratch3);\n  return Core_Cartesian3.maximumComponent(Matrix4_scaleScratch3);\n};\n\nconst Matrix4_scaleScratch4 = new Core_Cartesian3();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Matrix3} rotation The rotation matrix.\n * @returns {Matrix4} The modified result parameter.\n *\n * @see Matrix4.fromRotation\n * @see Matrix4.getRotation\n */\nMatrix4.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix4.getScale(matrix, Matrix4_scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.x;\n  result[3] = matrix[3];\n\n  result[4] = rotation[3] * scale.y;\n  result[5] = rotation[4] * scale.y;\n  result[6] = rotation[5] * scale.y;\n  result[7] = matrix[7];\n\n  result[8] = rotation[6] * scale.z;\n  result[9] = rotation[7] * scale.z;\n  result[10] = rotation[8] * scale.z;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst Matrix4_scaleScratch5 = new Core_Cartesian3();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix4.setRotation\n * @see Matrix4.fromRotation\n */\nMatrix4.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix4.getScale(matrix, Matrix4_scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.x;\n\n  result[3] = matrix[4] / scale.y;\n  result[4] = matrix[5] / scale.y;\n  result[5] = matrix[6] / scale.y;\n\n  result[6] = matrix[8] / scale.z;\n  result[7] = matrix[9] / scale.z;\n  result[8] = matrix[10] / scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const left0 = left[0];\n  const left1 = left[1];\n  const left2 = left[2];\n  const left3 = left[3];\n  const left4 = left[4];\n  const left5 = left[5];\n  const left6 = left[6];\n  const left7 = left[7];\n  const left8 = left[8];\n  const left9 = left[9];\n  const left10 = left[10];\n  const left11 = left[11];\n  const left12 = left[12];\n  const left13 = left[13];\n  const left14 = left[14];\n  const left15 = left[15];\n\n  const right0 = right[0];\n  const right1 = right[1];\n  const right2 = right[2];\n  const right3 = right[3];\n  const right4 = right[4];\n  const right5 = right[5];\n  const right6 = right[6];\n  const right7 = right[7];\n  const right8 = right[8];\n  const right9 = right[9];\n  const right10 = right[10];\n  const right11 = right[11];\n  const right12 = right[12];\n  const right13 = right[13];\n  const right14 = right[14];\n  const right15 = right[15];\n\n  const column0Row0 =\n    left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;\n  const column0Row1 =\n    left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;\n  const column0Row2 =\n    left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;\n  const column0Row3 =\n    left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;\n\n  const column1Row0 =\n    left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;\n  const column1Row1 =\n    left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;\n  const column1Row2 =\n    left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;\n  const column1Row3 =\n    left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;\n\n  const column2Row0 =\n    left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;\n  const column2Row1 =\n    left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;\n  const column2Row2 =\n    left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;\n  const column2Row3 =\n    left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;\n\n  const column3Row0 =\n    left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;\n  const column3Row1 =\n    left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;\n  const column3Row2 =\n    left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;\n  const column3Row3 =\n    left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column0Row3;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = column1Row3;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = column3Row3;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  result[9] = left[9] + right[9];\n  result[10] = left[10] + right[10];\n  result[11] = left[11] + right[11];\n  result[12] = left[12] + right[12];\n  result[13] = left[13] + right[13];\n  result[14] = left[14] + right[14];\n  result[15] = left[15] + right[15];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  result[9] = left[9] - right[9];\n  result[10] = left[10] - right[10];\n  result[11] = left[11] - right[11];\n  result[12] = left[12] - right[12];\n  result[13] = left[13] - right[13];\n  result[14] = left[14] - right[14];\n  result[15] = left[15] - right[15];\n  return result;\n};\n\n/**\n * Computes the product of two matrices assuming the matrices are affine transformation matrices,\n * where the upper left 3x3 elements are any matrix, and\n * the upper three elements in the fourth column are the translation.\n * The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * This method is faster than computing the product for general 4x4\n * matrices using {@link Matrix4.multiply}.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * const m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n * const m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));\n * const m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());\n */\nMatrix4.multiplyTransformation = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const left0 = left[0];\n  const left1 = left[1];\n  const left2 = left[2];\n  const left4 = left[4];\n  const left5 = left[5];\n  const left6 = left[6];\n  const left8 = left[8];\n  const left9 = left[9];\n  const left10 = left[10];\n  const left12 = left[12];\n  const left13 = left[13];\n  const left14 = left[14];\n\n  const right0 = right[0];\n  const right1 = right[1];\n  const right2 = right[2];\n  const right4 = right[4];\n  const right5 = right[5];\n  const right6 = right[6];\n  const right8 = right[8];\n  const right9 = right[9];\n  const right10 = right[10];\n  const right12 = right[12];\n  const right13 = right[13];\n  const right14 = right[14];\n\n  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n  const column3Row0 =\n    left0 * right12 + left4 * right13 + left8 * right14 + left12;\n  const column3Row1 =\n    left1 * right12 + left5 * right13 + left9 * right14 + left13;\n  const column3Row2 =\n    left2 * right12 + left6 * right13 + left10 * right14 + left14;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = 0.0;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by a 3x3 rotation matrix.  This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);\n * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);\n */\nMatrix4.multiplyByMatrix3 = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"rotation\", rotation);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const left0 = matrix[0];\n  const left1 = matrix[1];\n  const left2 = matrix[2];\n  const left4 = matrix[4];\n  const left5 = matrix[5];\n  const left6 = matrix[6];\n  const left8 = matrix[8];\n  const left9 = matrix[9];\n  const left10 = matrix[10];\n\n  const right0 = rotation[0];\n  const right1 = rotation[1];\n  const right2 = rotation[2];\n  const right4 = rotation[3];\n  const right5 = rotation[4];\n  const right6 = rotation[5];\n  const right8 = rotation[6];\n  const right9 = rotation[7];\n  const right10 = rotation[8];\n\n  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = 0.0;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Cartesian3} translation The translation on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);\n * Cesium.Matrix4.multiplyByTranslation(m, position, m);\n */\nMatrix4.multiplyByTranslation = function (matrix, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"translation\", translation);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = translation.x;\n  const y = translation.y;\n  const z = translation.z;\n\n  const tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];\n  const ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];\n  const tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = tx;\n  result[13] = ty;\n  result[14] = tz;\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by an implicit non-uniform scale matrix. This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where\n * <code>m</code> must be an affine matrix.\n * This function performs fewer allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The affine matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);\n * Cesium.Matrix4.multiplyByScale(m, scale, m);\n *\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.setScale\n * @see Matrix4.setUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scaleX = scale.x;\n  const scaleY = scale.y;\n  const scaleZ = scale.z;\n\n  // Faster than Cartesian3.equals\n  if (scaleX === 1.0 && scaleY === 1.0 && scaleZ === 1.0) {\n    return Matrix4.clone(matrix, result);\n  }\n\n  result[0] = scaleX * matrix[0];\n  result[1] = scaleX * matrix[1];\n  result[2] = scaleX * matrix[2];\n  result[3] = matrix[3];\n\n  result[4] = scaleY * matrix[4];\n  result[5] = scaleY * matrix[5];\n  result[6] = scaleY * matrix[6];\n  result[7] = matrix[7];\n\n  result[8] = scaleZ * matrix[8];\n  result[9] = scaleZ * matrix[9];\n  result[10] = scaleZ * matrix[10];\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Number} scale The uniform scale on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);\n * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix4.multiplyByScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.setScale\n * @see Matrix4.setUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number(\"scale\", scale);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3];\n\n  result[4] = matrix[4] * scale;\n  result[5] = matrix[5] * scale;\n  result[6] = matrix[6] * scale;\n  result[7] = matrix[7];\n\n  result[8] = matrix[8] * scale;\n  result[9] = matrix[9] * scale;\n  result[10] = matrix[10] * scale;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian4} cartesian The vector.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nMatrix4.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n  const vW = cartesian.w;\n\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;\n  const w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}\n * with a {@link Cartesian4} with a <code>w</code> component of zero.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} cartesian The point.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @example\n * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());\n * // A shortcut for\n * //   Cartesian3 p = ...\n * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);\n */\nMatrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}\n * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} cartesian The point.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @example\n * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());\n */\nMatrix4.multiplyByPoint = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //create a Matrix4 instance which is a scaled version of the supplied Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-20.0, -22.0, -24.0, -26.0]\n * //     [-28.0, -30.0, -32.0, -34.0]\n * //     [-36.0, -38.0, -40.0, -42.0]\n * //     [-44.0, -46.0, -48.0, -50.0]\n */\nMatrix4.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  result[9] = matrix[9] * scalar;\n  result[10] = matrix[10] * scalar;\n  result[11] = matrix[11] * scalar;\n  result[12] = matrix[12] * scalar;\n  result[13] = matrix[13] * scalar;\n  result[14] = matrix[14] * scalar;\n  result[15] = matrix[15] * scalar;\n  return result;\n};\n\n/**\n * Computes a negated copy of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to negate.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //create a new Matrix4 instance which is a negation of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-10.0, -11.0, -12.0, -13.0]\n * //     [-14.0, -15.0, -16.0, -17.0]\n * //     [-18.0, -19.0, -20.0, -21.0]\n * //     [-22.0, -23.0, -24.0, -25.0]\n */\nMatrix4.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  result[9] = -matrix[9];\n  result[10] = -matrix[10];\n  result[11] = -matrix[11];\n  result[12] = -matrix[12];\n  result[13] = -matrix[13];\n  result[14] = -matrix[14];\n  result[15] = -matrix[15];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to transpose.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //returns transpose of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n */\nMatrix4.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const matrix1 = matrix[1];\n  const matrix2 = matrix[2];\n  const matrix3 = matrix[3];\n  const matrix6 = matrix[6];\n  const matrix7 = matrix[7];\n  const matrix11 = matrix[11];\n\n  result[0] = matrix[0];\n  result[1] = matrix[4];\n  result[2] = matrix[8];\n  result[3] = matrix[12];\n  result[4] = matrix1;\n  result[5] = matrix[5];\n  result[6] = matrix[9];\n  result[7] = matrix[13];\n  result[8] = matrix2;\n  result[9] = matrix6;\n  result[10] = matrix[10];\n  result[11] = matrix[14];\n  result[12] = matrix3;\n  result[13] = matrix7;\n  result[14] = matrix11;\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix4} matrix The matrix with signed elements.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n  result[9] = Math.abs(matrix[9]);\n  result[10] = Math.abs(matrix[10]);\n  result[11] = Math.abs(matrix[11]);\n  result[12] = Math.abs(matrix[12]);\n  result[13] = Math.abs(matrix[13]);\n  result[14] = Math.abs(matrix[14]);\n  result[15] = Math.abs(matrix[15]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix4} [left] The first matrix.\n * @param {Matrix4} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n *\n * @example\n * //compares two Matrix4 instances\n *\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equals(a,b)) {\n *      console.log(\"Both matrices are equal\");\n * } else {\n *      console.log(\"They are not equal\");\n * }\n *\n * //Prints \"Both matrices are equal\" on the console\n */\nMatrix4.equals = function (left, right) {\n  // Given that most matrices will be transformation matrices, the elements\n  // are tested in order such that the test is likely to fail as early\n  // as possible.  I _think_ this is just as friendly to the L1 cache\n  // as testing in index order.  It is certainty faster in practice.\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      // Translation\n      left[12] === right[12] &&\n      left[13] === right[13] &&\n      left[14] === right[14] &&\n      // Rotation/scale\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[8] === right[8] &&\n      left[9] === right[9] &&\n      left[10] === right[10] &&\n      // Bottom row\n      left[3] === right[3] &&\n      left[7] === right[7] &&\n      left[11] === right[11] &&\n      left[15] === right[15])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix4} [left] The first matrix.\n * @param {Matrix4} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n *\n * @example\n * //compares two Matrix4 instances\n *\n * // a = [10.5, 14.5, 18.5, 22.5]\n * //     [11.5, 15.5, 19.5, 23.5]\n * //     [12.5, 16.5, 20.5, 24.5]\n * //     [13.5, 17.5, 21.5, 25.5]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){\n *      console.log(\"Difference between both the matrices is less than 0.1\");\n * } else {\n *      console.log(\"Difference between both the matrices is not less than 0.1\");\n * }\n *\n * //Prints \"Difference between both the matrices is not less than 0.1\" on the console\n */\nMatrix4.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = Core_defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon &&\n      Math.abs(left[9] - right[9]) <= epsilon &&\n      Math.abs(left[10] - right[10]) <= epsilon &&\n      Math.abs(left[11] - right[11]) <= epsilon &&\n      Math.abs(left[12] - right[12]) <= epsilon &&\n      Math.abs(left[13] - right[13]) <= epsilon &&\n      Math.abs(left[14] - right[14]) <= epsilon &&\n      Math.abs(left[15] - right[15]) <= epsilon)\n  );\n};\n\n/**\n * Gets the translation portion of the provided matrix, assuming the matrix is an affine transformation matrix.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix4.getTranslation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = matrix[12];\n  result.y = matrix[13];\n  result.z = matrix[14];\n  return result;\n};\n\n/**\n * Gets the upper left 3x3 matrix of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // returns a Matrix3 instance from a Matrix4 instance\n *\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * const b = new Cesium.Matrix3();\n * Cesium.Matrix4.getMatrix3(m,b);\n *\n * // b = [10.0, 14.0, 18.0]\n * //     [11.0, 15.0, 19.0]\n * //     [12.0, 16.0, 20.0]\n */\nMatrix4.getMatrix3 = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[4];\n  result[4] = matrix[5];\n  result[5] = matrix[6];\n  result[6] = matrix[8];\n  result[7] = matrix[9];\n  result[8] = matrix[10];\n  return result;\n};\n\nconst scratchInverseRotation = new Core_Matrix3();\nconst scratchMatrix3Zero = new Core_Matrix3();\nconst scratchBottomRow = new Core_Cartesian4();\nconst scratchExpectedBottomRow = new Core_Cartesian4(0.0, 0.0, 0.0, 1.0);\n\n/**\n * Computes the inverse of the provided matrix using Cramers Rule.\n * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.\n * If the matrix is a proper rigid transformation, it is more efficient\n * to invert it with {@link Matrix4.inverseTransformation}.\n *\n * @param {Matrix4} matrix The matrix to invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {RuntimeError} matrix is not invertible because its determinate is zero.\n */\nMatrix4.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  //\n  // Ported from:\n  //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf\n  //\n  const src0 = matrix[0];\n  const src1 = matrix[4];\n  const src2 = matrix[8];\n  const src3 = matrix[12];\n  const src4 = matrix[1];\n  const src5 = matrix[5];\n  const src6 = matrix[9];\n  const src7 = matrix[13];\n  const src8 = matrix[2];\n  const src9 = matrix[6];\n  const src10 = matrix[10];\n  const src11 = matrix[14];\n  const src12 = matrix[3];\n  const src13 = matrix[7];\n  const src14 = matrix[11];\n  const src15 = matrix[15];\n\n  // calculate pairs for first 8 elements (cofactors)\n  let tmp0 = src10 * src15;\n  let tmp1 = src11 * src14;\n  let tmp2 = src9 * src15;\n  let tmp3 = src11 * src13;\n  let tmp4 = src9 * src14;\n  let tmp5 = src10 * src13;\n  let tmp6 = src8 * src15;\n  let tmp7 = src11 * src12;\n  let tmp8 = src8 * src14;\n  let tmp9 = src10 * src12;\n  let tmp10 = src8 * src13;\n  let tmp11 = src9 * src12;\n\n  // calculate first 8 elements (cofactors)\n  const dst0 =\n    tmp0 * src5 +\n    tmp3 * src6 +\n    tmp4 * src7 -\n    (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);\n  const dst1 =\n    tmp1 * src4 +\n    tmp6 * src6 +\n    tmp9 * src7 -\n    (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);\n  const dst2 =\n    tmp2 * src4 +\n    tmp7 * src5 +\n    tmp10 * src7 -\n    (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);\n  const dst3 =\n    tmp5 * src4 +\n    tmp8 * src5 +\n    tmp11 * src6 -\n    (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);\n  const dst4 =\n    tmp1 * src1 +\n    tmp2 * src2 +\n    tmp5 * src3 -\n    (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);\n  const dst5 =\n    tmp0 * src0 +\n    tmp7 * src2 +\n    tmp8 * src3 -\n    (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);\n  const dst6 =\n    tmp3 * src0 +\n    tmp6 * src1 +\n    tmp11 * src3 -\n    (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);\n  const dst7 =\n    tmp4 * src0 +\n    tmp9 * src1 +\n    tmp10 * src2 -\n    (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);\n\n  // calculate pairs for second 8 elements (cofactors)\n  tmp0 = src2 * src7;\n  tmp1 = src3 * src6;\n  tmp2 = src1 * src7;\n  tmp3 = src3 * src5;\n  tmp4 = src1 * src6;\n  tmp5 = src2 * src5;\n  tmp6 = src0 * src7;\n  tmp7 = src3 * src4;\n  tmp8 = src0 * src6;\n  tmp9 = src2 * src4;\n  tmp10 = src0 * src5;\n  tmp11 = src1 * src4;\n\n  // calculate second 8 elements (cofactors)\n  const dst8 =\n    tmp0 * src13 +\n    tmp3 * src14 +\n    tmp4 * src15 -\n    (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);\n  const dst9 =\n    tmp1 * src12 +\n    tmp6 * src14 +\n    tmp9 * src15 -\n    (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);\n  const dst10 =\n    tmp2 * src12 +\n    tmp7 * src13 +\n    tmp10 * src15 -\n    (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);\n  const dst11 =\n    tmp5 * src12 +\n    tmp8 * src13 +\n    tmp11 * src14 -\n    (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);\n  const dst12 =\n    tmp2 * src10 +\n    tmp5 * src11 +\n    tmp1 * src9 -\n    (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);\n  const dst13 =\n    tmp8 * src11 +\n    tmp0 * src8 +\n    tmp7 * src10 -\n    (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);\n  const dst14 =\n    tmp6 * src9 +\n    tmp11 * src11 +\n    tmp3 * src8 -\n    (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);\n  const dst15 =\n    tmp10 * src10 +\n    tmp4 * src8 +\n    tmp9 * src9 -\n    (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);\n\n  // calculate determinant\n  let det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;\n\n  if (Math.abs(det) < Core_Math.EPSILON21) {\n    // Special case for a zero scale matrix that can occur, for example,\n    // when a model's node has a [0, 0, 0] scale.\n    if (\n      Core_Matrix3.equalsEpsilon(\n        Matrix4.getMatrix3(matrix, scratchInverseRotation),\n        scratchMatrix3Zero,\n        Core_Math.EPSILON7\n      ) &&\n      Core_Cartesian4.equals(\n        Matrix4.getRow(matrix, 3, scratchBottomRow),\n        scratchExpectedBottomRow\n      )\n    ) {\n      result[0] = 0.0;\n      result[1] = 0.0;\n      result[2] = 0.0;\n      result[3] = 0.0;\n      result[4] = 0.0;\n      result[5] = 0.0;\n      result[6] = 0.0;\n      result[7] = 0.0;\n      result[8] = 0.0;\n      result[9] = 0.0;\n      result[10] = 0.0;\n      result[11] = 0.0;\n      result[12] = -matrix[12];\n      result[13] = -matrix[13];\n      result[14] = -matrix[14];\n      result[15] = 1.0;\n      return result;\n    }\n\n    throw new Core_RuntimeError(\n      \"matrix is not invertible because its determinate is zero.\"\n    );\n  }\n\n  // calculate matrix inverse\n  det = 1.0 / det;\n\n  result[0] = dst0 * det;\n  result[1] = dst1 * det;\n  result[2] = dst2 * det;\n  result[3] = dst3 * det;\n  result[4] = dst4 * det;\n  result[5] = dst5 * det;\n  result[6] = dst6 * det;\n  result[7] = dst7 * det;\n  result[8] = dst8 * det;\n  result[9] = dst9 * det;\n  result[10] = dst10 * det;\n  result[11] = dst11 * det;\n  result[12] = dst12 * det;\n  result[13] = dst13 * det;\n  result[14] = dst14 * det;\n  result[15] = dst15 * det;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided matrix assuming it is a proper rigid matrix,\n * where the upper left 3x3 elements are a rotation matrix,\n * and the upper three elements in the fourth column are the translation.\n * The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * This method is faster than computing the inverse for a general 4x4\n * matrix using {@link Matrix4.inverse}.\n *\n * @param {Matrix4} matrix The matrix to invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.inverseTransformation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  //This function is an optimized version of the below 4 lines.\n  //const rT = Matrix3.transpose(Matrix4.getMatrix3(matrix));\n  //const rTN = Matrix3.negate(rT);\n  //const rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));\n  //return Matrix4.fromRotationTranslation(rT, rTT, result);\n\n  const matrix0 = matrix[0];\n  const matrix1 = matrix[1];\n  const matrix2 = matrix[2];\n  const matrix4 = matrix[4];\n  const matrix5 = matrix[5];\n  const matrix6 = matrix[6];\n  const matrix8 = matrix[8];\n  const matrix9 = matrix[9];\n  const matrix10 = matrix[10];\n\n  const vX = matrix[12];\n  const vY = matrix[13];\n  const vZ = matrix[14];\n\n  const x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;\n  const y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;\n  const z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;\n\n  result[0] = matrix0;\n  result[1] = matrix4;\n  result[2] = matrix8;\n  result[3] = 0.0;\n  result[4] = matrix1;\n  result[5] = matrix5;\n  result[6] = matrix9;\n  result[7] = 0.0;\n  result[8] = matrix2;\n  result[9] = matrix6;\n  result[10] = matrix10;\n  result[11] = 0.0;\n  result[12] = x;\n  result[13] = y;\n  result[14] = z;\n  result[15] = 1.0;\n  return result;\n};\n\nconst Matrix4_scratchTransposeMatrix = new Matrix4();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix4} matrix The matrix to transpose and invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix4.inverse(\n    Matrix4.transpose(matrix, Matrix4_scratchTransposeMatrix),\n    result\n  );\n};\n\n/**\n * An immutable Matrix4 instance initialized to the identity matrix.\n *\n * @type {Matrix4}\n * @constant\n */\nMatrix4.IDENTITY = Object.freeze(\n  new Matrix4(\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  )\n);\n\n/**\n * An immutable Matrix4 instance initialized to the zero matrix.\n *\n * @type {Matrix4}\n * @constant\n */\nMatrix4.ZERO = Object.freeze(\n  new Matrix4(\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0\n  )\n);\n\n/**\n * The index into Matrix4 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix4 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix4 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix4 for column 0, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW3 = 3;\n\n/**\n * The index into Matrix4 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW0 = 4;\n\n/**\n * The index into Matrix4 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW1 = 5;\n\n/**\n * The index into Matrix4 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW2 = 6;\n\n/**\n * The index into Matrix4 for column 1, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW3 = 7;\n\n/**\n * The index into Matrix4 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW0 = 8;\n\n/**\n * The index into Matrix4 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW1 = 9;\n\n/**\n * The index into Matrix4 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW2 = 10;\n\n/**\n * The index into Matrix4 for column 2, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW3 = 11;\n\n/**\n * The index into Matrix4 for column 3, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW0 = 12;\n\n/**\n * The index into Matrix4 for column 3, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW1 = 13;\n\n/**\n * The index into Matrix4 for column 3, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW2 = 14;\n\n/**\n * The index into Matrix4 for column 3, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW3 = 15;\n\nObject.defineProperties(Matrix4.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix4.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix4.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix4 instance.\n *\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n */\nMatrix4.prototype.clone = function (result) {\n  return Matrix4.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix4} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix4.prototype.equals = function (right) {\n  return Matrix4.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix4.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8] &&\n    matrix[9] === array[offset + 9] &&\n    matrix[10] === array[offset + 10] &&\n    matrix[11] === array[offset + 11] &&\n    matrix[12] === array[offset + 12] &&\n    matrix[13] === array[offset + 13] &&\n    matrix[14] === array[offset + 14] &&\n    matrix[15] === array[offset + 15]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix4} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix4.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix4.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Computes a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2, column3)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.\n */\nMatrix4.prototype.toString = function () {\n  return (\n    `(${this[0]}, ${this[4]}, ${this[8]}, ${this[12]})\\n` +\n    `(${this[1]}, ${this[5]}, ${this[9]}, ${this[13]})\\n` +\n    `(${this[2]}, ${this[6]}, ${this[10]}, ${this[14]})\\n` +\n    `(${this[3]}, ${this[7]}, ${this[11]}, ${this[15]})`\n  );\n};\n/* harmony default export */ const Core_Matrix4 = (Matrix4);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/GeographicProjection.js\n\n\n\n\n\n\n\n/**\n * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying\n * them by the {@link Ellipsoid#maximumRadius}.  This projection\n * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It\n * is also known as EPSG:4326.\n *\n * @alias GeographicProjection\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n *\n * @see WebMercatorProjection\n */\nfunction GeographicProjection(ellipsoid) {\n  this._ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n  this._semimajorAxis = this._ellipsoid.maximumRadius;\n  this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;\n}\n\nObject.defineProperties(GeographicProjection.prototype, {\n  /**\n   * Gets the {@link Ellipsoid}.\n   *\n   * @memberof GeographicProjection.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.\n * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the\n * ellipsoid.  Z is the unmodified height.\n *\n * @param {Cartographic} cartographic The coordinates to project.\n * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nGeographicProjection.prototype.project = function (cartographic, result) {\n  // Actually this is the special case of equidistant cylindrical called the plate carree\n  const semimajorAxis = this._semimajorAxis;\n  const x = cartographic.longitude * semimajorAxis;\n  const y = cartographic.latitude * semimajorAxis;\n  const z = cartographic.height;\n\n  if (!Core_defined(result)) {\n    return new Core_Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}\n * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,\n * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.\n *\n * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.\n * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nGeographicProjection.prototype.unproject = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required\");\n  }\n  //>>includeEnd('debug');\n\n  const oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;\n  const longitude = cartesian.x * oneOverEarthSemimajorAxis;\n  const latitude = cartesian.y * oneOverEarthSemimajorAxis;\n  const height = cartesian.z;\n\n  if (!Core_defined(result)) {\n    return new Core_Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n/* harmony default export */ const Core_GeographicProjection = (GeographicProjection);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Intersect.js\n/**\n * This enumerated type is used in determining where, relative to the frustum, an\n * object is located. The object can either be fully contained within the frustum (INSIDE),\n * partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely\n * outside of the frustum's 6 planes (OUTSIDE).\n *\n * @enum {Number}\n */\nconst Intersect = {\n  /**\n   * Represents that an object is not contained within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  OUTSIDE: -1,\n\n  /**\n   * Represents that an object intersects one of the frustum's planes.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INTERSECTING: 0,\n\n  /**\n   * Represents that an object is fully within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INSIDE: 1,\n};\n/* harmony default export */ const Core_Intersect = (Object.freeze(Intersect));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Interval.js\n\n\n/**\n * Represents the closed interval [start, stop].\n * @alias Interval\n * @constructor\n *\n * @param {Number} [start=0.0] The beginning of the interval.\n * @param {Number} [stop=0.0] The end of the interval.\n */\nfunction Interval(start, stop) {\n  /**\n   * The beginning of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.start = Core_defaultValue(start, 0.0);\n  /**\n   * The end of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.stop = Core_defaultValue(stop, 0.0);\n}\n/* harmony default export */ const Core_Interval = (Interval);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Rectangle.js\n\n\n\n\n\n\n\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.west = Core_defaultValue(west, 0.0);\n\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.south = Core_defaultValue(south, 0.0);\n\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.east = Core_defaultValue(east, 0.0);\n\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.north = Core_defaultValue(north, 0.0);\n}\n\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   * @readonly\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    },\n  },\n\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   * @readonly\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {Number} The width.\n */\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  let east = rectangle.east;\n  const west = rectangle.west;\n  if (east < west) {\n    east += Core_Math.TWO_PI;\n  }\n  return east - west;\n};\n\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {Number} The height.\n */\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  return rectangle.north - rectangle.south;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = Core_Math.toRadians(Core_defaultValue(west, 0.0));\n  south = Core_Math.toRadians(Core_defaultValue(south, 0.0));\n  east = Core_Math.toRadians(Core_defaultValue(east, 0.0));\n  north = Core_Math.toRadians(Core_defaultValue(north, 0.0));\n\n  if (!Core_defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n\n  return result;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!Core_defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = Core_defaultValue(west, 0.0);\n  result.south = Core_defaultValue(south, 0.0);\n  result.east = Core_defaultValue(east, 0.0);\n  result.north = Core_defaultValue(north, 0.0);\n\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n\n  for (let i = 0, len = cartographics.length; i < len; i++) {\n    const position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    const lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + Core_Math.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > Core_Math.PI) {\n      east = east - Core_Math.TWO_PI;\n    }\n    if (west > Core_Math.PI) {\n      west = west - Core_Math.TWO_PI;\n    }\n  }\n\n  if (!Core_defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n  ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n\n  for (let i = 0, len = cartesians.length; i < len; i++) {\n    const position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    const lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + Core_Math.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > Core_Math.PI) {\n      east = east - Core_Math.TWO_PI;\n    }\n    if (west > Core_Math.PI) {\n      west = west - Core_Math.TWO_PI;\n    }\n  }\n\n  if (!Core_defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\nRectangle.clone = function (rectangle, result) {\n  if (!Core_defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    return new Rectangle(\n      rectangle.west,\n      rectangle.south,\n      rectangle.east,\n      rectangle.north\n    );\n  }\n\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {Number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  absoluteEpsilon = Core_defaultValue(absoluteEpsilon, 0);\n\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Math.abs(left.west - right.west) <= absoluteEpsilon &&\n      Math.abs(left.south - right.south) <= absoluteEpsilon &&\n      Math.abs(left.east - right.east) <= absoluteEpsilon &&\n      Math.abs(left.north - right.north) <= absoluteEpsilon)\n  );\n};\n\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.west === right.west &&\n      left.south === right.south &&\n      left.east === right.east &&\n      left.north === right.north)\n  );\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n */\nRectangle.validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n\n  const north = rectangle.north;\n  Core_Check.typeOf.number.greaterThanOrEquals(\n    \"north\",\n    north,\n    -Core_Math.PI_OVER_TWO\n  );\n  Core_Check.typeOf.number.lessThanOrEquals(\"north\", north, Core_Math.PI_OVER_TWO);\n\n  const south = rectangle.south;\n  Core_Check.typeOf.number.greaterThanOrEquals(\n    \"south\",\n    south,\n    -Core_Math.PI_OVER_TWO\n  );\n  Core_Check.typeOf.number.lessThanOrEquals(\"south\", south, Core_Math.PI_OVER_TWO);\n\n  const west = rectangle.west;\n  Core_Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Core_Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n\n  const east = rectangle.east;\n  Core_Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Core_Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\n  //>>includeEnd('debug');\n};\n\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Core_Cartographic(rectangle.west, rectangle.south);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Core_Cartographic(rectangle.west, rectangle.north);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Core_Cartographic(rectangle.east, rectangle.north);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Core_Cartographic(rectangle.east, rectangle.south);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  let east = rectangle.east;\n  const west = rectangle.west;\n\n  if (east < west) {\n    east += Core_Math.TWO_PI;\n  }\n\n  const longitude = Core_Math.negativePiToPi((west + east) * 0.5);\n  const latitude = (rectangle.south + rectangle.north) * 0.5;\n\n  if (!Core_defined(result)) {\n    return new Core_Cartographic(longitude, latitude);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  Core_Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += Core_Math.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += Core_Math.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += Core_Math.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += Core_Math.TWO_PI;\n  }\n\n  const west = Core_Math.negativePiToPi(\n    Math.max(rectangleWest, otherRectangleWest)\n  );\n  const east = Core_Math.negativePiToPi(\n    Math.min(rectangleEast, otherRectangleEast)\n  );\n\n  if (\n    (rectangle.west < rectangle.east ||\n      otherRectangle.west < otherRectangle.east) &&\n    east <= west\n  ) {\n    return undefined;\n  }\n\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  Core_Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  const west = Math.max(rectangle.west, otherRectangle.west);\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const east = Math.min(rectangle.east, otherRectangle.east);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  Core_Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Rectangle();\n  }\n\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += Core_Math.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += Core_Math.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += Core_Math.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += Core_Math.TWO_PI;\n  }\n\n  const west = Core_Math.negativePiToPi(\n    Math.min(rectangleWest, otherRectangleWest)\n  );\n  const east = Core_Math.negativePiToPi(\n    Math.max(rectangleEast, otherRectangleEast)\n  );\n\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n\n  return result;\n};\n\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  Core_Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n\n  return result;\n};\n\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  Core_Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  let longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n\n  const west = rectangle.west;\n  let east = rectangle.east;\n\n  if (east < west) {\n    east += Core_Math.TWO_PI;\n    if (longitude < 0.0) {\n      longitude += Core_Math.TWO_PI;\n    }\n  }\n  return (\n    (longitude > west ||\n      Core_Math.equalsEpsilon(longitude, west, Core_Math.EPSILON14)) &&\n    (longitude < east ||\n      Core_Math.equalsEpsilon(longitude, east, Core_Math.EPSILON14)) &&\n    latitude >= rectangle.south &&\n    latitude <= rectangle.north\n  );\n};\n\nconst subsampleLlaScratch = new Core_Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n  surfaceHeight = Core_defaultValue(surfaceHeight, 0.0);\n\n  if (!Core_defined(result)) {\n    result = [];\n  }\n  let length = 0;\n\n  const north = rectangle.north;\n  const south = rectangle.south;\n  const east = rectangle.east;\n  const west = rectangle.west;\n\n  const lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n\n  for (let i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * Core_Math.PI_OVER_TWO;\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n  result.length = length;\n  return result;\n};\n\n/**\n * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].\n *\n * @param {Rectangle} rectangle The rectangle to subsection.\n * @param {Number} westLerp The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.\n * @param {Number} southLerp The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.\n * @param {Number} eastLerp The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.\n * @param {Number} northLerp The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.subsection = function (\n  rectangle,\n  westLerp,\n  southLerp,\n  eastLerp,\n  northLerp,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"rectangle\", rectangle);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"westLerp\", westLerp, 0.0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, 1.0);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"southLerp\", southLerp, 0.0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, 1.0);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"eastLerp\", eastLerp, 0.0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"eastLerp\", eastLerp, 1.0);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"northLerp\", northLerp, 0.0);\n  Core_Check.typeOf.number.lessThanOrEquals(\"northLerp\", northLerp, 1.0);\n\n  Core_Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, eastLerp);\n  Core_Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, northLerp);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Rectangle();\n  }\n\n  // This function doesn't use CesiumMath.lerp because it has floating point precision problems\n  // when the start and end values are the same but the t changes.\n\n  if (rectangle.west <= rectangle.east) {\n    const width = rectangle.east - rectangle.west;\n    result.west = rectangle.west + westLerp * width;\n    result.east = rectangle.west + eastLerp * width;\n  } else {\n    const width = Core_Math.TWO_PI + rectangle.east - rectangle.west;\n    result.west = Core_Math.negativePiToPi(rectangle.west + westLerp * width);\n    result.east = Core_Math.negativePiToPi(rectangle.west + eastLerp * width);\n  }\n  const height = rectangle.north - rectangle.south;\n  result.south = rectangle.south + southLerp * height;\n  result.north = rectangle.south + northLerp * height;\n\n  // Fix floating point precision problems when t = 1\n  if (westLerp === 1.0) {\n    result.west = rectangle.east;\n  }\n  if (eastLerp === 1.0) {\n    result.east = rectangle.east;\n  }\n  if (southLerp === 1.0) {\n    result.south = rectangle.north;\n  }\n  if (northLerp === 1.0) {\n    result.north = rectangle.north;\n  }\n\n  return result;\n};\n\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\nRectangle.MAX_VALUE = Object.freeze(\n  new Rectangle(\n    -Math.PI,\n    -Core_Math.PI_OVER_TWO,\n    Math.PI,\n    Core_Math.PI_OVER_TWO\n  )\n);\n/* harmony default export */ const Core_Rectangle = (Rectangle);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/BoundingSphere.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A bounding sphere with a center and a radius.\n * @alias BoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {Number} [radius=0.0] The radius of the bounding sphere.\n *\n * @see AxisAlignedBoundingBox\n * @see BoundingRectangle\n * @see Packable\n */\nfunction BoundingSphere(center, radius) {\n  /**\n   * The center point of the sphere.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Core_Cartesian3.clone(Core_defaultValue(center, Core_Cartesian3.ZERO));\n\n  /**\n   * The radius of the sphere.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.radius = Core_defaultValue(radius, 0.0);\n}\n\nconst fromPointsXMin = new Core_Cartesian3();\nconst fromPointsYMin = new Core_Cartesian3();\nconst fromPointsZMin = new Core_Cartesian3();\nconst fromPointsXMax = new Core_Cartesian3();\nconst fromPointsYMax = new Core_Cartesian3();\nconst fromPointsZMax = new Core_Cartesian3();\nconst fromPointsCurrentPos = new Core_Cartesian3();\nconst fromPointsScratch = new Core_Cartesian3();\nconst fromPointsRitterCenter = new Core_Cartesian3();\nconst fromPointsMinBoxPt = new Core_Cartesian3();\nconst fromPointsMaxBoxPt = new Core_Cartesian3();\nconst fromPointsNaiveCenterScratch = new Core_Cartesian3();\nconst volumeConstant = (4.0 / 3.0) * Core_Math.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n *\n * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n */\nBoundingSphere.fromPoints = function (positions, result) {\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!Core_defined(positions) || positions.length === 0) {\n    result.center = Core_Cartesian3.clone(Core_Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const currentPos = Core_Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n  const xMin = Core_Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Core_Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Core_Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Core_Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Core_Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Core_Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numPositions = positions.length;\n  let i;\n  for (i = 1; i < numPositions; i++) {\n    Core_Cartesian3.clone(positions[i], currentPos);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Core_Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Core_Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Core_Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Core_Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Core_Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Core_Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  const ySpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  const zSpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Core_Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numPositions; i++) {\n    Core_Cartesian3.clone(positions[i], currentPos);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Core_Cartesian3.magnitude(\n      Core_Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Core_Cartesian3.magnitudeSquared(\n      Core_Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Core_Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Core_Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\nconst defaultProjection = new Core_GeographicProjection();\nconst fromRectangle2DLowerLeft = new Core_Cartesian3();\nconst fromRectangle2DUpperRight = new Core_Cartesian3();\nconst fromRectangle2DSouthwest = new Core_Cartographic();\nconst fromRectangle2DNortheast = new Core_Cartographic();\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle2D = function (rectangle, projection, result) {\n  return BoundingSphere.fromRectangleWithHeights2D(\n    rectangle,\n    projection,\n    0.0,\n    0.0,\n    result\n  );\n};\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n * object's minimum and maximum heights over the rectangle.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.\n * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangleWithHeights2D = function (\n  rectangle,\n  projection,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!Core_defined(rectangle)) {\n    result.center = Core_Cartesian3.clone(Core_Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  projection = Core_defaultValue(projection, defaultProjection);\n\n  Core_Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n  fromRectangle2DSouthwest.height = minimumHeight;\n  Core_Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n  fromRectangle2DNortheast.height = maximumHeight;\n\n  const lowerLeft = projection.project(\n    fromRectangle2DSouthwest,\n    fromRectangle2DLowerLeft\n  );\n  const upperRight = projection.project(\n    fromRectangle2DNortheast,\n    fromRectangle2DUpperRight\n  );\n\n  const width = upperRight.x - lowerLeft.x;\n  const height = upperRight.y - lowerLeft.y;\n  const elevation = upperRight.z - lowerLeft.z;\n\n  result.radius =\n    Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n  const center = result.center;\n  center.x = lowerLeft.x + width * 0.5;\n  center.y = lowerLeft.y + height * 0.5;\n  center.z = lowerLeft.z + elevation * 0.5;\n  return result;\n};\n\nconst fromRectangle3DScratch = [];\n\n/**\n * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n *\n * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle3D = function (\n  rectangle,\n  ellipsoid,\n  surfaceHeight,\n  result\n) {\n  ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n  surfaceHeight = Core_defaultValue(surfaceHeight, 0.0);\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!Core_defined(rectangle)) {\n    result.center = Core_Cartesian3.clone(Core_Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const positions = Core_Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    surfaceHeight,\n    fromRectangle3DScratch\n  );\n  return BoundingSphere.fromPoints(positions, result);\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n *        origin of the coordinate system.  This is useful when the positions are to be used for\n *        relative-to-center (RTC) rendering.\n * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n *        the stride is 5, however, two array elements are skipped and the next position begins at array\n *        index 5.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @example\n * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromVertices = function (positions, center, stride, result) {\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!Core_defined(positions) || positions.length === 0) {\n    result.center = Core_Cartesian3.clone(Core_Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  center = Core_defaultValue(center, Core_Cartesian3.ZERO);\n\n  stride = Core_defaultValue(stride, 3);\n\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n  //>>includeEnd('debug');\n\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positions[0] + center.x;\n  currentPos.y = positions[1] + center.y;\n  currentPos.z = positions[2] + center.z;\n\n  const xMin = Core_Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Core_Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Core_Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Core_Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Core_Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Core_Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numElements = positions.length;\n  let i;\n  for (i = 0; i < numElements; i += stride) {\n    const x = positions[i] + center.x;\n    const y = positions[i + 1] + center.y;\n    const z = positions[i + 2] + center.z;\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Core_Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Core_Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Core_Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Core_Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Core_Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Core_Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  const ySpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  const zSpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Core_Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += stride) {\n    currentPos.x = positions[i] + center.x;\n    currentPos.y = positions[i + 1] + center.y;\n    currentPos.z = positions[i + 2] + center.z;\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Core_Cartesian3.magnitude(\n      Core_Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Core_Cartesian3.magnitudeSquared(\n      Core_Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Core_Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Core_Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromEncodedCartesianVertices = function (\n  positionsHigh,\n  positionsLow,\n  result\n) {\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (\n    !Core_defined(positionsHigh) ||\n    !Core_defined(positionsLow) ||\n    positionsHigh.length !== positionsLow.length ||\n    positionsHigh.length === 0\n  ) {\n    result.center = Core_Cartesian3.clone(Core_Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positionsHigh[0] + positionsLow[0];\n  currentPos.y = positionsHigh[1] + positionsLow[1];\n  currentPos.z = positionsHigh[2] + positionsLow[2];\n\n  const xMin = Core_Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Core_Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Core_Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Core_Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Core_Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Core_Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numElements = positionsHigh.length;\n  let i;\n  for (i = 0; i < numElements; i += 3) {\n    const x = positionsHigh[i] + positionsLow[i];\n    const y = positionsHigh[i + 1] + positionsLow[i + 1];\n    const z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Core_Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Core_Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Core_Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Core_Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Core_Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Core_Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  const ySpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  const zSpan = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Core_Cartesian3.magnitudeSquared(\n    Core_Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Core_Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += 3) {\n    currentPos.x = positionsHigh[i] + positionsLow[i];\n    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Core_Cartesian3.magnitude(\n      Core_Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Core_Cartesian3.magnitudeSquared(\n      Core_Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Core_Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Core_Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n * tightly and fully encompasses the box.\n *\n * @param {Cartesian3} [corner] The minimum height over the rectangle.\n * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * // Create a bounding sphere around the unit cube\n * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n */\nBoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"corner\", corner);\n  Core_Check.typeOf.object(\"oppositeCorner\", oppositeCorner);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = Core_Cartesian3.midpoint(corner, oppositeCorner, result.center);\n  result.radius = Core_Cartesian3.distance(center, oppositeCorner);\n  return result;\n};\n\n/**\n * Creates a bounding sphere encompassing an ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n */\nBoundingSphere.fromEllipsoid = function (ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  Core_Cartesian3.clone(Core_Cartesian3.ZERO, result.center);\n  result.radius = ellipsoid.maximumRadius;\n  return result;\n};\n\nconst fromBoundingSpheresScratch = new Core_Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n *\n * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!Core_defined(boundingSpheres) || boundingSpheres.length === 0) {\n    result.center = Core_Cartesian3.clone(Core_Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const length = boundingSpheres.length;\n  if (length === 1) {\n    return BoundingSphere.clone(boundingSpheres[0], result);\n  }\n\n  if (length === 2) {\n    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n  }\n\n  const positions = [];\n  let i;\n  for (i = 0; i < length; i++) {\n    positions.push(boundingSpheres[i].center);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  const center = result.center;\n  let radius = result.radius;\n  for (i = 0; i < length; i++) {\n    const tmp = boundingSpheres[i];\n    radius = Math.max(\n      radius,\n      Core_Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) +\n        tmp.radius\n    );\n  }\n  result.radius = radius;\n\n  return result;\n};\n\nconst fromOrientedBoundingBoxScratchU = new Core_Cartesian3();\nconst fromOrientedBoundingBoxScratchV = new Core_Cartesian3();\nconst fromOrientedBoundingBoxScratchW = new Core_Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n *\n * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromOrientedBoundingBox = function (\n  orientedBoundingBox,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"orientedBoundingBox\", orientedBoundingBox);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const halfAxes = orientedBoundingBox.halfAxes;\n  const u = Core_Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n  const v = Core_Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n  const w = Core_Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n\n  Core_Cartesian3.add(u, v, u);\n  Core_Cartesian3.add(u, w, u);\n\n  result.center = Core_Cartesian3.clone(orientedBoundingBox.center, result.center);\n  result.radius = Core_Cartesian3.magnitude(u);\n\n  return result;\n};\n\nconst scratchFromTransformationCenter = new Core_Cartesian3();\nconst scratchFromTransformationScale = new Core_Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = Core_Matrix4.getTranslation(\n    transformation,\n    scratchFromTransformationCenter\n  );\n  const scale = Core_Matrix4.getScale(\n    transformation,\n    scratchFromTransformationScale\n  );\n  const radius = 0.5 * Core_Cartesian3.magnitude(scale);\n  result.center = Core_Cartesian3.clone(center, result.center);\n  result.radius = radius;\n\n  return result;\n};\n\n/**\n * Duplicates a BoundingSphere instance.\n *\n * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n */\nBoundingSphere.clone = function (sphere, result) {\n  if (!Core_defined(sphere)) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    return new BoundingSphere(sphere.center, sphere.radius);\n  }\n\n  result.center = Core_Cartesian3.clone(sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nBoundingSphere.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingSphere} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nBoundingSphere.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  const center = value.center;\n  array[startingIndex++] = center.x;\n  array[startingIndex++] = center.y;\n  array[startingIndex++] = center.z;\n  array[startingIndex] = value.radius;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingSphere} [result] The object into which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n */\nBoundingSphere.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = result.center;\n  center.x = array[startingIndex++];\n  center.y = array[startingIndex++];\n  center.z = array[startingIndex++];\n  result.radius = array[startingIndex];\n  return result;\n};\n\nconst unionScratch = new Core_Cartesian3();\nconst unionScratchCenter = new Core_Cartesian3();\n/**\n * Computes a bounding sphere that contains both the left and right bounding spheres.\n *\n * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const leftCenter = left.center;\n  const leftRadius = left.radius;\n  const rightCenter = right.center;\n  const rightRadius = right.radius;\n\n  const toRightCenter = Core_Cartesian3.subtract(\n    rightCenter,\n    leftCenter,\n    unionScratch\n  );\n  const centerSeparation = Core_Cartesian3.magnitude(toRightCenter);\n\n  if (leftRadius >= centerSeparation + rightRadius) {\n    // Left sphere wins.\n    left.clone(result);\n    return result;\n  }\n\n  if (rightRadius >= centerSeparation + leftRadius) {\n    // Right sphere wins.\n    right.clone(result);\n    return result;\n  }\n\n  // There are two tangent points, one on far side of each sphere.\n  const halfDistanceBetweenTangentPoints =\n    (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n  // Compute the center point halfway between the two tangent points.\n  const center = Core_Cartesian3.multiplyByScalar(\n    toRightCenter,\n    (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation,\n    unionScratchCenter\n  );\n  Core_Cartesian3.add(center, leftCenter, center);\n  Core_Cartesian3.clone(center, result.center);\n  result.radius = halfDistanceBetweenTangentPoints;\n\n  return result;\n};\n\nconst expandScratch = new Core_Cartesian3();\n/**\n * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n *\n * @param {BoundingSphere} sphere A sphere to expand.\n * @param {Cartesian3} point A point to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.expand = function (sphere, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  Core_Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingSphere.clone(sphere, result);\n\n  const radius = Core_Cartesian3.magnitude(\n    Core_Cartesian3.subtract(point, result.center, expandScratch)\n  );\n  if (radius > result.radius) {\n    result.radius = radius;\n  }\n\n  return result;\n};\n\n/**\n * Determines which side of a plane a sphere is located.\n *\n * @param {BoundingSphere} sphere The bounding sphere to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.intersectPlane = function (sphere, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  Core_Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  const center = sphere.center;\n  const radius = sphere.radius;\n  const normal = plane.normal;\n  const distanceToPlane = Core_Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane < -radius) {\n    // The center point is negative side of the plane normal\n    return Core_Intersect.OUTSIDE;\n  } else if (distanceToPlane < radius) {\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    return Core_Intersect.INTERSECTING;\n  }\n  return Core_Intersect.INSIDE;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.transform = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  Core_Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Core_Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center\n  );\n  result.radius = Core_Matrix4.getMaximumScale(transform) * sphere.radius;\n\n  return result;\n};\n\nconst distanceSquaredToScratch = new Core_Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {BoundingSphere} sphere The sphere.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The distance squared from the bounding sphere to the point. Returns 0 if the point is inside the sphere.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nBoundingSphere.distanceSquaredTo = function (sphere, cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const diff = Core_Cartesian3.subtract(\n    sphere.center,\n    cartesian,\n    distanceSquaredToScratch\n  );\n\n  const distance = Core_Cartesian3.magnitude(diff) - sphere.radius;\n  if (distance <= 0.0) {\n    return 0.0;\n  }\n\n  return distance * distance;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n * The transformation matrix is not verified to have a uniform scale of 1.\n * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * const boundingSphere = new Cesium.BoundingSphere();\n * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n */\nBoundingSphere.transformWithoutScale = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  Core_Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Core_Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center\n  );\n  result.radius = sphere.radius;\n\n  return result;\n};\n\nconst scratchCartesian3 = new Core_Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.computePlaneDistances = function (\n  sphere,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  Core_Check.typeOf.object(\"position\", position);\n  Core_Check.typeOf.object(\"direction\", direction);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Interval();\n  }\n\n  const toCenter = Core_Cartesian3.subtract(\n    sphere.center,\n    position,\n    scratchCartesian3\n  );\n  const mag = Core_Cartesian3.dot(direction, toCenter);\n\n  result.start = mag - sphere.radius;\n  result.stop = mag + sphere.radius;\n  return result;\n};\n\nconst projectTo2DNormalScratch = new Core_Cartesian3();\nconst projectTo2DEastScratch = new Core_Cartesian3();\nconst projectTo2DNorthScratch = new Core_Cartesian3();\nconst projectTo2DWestScratch = new Core_Cartesian3();\nconst projectTo2DSouthScratch = new Core_Cartesian3();\nconst projectTo2DCartographicScratch = new Core_Cartographic();\nconst projectTo2DPositionsScratch = new Array(8);\nfor (let n = 0; n < 8; ++n) {\n  projectTo2DPositionsScratch[n] = new Core_Cartesian3();\n}\n\nconst projectTo2DProjection = new Core_GeographicProjection();\n/**\n * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n *\n * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n * @param {Object} [projection=GeographicProjection] The projection to 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.projectTo2D = function (sphere, projection, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  //>>includeEnd('debug');\n\n  projection = Core_defaultValue(projection, projectTo2DProjection);\n\n  const ellipsoid = projection.ellipsoid;\n  let center = sphere.center;\n  const radius = sphere.radius;\n\n  let normal;\n  if (Core_Cartesian3.equals(center, Core_Cartesian3.ZERO)) {\n    // Bounding sphere is at the center. The geodetic surface normal is not\n    // defined here so pick the x-axis as a fallback.\n    normal = Core_Cartesian3.clone(Core_Cartesian3.UNIT_X, projectTo2DNormalScratch);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n  }\n  const east = Core_Cartesian3.cross(\n    Core_Cartesian3.UNIT_Z,\n    normal,\n    projectTo2DEastScratch\n  );\n  Core_Cartesian3.normalize(east, east);\n  const north = Core_Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n  Core_Cartesian3.normalize(north, north);\n\n  Core_Cartesian3.multiplyByScalar(normal, radius, normal);\n  Core_Cartesian3.multiplyByScalar(north, radius, north);\n  Core_Cartesian3.multiplyByScalar(east, radius, east);\n\n  const south = Core_Cartesian3.negate(north, projectTo2DSouthScratch);\n  const west = Core_Cartesian3.negate(east, projectTo2DWestScratch);\n\n  const positions = projectTo2DPositionsScratch;\n\n  // top NE corner\n  let corner = positions[0];\n  Core_Cartesian3.add(normal, north, corner);\n  Core_Cartesian3.add(corner, east, corner);\n\n  // top NW corner\n  corner = positions[1];\n  Core_Cartesian3.add(normal, north, corner);\n  Core_Cartesian3.add(corner, west, corner);\n\n  // top SW corner\n  corner = positions[2];\n  Core_Cartesian3.add(normal, south, corner);\n  Core_Cartesian3.add(corner, west, corner);\n\n  // top SE corner\n  corner = positions[3];\n  Core_Cartesian3.add(normal, south, corner);\n  Core_Cartesian3.add(corner, east, corner);\n\n  Core_Cartesian3.negate(normal, normal);\n\n  // bottom NE corner\n  corner = positions[4];\n  Core_Cartesian3.add(normal, north, corner);\n  Core_Cartesian3.add(corner, east, corner);\n\n  // bottom NW corner\n  corner = positions[5];\n  Core_Cartesian3.add(normal, north, corner);\n  Core_Cartesian3.add(corner, west, corner);\n\n  // bottom SW corner\n  corner = positions[6];\n  Core_Cartesian3.add(normal, south, corner);\n  Core_Cartesian3.add(corner, west, corner);\n\n  // bottom SE corner\n  corner = positions[7];\n  Core_Cartesian3.add(normal, south, corner);\n  Core_Cartesian3.add(corner, east, corner);\n\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const position = positions[i];\n    Core_Cartesian3.add(center, position, position);\n    const cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      projectTo2DCartographicScratch\n    );\n    projection.project(cartographic, position);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  // swizzle center components\n  center = result.center;\n  const x = center.x;\n  const y = center.y;\n  const z = center.z;\n  center.x = z;\n  center.y = x;\n  center.z = y;\n\n  return result;\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.isOccluded = function (sphere, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"sphere\", sphere);\n  Core_Check.typeOf.object(\"occluder\", occluder);\n  //>>includeEnd('debug');\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Compares the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [left] The first BoundingSphere.\n * @param {BoundingSphere} [right] The second BoundingSphere.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingSphere.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Core_Cartesian3.equals(left.center, right.center) &&\n      left.radius === right.radius)\n  );\n};\n\n/**\n * Determines which side of a plane the sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.prototype.intersectPlane = function (plane) {\n  return BoundingSphere.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nBoundingSphere.prototype.distanceSquaredTo = function (cartesian) {\n  return BoundingSphere.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return BoundingSphere.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.prototype.isOccluded = function (occluder) {\n  return BoundingSphere.isOccluded(this, occluder);\n};\n\n/**\n * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingSphere.prototype.equals = function (right) {\n  return BoundingSphere.equals(this, right);\n};\n\n/**\n * Duplicates this BoundingSphere instance.\n *\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.prototype.clone = function (result) {\n  return BoundingSphere.clone(this, result);\n};\n\n/**\n * Computes the radius of the BoundingSphere.\n * @returns {Number} The radius of the BoundingSphere.\n */\nBoundingSphere.prototype.volume = function () {\n  const radius = this.radius;\n  return volumeConstant * radius * radius * radius;\n};\n/* harmony default export */ const Core_BoundingSphere = (BoundingSphere);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/HeadingPitchRange.js\n\n\n\n/**\n * Defines a heading angle, pitch angle, and range in a local frame.\n * Heading is the rotation from the local north direction where a positive angle is increasing eastward.\n * Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch\n * angles are below the plane. Range is the distance from the center of the frame.\n * @alias HeadingPitchRange\n * @constructor\n *\n * @param {Number} [heading=0.0] The heading angle in radians.\n * @param {Number} [pitch=0.0] The pitch angle in radians.\n * @param {Number} [range=0.0] The distance from the center in meters.\n */\nfunction HeadingPitchRange(heading, pitch, range) {\n  /**\n   * Heading is the rotation from the local north direction where a positive angle is increasing eastward.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.heading = Core_defaultValue(heading, 0.0);\n\n  /**\n   * Pitch is the rotation from the local xy-plane. Positive pitch angles\n   * are above the plane. Negative pitch angles are below the plane.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.pitch = Core_defaultValue(pitch, 0.0);\n\n  /**\n   * Range is the distance from the center of the local frame.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.range = Core_defaultValue(range, 0.0);\n}\n\n/**\n * Duplicates a HeadingPitchRange instance.\n *\n * @param {HeadingPitchRange} hpr The HeadingPitchRange to duplicate.\n * @param {HeadingPitchRange} [result] The object onto which to store the result.\n * @returns {HeadingPitchRange} The modified result parameter or a new HeadingPitchRange instance if one was not provided. (Returns undefined if hpr is undefined)\n */\nHeadingPitchRange.clone = function (hpr, result) {\n  if (!Core_defined(hpr)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    result = new HeadingPitchRange();\n  }\n\n  result.heading = hpr.heading;\n  result.pitch = hpr.pitch;\n  result.range = hpr.range;\n  return result;\n};\n/* harmony default export */ const Core_HeadingPitchRange = (HeadingPitchRange);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/binarySearch.js\n\n\n/**\n * Finds an item in a sorted array.\n *\n * @function\n * @param {Array} array The sorted array to search.\n * @param {*} itemToFind The item to find in the array.\n * @param {binarySearchComparator} comparator The function to use to compare the item to\n *        elements in the array.\n * @returns {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>\n *        does not exist, the return value is a negative number which is the bitwise complement (~)\n *        of the index before which the itemToFind should be inserted in order to maintain the\n *        sorted order of the array.\n *\n * @example\n * // Create a comparator function to search through an array of numbers.\n * function comparator(a, b) {\n *     return a - b;\n * };\n * const numbers = [0, 2, 4, 6, 8];\n * const index = Cesium.binarySearch(numbers, 6, comparator); // 3\n */\nfunction binarySearch(array, itemToFind, comparator) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  Core_Check.defined(\"itemToFind\", itemToFind);\n  Core_Check.defined(\"comparator\", comparator);\n  //>>includeEnd('debug');\n\n  let low = 0;\n  let high = array.length - 1;\n  let i;\n  let comparison;\n\n  while (low <= high) {\n    i = ~~((low + high) / 2);\n    comparison = comparator(array[i], itemToFind);\n    if (comparison < 0) {\n      low = i + 1;\n      continue;\n    }\n    if (comparison > 0) {\n      high = i - 1;\n      continue;\n    }\n    return i;\n  }\n  return ~(high + 1);\n}\n\n/**\n * A function used to compare two items while performing a binary search.\n * @callback binarySearchComparator\n *\n * @param {*} a An item in the array.\n * @param {*} b The item being searched for.\n * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\n *          0 if <code>a</code> is equal to <code>b</code>.\n *\n * @example\n * function compareNumbers(a, b) {\n *     return a - b;\n * }\n */\n/* harmony default export */ const Core_binarySearch = (binarySearch);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/EarthOrientationParametersSample.js\n/**\n * A set of Earth Orientation Parameters (EOP) sampled at a time.\n *\n * @alias EarthOrientationParametersSample\n * @constructor\n *\n * @param {Number} xPoleWander The pole wander about the X axis, in radians.\n * @param {Number} yPoleWander The pole wander about the Y axis, in radians.\n * @param {Number} xPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n * @param {Number} yPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n * @param {Number} ut1MinusUtc The difference in time standards, UT1 - UTC, in seconds.\n *\n * @private\n */\nfunction EarthOrientationParametersSample(\n  xPoleWander,\n  yPoleWander,\n  xPoleOffset,\n  yPoleOffset,\n  ut1MinusUtc\n) {\n  /**\n   * The pole wander about the X axis, in radians.\n   * @type {Number}\n   */\n  this.xPoleWander = xPoleWander;\n\n  /**\n   * The pole wander about the Y axis, in radians.\n   * @type {Number}\n   */\n  this.yPoleWander = yPoleWander;\n\n  /**\n   * The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n   * @type {Number}\n   */\n  this.xPoleOffset = xPoleOffset;\n\n  /**\n   * The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n   * @type {Number}\n   */\n  this.yPoleOffset = yPoleOffset;\n\n  /**\n   * The difference in time standards, UT1 - UTC, in seconds.\n   * @type {Number}\n   */\n  this.ut1MinusUtc = ut1MinusUtc;\n}\n/* harmony default export */ const Core_EarthOrientationParametersSample = (EarthOrientationParametersSample);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/GregorianDate.js\n/**\n * Represents a Gregorian date in a more precise format than the JavaScript Date object.\n * In addition to submillisecond precision, this object can also represent leap seconds.\n * @alias GregorianDate\n * @constructor\n *\n * @param {Number} [year] The year as a whole number.\n * @param {Number} [month] The month as a whole number with range [1, 12].\n * @param {Number} [day] The day of the month as a whole number starting at 1.\n * @param {Number} [hour] The hour as a whole number with range [0, 23].\n * @param {Number} [minute] The minute of the hour as a whole number with range [0, 59].\n * @param {Number} [second] The second of the minute as a whole number with range [0, 60], with 60 representing a leap second.\n * @param {Number} [millisecond] The millisecond of the second as a floating point number with range [0.0, 1000.0).\n * @param {Boolean} [isLeapSecond] Whether this time is during a leap second.\n *\n * @see JulianDate#toGregorianDate\n */\nfunction GregorianDate(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond,\n  isLeapSecond\n) {\n  /**\n   * Gets or sets the year as a whole number.\n   * @type {Number}\n   */\n  this.year = year;\n  /**\n   * Gets or sets the month as a whole number with range [1, 12].\n   * @type {Number}\n   */\n  this.month = month;\n  /**\n   * Gets or sets the day of the month as a whole number starting at 1.\n   * @type {Number}\n   */\n  this.day = day;\n  /**\n   * Gets or sets the hour as a whole number with range [0, 23].\n   * @type {Number}\n   */\n  this.hour = hour;\n  /**\n   * Gets or sets the minute of the hour as a whole number with range [0, 59].\n   * @type {Number}\n   */\n  this.minute = minute;\n  /**\n   * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.\n   * @type {Number}\n   */\n  this.second = second;\n  /**\n   * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).\n   * @type {Number}\n   */\n  this.millisecond = millisecond;\n  /**\n   * Gets or sets whether this time is during a leap second.\n   * @type {Boolean}\n   */\n  this.isLeapSecond = isLeapSecond;\n}\n/* harmony default export */ const Core_GregorianDate = (GregorianDate);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/isLeapYear.js\n\n\n/**\n * Determines if a given date is a leap year.\n *\n * @function isLeapYear\n *\n * @param {Number} year The year to be tested.\n * @returns {Boolean} True if <code>year</code> is a leap year.\n *\n * @example\n * const leapYear = Cesium.isLeapYear(2000); // true\n */\nfunction isLeapYear(year) {\n  //>>includeStart('debug', pragmas.debug);\n  if (year === null || isNaN(year)) {\n    throw new Core_DeveloperError(\"year is required and must be a number.\");\n  }\n  //>>includeEnd('debug');\n\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}\n/* harmony default export */ const Core_isLeapYear = (isLeapYear);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/LeapSecond.js\n/**\n * Describes a single leap second, which is constructed from a {@link JulianDate} and a\n * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.\n * @alias LeapSecond\n * @constructor\n *\n * @param {JulianDate} [date] A Julian date representing the time of the leap second.\n * @param {Number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.\n */\nfunction LeapSecond(date, offset) {\n  /**\n   * Gets or sets the date at which this leap second occurs.\n   * @type {JulianDate}\n   */\n  this.julianDate = date;\n\n  /**\n   * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time\n   * of this leap second.\n   * @type {Number}\n   */\n  this.offset = offset;\n}\n/* harmony default export */ const Core_LeapSecond = (LeapSecond);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/TimeConstants.js\n/**\n * Constants for time conversions like those done by {@link JulianDate}.\n *\n * @namespace TimeConstants\n *\n * @see JulianDate\n *\n * @private\n */\nconst TimeConstants = {\n  /**\n   * The number of seconds in one millisecond: <code>0.001</code>\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_MILLISECOND: 0.001,\n\n  /**\n   * The number of seconds in one minute: <code>60</code>.\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_MINUTE: 60.0,\n\n  /**\n   * The number of minutes in one hour: <code>60</code>.\n   * @type {Number}\n   * @constant\n   */\n  MINUTES_PER_HOUR: 60.0,\n\n  /**\n   * The number of hours in one day: <code>24</code>.\n   * @type {Number}\n   * @constant\n   */\n  HOURS_PER_DAY: 24.0,\n\n  /**\n   * The number of seconds in one hour: <code>3600</code>.\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_HOUR: 3600.0,\n\n  /**\n   * The number of minutes in one day: <code>1440</code>.\n   * @type {Number}\n   * @constant\n   */\n  MINUTES_PER_DAY: 1440.0,\n\n  /**\n   * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_DAY: 86400.0,\n\n  /**\n   * The number of days in one Julian century: <code>36525</code>.\n   * @type {Number}\n   * @constant\n   */\n  DAYS_PER_JULIAN_CENTURY: 36525.0,\n\n  /**\n   * One trillionth of a second.\n   * @type {Number}\n   * @constant\n   */\n  PICOSECOND: 0.000000001,\n\n  /**\n   * The number of days to subtract from a Julian date to determine the\n   * modified Julian date, which gives the number of days since midnight\n   * on November 17, 1858.\n   * @type {Number}\n   * @constant\n   */\n  MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5,\n};\n/* harmony default export */ const Core_TimeConstants = (Object.freeze(TimeConstants));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/TimeStandard.js\n/**\n * Provides the type of time standards which JulianDate can take as input.\n *\n * @enum {Number}\n *\n * @see JulianDate\n */\nconst TimeStandard = {\n  /**\n   * Represents the coordinated Universal Time (UTC) time standard.\n   *\n   * UTC is related to TAI according to the relationship\n   * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap\n   * seconds which have been introduced as of the time in TAI.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UTC: 0,\n\n  /**\n   * Represents the International Atomic Time (TAI) time standard.\n   * TAI is the principal time standard to which the other time standards are related.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TAI: 1,\n};\n/* harmony default export */ const Core_TimeStandard = (Object.freeze(TimeStandard));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/JulianDate.js\n\n\n\n\n\n\n\n\n\n\nconst gregorianDateScratch = new Core_GregorianDate();\nconst daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInLeapFeburary = 29;\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n}\n\n// we don't really need a leap second instance, anything with a julianDate property will do\nconst binarySearchScratchLeapSecond = new Core_LeapSecond();\n\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we'll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = Core_binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n\n  if (index < 0) {\n    index = ~index;\n  }\n\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n\n  let offset = leapSeconds[index].offset;\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    const difference = JulianDate.secondsDifference(\n      leapSeconds[index].julianDate,\n      julianDate\n    );\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\n\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = Core_binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n  }\n\n  //All times before our first leap second get the first offset.\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  }\n\n  //All times after our leap second get the last offset.\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index - 1].offset,\n      result\n    );\n  }\n\n  //Compute the difference between the found leap second and the time we are converting.\n  const difference = JulianDate.secondsDifference(\n    leapSeconds[index].julianDate,\n    julianDate\n  );\n\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index].offset,\n      result\n    );\n  }\n\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  }\n\n  //The time is in between two leap seconds, index is the leap second after the date\n  //we're converting, so we subtract one to get the correct LeapSecond instance.\n  return JulianDate.addSeconds(\n    julianDate,\n    -leapSeconds[--index].offset,\n    result\n  );\n}\n\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  const extraDays = (secondsOfDay / Core_TimeConstants.SECONDS_PER_DAY) | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= Core_TimeConstants.SECONDS_PER_DAY * extraDays;\n\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += Core_TimeConstants.SECONDS_PER_DAY;\n  }\n\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\n\nfunction computeJulianDateComponents(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond\n) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n  const a = ((month - 14) / 12) | 0;\n  const b = year + 4800 + a;\n  let dayNumber =\n    (((1461 * b) / 4) | 0) +\n    (((367 * (month - 2 - 12 * a)) / 12) | 0) -\n    (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +\n    day -\n    32075;\n\n  // JulianDates are noon-based\n  hour = hour - 12;\n  if (hour < 0) {\n    hour += 24;\n  }\n\n  const secondsOfDay =\n    second +\n    (hour * Core_TimeConstants.SECONDS_PER_HOUR +\n      minute * Core_TimeConstants.SECONDS_PER_MINUTE +\n      millisecond * Core_TimeConstants.SECONDS_PER_MILLISECOND);\n\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n\n  return [dayNumber, secondsOfDay];\n}\n\n//Regular expressions used for ISO8601 date parsing.\n//YYYY\nconst matchCalendarYear = /^(\\d{4})$/;\n//YYYY-MM (YYYYMM is invalid)\nconst matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n//YYYY-DDD or YYYYDDD\nconst matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\nconst matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n//YYYY-MM-DD or YYYYMMDD\nconst matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n// Match utc offset\nconst utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n// Match hours HH or HH.xxxxx\nconst matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM HHMM.xxxxx\nconst matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM:SS HHMMSS.xxxxx\nconst matchHoursMinutesSeconds =\n  /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n\nconst iso8601ErrorMessage = \"Invalid ISO 8601 date.\";\n\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {Number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {Number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {Number}\n   */\n  this.dayNumber = undefined;\n\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {Number}\n   */\n  this.secondsOfDay = undefined;\n\n  julianDayNumber = Core_defaultValue(julianDayNumber, 0.0);\n  secondsOfDay = Core_defaultValue(secondsOfDay, 0.0);\n  timeStandard = Core_defaultValue(timeStandard, Core_TimeStandard.UTC);\n\n  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n  const wholeDays = julianDayNumber | 0;\n  secondsOfDay =\n    secondsOfDay +\n    (julianDayNumber - wholeDays) * Core_TimeConstants.SECONDS_PER_DAY;\n\n  setComponents(wholeDays, secondsOfDay, this);\n\n  if (timeStandard === Core_TimeStandard.UTC) {\n    convertUtcToTai(this);\n  }\n}\n\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Core_GregorianDate)) {\n    throw new Core_DeveloperError(\"date must be a valid GregorianDate.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.year,\n    date.month,\n    date.day,\n    date.hour,\n    date.minute,\n    date.second,\n    date.millisecond\n  );\n  if (!Core_defined(result)) {\n    return new JulianDate(components[0], components[1], Core_TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new Core_DeveloperError(\"date must be a valid JavaScript Date.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.getUTCFullYear(),\n    date.getUTCMonth() + 1,\n    date.getUTCDate(),\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds(),\n    date.getUTCMilliseconds()\n  );\n  if (!Core_defined(result)) {\n    return new JulianDate(components[0], components[1], Core_TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {String} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof iso8601String !== \"string\") {\n    throw new Core_DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n  iso8601String = iso8601String.replace(\",\", \".\");\n\n  //Split the string into its date and time components, denoted by a mandatory T\n  let tokens = iso8601String.split(\"T\");\n  let year;\n  let month = 1;\n  let day = 1;\n  let hour = 0;\n  let minute = 0;\n  let second = 0;\n  let millisecond = 0;\n\n  //Lacking a time is okay, but a missing date is illegal.\n  const date = tokens[0];\n  const time = tokens[1];\n  let tmp;\n  let inLeapYear;\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(date)) {\n    throw new Core_DeveloperError(iso8601ErrorMessage);\n  }\n\n  let dashCount;\n  //>>includeEnd('debug');\n\n  //First match the date against possible regular expressions.\n  tokens = date.match(matchCalendarDate);\n  if (tokens !== null) {\n    //>>includeStart('debug', pragmas.debug);\n    dashCount = date.split(\"-\").length - 1;\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new Core_DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        let dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = Core_isLeapYear(year);\n\n          //This validation is only applicable for this format.\n          //>>includeStart('debug', pragmas.debug);\n          if (\n            dayOfYear < 1 ||\n            (inLeapYear && dayOfYear > 366) ||\n            (!inLeapYear && dayOfYear > 365)\n          ) {\n            throw new Core_DeveloperError(iso8601ErrorMessage);\n          }\n          //>>includeEnd('debug')\n        } else {\n          tokens = date.match(matchWeekDate);\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            const weekNumber = +tokens[2];\n            const dayOfWeek = +tokens[3] || 0;\n\n            //>>includeStart('debug', pragmas.debug);\n            dashCount = date.split(\"-\").length - 1;\n            if (\n              dashCount > 0 &&\n              ((!Core_defined(tokens[3]) && dashCount !== 1) ||\n                (Core_defined(tokens[3]) && dashCount !== 2))\n            ) {\n              throw new Core_DeveloperError(iso8601ErrorMessage);\n            }\n            //>>includeEnd('debug')\n\n            const january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart('debug', pragmas.debug);\n            throw new Core_DeveloperError(iso8601ErrorMessage);\n            //>>includeEnd('debug')\n          }\n        }\n        //Split an ordinal date into month/day.\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  }\n\n  //Now that we have all of the date components, validate them to make sure nothing is out of range.\n  inLeapYear = Core_isLeapYear(year);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    month < 1 ||\n    month > 12 ||\n    day < 1 ||\n    ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) ||\n    (inLeapYear && month === 2 && day > daysInLeapFeburary)\n  ) {\n    throw new Core_DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug')\n\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.\n  let offsetIndex;\n  if (Core_defined(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n    if (tokens !== null) {\n      //>>includeStart('debug', pragmas.debug);\n      dashCount = time.split(\":\").length - 1;\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new Core_DeveloperError(iso8601ErrorMessage);\n      }\n      //>>includeEnd('debug')\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n      if (tokens !== null) {\n        //>>includeStart('debug', pragmas.debug);\n        dashCount = time.split(\":\").length - 1;\n        if (dashCount > 2) {\n          throw new Core_DeveloperError(iso8601ErrorMessage);\n        }\n        //>>includeEnd('debug')\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart('debug', pragmas.debug);\n          throw new Core_DeveloperError(iso8601ErrorMessage);\n          //>>includeEnd('debug')\n        }\n      }\n    }\n\n    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      minute >= 60 ||\n      second >= 61 ||\n      hour > 24 ||\n      (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))\n    ) {\n      throw new Core_DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n    const offset = tokens[offsetIndex];\n    const offsetHours = +tokens[offsetIndex + 1];\n    const offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n    switch (offset) {\n      case \"+\":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n      case \"-\":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n      case \"Z\":\n        break;\n      default:\n        minute =\n          minute +\n          new Date(\n            Date.UTC(year, month - 1, day, hour, minute)\n          ).getTimezoneOffset();\n        break;\n    }\n  }\n\n  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n  const isLeapSecond = second === 60;\n  if (isLeapSecond) {\n    second--;\n  }\n\n  //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n\n  tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  }\n\n  //If UTC offset is at the beginning/end of the day, minutes can be negative.\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n\n  while (day < 1) {\n    month--;\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n    day += tmp;\n  }\n\n  //Now create the JulianDate components from the Gregorian date and actually create our instance.\n  const components = computeJulianDateComponents(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond\n  );\n\n  if (!Core_defined(result)) {\n    result = new JulianDate(components[0], components[1], Core_TimeStandard.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\n\nconst toGregorianDateScratch = new JulianDate(0, 0, Core_TimeStandard.TAI);\n\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let isLeapSecond = false;\n  let thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n  if (!Core_defined(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that's the case, subtract a second and convert again.\n    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n\n  let julianDayNumber = thisUtc.dayNumber;\n  const secondsOfDay = thisUtc.secondsOfDay;\n\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  }\n\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  let L = (julianDayNumber + 68569) | 0;\n  const N = ((4 * L) / 146097) | 0;\n  L = (L - (((146097 * N + 3) / 4) | 0)) | 0;\n  const I = ((4000 * (L + 1)) / 1461001) | 0;\n  L = (L - (((1461 * I) / 4) | 0) + 31) | 0;\n  const J = ((80 * L) / 2447) | 0;\n  const day = (L - (((2447 * J) / 80) | 0)) | 0;\n  L = (J / 11) | 0;\n  const month = (J + 2 - 12 * L) | 0;\n  const year = (100 * (N - 49) + I + L) | 0;\n\n  let hour = (secondsOfDay / Core_TimeConstants.SECONDS_PER_HOUR) | 0;\n  let remainingSeconds = secondsOfDay - hour * Core_TimeConstants.SECONDS_PER_HOUR;\n  const minute = (remainingSeconds / Core_TimeConstants.SECONDS_PER_MINUTE) | 0;\n  remainingSeconds =\n    remainingSeconds - minute * Core_TimeConstants.SECONDS_PER_MINUTE;\n  let second = remainingSeconds | 0;\n  const millisecond =\n    (remainingSeconds - second) / Core_TimeConstants.SECONDS_PER_MILLISECOND;\n\n  // JulianDates are noon-based\n  hour += 12;\n  if (hour > 23) {\n    hour -= 24;\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    second += 1;\n  }\n\n  if (!Core_defined(result)) {\n    return new Core_GregorianDate(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      isLeapSecond\n    );\n  }\n\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let second = gDate.second;\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n  return new Date(\n    Date.UTC(\n      gDate.year,\n      gDate.month - 1,\n      gDate.day,\n      gDate.hour,\n      gDate.minute,\n      second,\n      gDate.millisecond\n    )\n  );\n};\n\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided date.\n */\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let year = gDate.year;\n  let month = gDate.month;\n  let day = gDate.day;\n  let hour = gDate.hour;\n  const minute = gDate.minute;\n  const second = gDate.second;\n  const millisecond = gDate.millisecond;\n\n  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n  if (\n    year === 10000 &&\n    month === 1 &&\n    day === 1 &&\n    hour === 0 &&\n    minute === 0 &&\n    second === 0 &&\n    millisecond === 0\n  ) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n\n  let millisecondStr;\n\n  if (!Core_defined(precision) && millisecond !== 0) {\n    //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.\n    millisecondStr = (millisecond * 0.01).toString().replace(\".\", \"\");\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day\n      .toString()\n      .padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute\n      .toString()\n      .padStart(2, \"0\")}:${second\n      .toString()\n      .padStart(2, \"0\")}.${millisecondStr}Z`;\n  }\n\n  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n  if (!Core_defined(precision) || precision === 0) {\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day\n      .toString()\n      .padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute\n      .toString()\n      .padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}Z`;\n  }\n\n  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n  millisecondStr = (millisecond * 0.01)\n    .toFixed(precision)\n    .replace(\".\", \"\")\n    .slice(0, precision);\n  return `${year.toString().padStart(4, \"0\")}-${month\n    .toString()\n    .padStart(2, \"0\")}-${day\n    .toString()\n    .padStart(2, \"0\")}T${hour\n    .toString()\n    .padStart(2, \"0\")}:${minute\n    .toString()\n    .padStart(2, \"0\")}:${second\n    .toString()\n    .padStart(2, \"0\")}.${millisecondStr}Z`;\n};\n\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\nJulianDate.clone = function (julianDate, result) {\n  if (!Core_defined(julianDate)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new JulianDate(\n      julianDate.dayNumber,\n      julianDate.secondsOfDay,\n      Core_TimeStandard.TAI\n    );\n  }\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\nJulianDate.compare = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"left is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const julianDayNumberDifference = left.dayNumber - right.dayNumber;\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n  return left.secondsOfDay - right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.dayNumber === right.dayNumber &&\n      left.secondsOfDay === right.secondsOfDay)\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {Number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = Core_defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon)\n  );\n};\n\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The Julian date as single floating point number.\n */\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n  return (\n    julianDate.dayNumber +\n    julianDate.secondsOfDay / Core_TimeConstants.SECONDS_PER_DAY\n  );\n};\n\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"left is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference =\n    (left.dayNumber - right.dayNumber) * Core_TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(left)) {\n    throw new Core_DeveloperError(\"left is required.\");\n  }\n  if (!Core_defined(right)) {\n    throw new Core_DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference = left.dayNumber - right.dayNumber;\n  const secondDifference =\n    (left.secondsOfDay - right.secondsOfDay) / Core_TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The number of seconds the provided instance is ahead of UTC\n */\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = Core_binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n    --index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n  return leapSeconds[index].offset;\n};\n\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  if (!Core_defined(seconds)) {\n    throw new Core_DeveloperError(\"seconds is required.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return setComponents(\n    julianDate.dayNumber,\n    julianDate.secondsOfDay + seconds,\n    result\n  );\n};\n\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  if (!Core_defined(minutes)) {\n    throw new Core_DeveloperError(\"minutes is required.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + minutes * Core_TimeConstants.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  if (!Core_defined(hours)) {\n    throw new Core_DeveloperError(\"hours is required.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + hours * Core_TimeConstants.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(julianDate)) {\n    throw new Core_DeveloperError(\"julianDate is required.\");\n  }\n  if (!Core_defined(days)) {\n    throw new Core_DeveloperError(\"days is required.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {Number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {String} A string representing this date in ISO8601 format.\n */\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\nJulianDate.leapSeconds = [\n  new Core_LeapSecond(new JulianDate(2441317, 43210.0, Core_TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2441499, 43211.0, Core_TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2441683, 43212.0, Core_TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2442048, 43213.0, Core_TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2442413, 43214.0, Core_TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2442778, 43215.0, Core_TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2443144, 43216.0, Core_TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2443509, 43217.0, Core_TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2443874, 43218.0, Core_TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2444239, 43219.0, Core_TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2444786, 43220.0, Core_TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2445151, 43221.0, Core_TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2445516, 43222.0, Core_TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2446247, 43223.0, Core_TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2447161, 43224.0, Core_TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2447892, 43225.0, Core_TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2448257, 43226.0, Core_TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2448804, 43227.0, Core_TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2449169, 43228.0, Core_TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2449534, 43229.0, Core_TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2450083, 43230.0, Core_TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2450630, 43231.0, Core_TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2451179, 43232.0, Core_TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2453736, 43233.0, Core_TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2454832, 43234.0, Core_TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2456109, 43235.0, Core_TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2457204, 43236.0, Core_TimeStandard.TAI), 36), // July 1, 2015 00:00:00 UTC\n  new Core_LeapSecond(new JulianDate(2457754, 43237.0, Core_TimeStandard.TAI), 37), // January 1, 2017 00:00:00 UTC\n];\n/* harmony default export */ const Core_JulianDate = (JulianDate);\n\n// EXTERNAL MODULE: ./node_modules/urijs/src/URI.js\nvar URI = __webpack_require__(\"./node_modules/urijs/src/URI.js\");\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/appendForwardSlash.js\n/**\n * @private\n */\nfunction appendForwardSlash(url) {\n  if (url.length === 0 || url[url.length - 1] !== \"/\") {\n    url = `${url}/`;\n  }\n  return url;\n}\n/* harmony default export */ const Core_appendForwardSlash = (appendForwardSlash);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/clone.js\n\n\n/**\n * Clones an object, returning a new object containing the same properties.\n *\n * @function\n *\n * @param {Object} object The object to clone.\n * @param {Boolean} [deep=false] If true, all properties will be deep cloned recursively.\n * @returns {Object} The cloned object.\n */\nfunction clone(object, deep) {\n  if (object === null || typeof object !== \"object\") {\n    return object;\n  }\n\n  deep = Core_defaultValue(deep, false);\n\n  const result = new object.constructor();\n  for (const propertyName in object) {\n    if (object.hasOwnProperty(propertyName)) {\n      let value = object[propertyName];\n      if (deep) {\n        value = clone(value, deep);\n      }\n      result[propertyName] = value;\n    }\n  }\n\n  return result;\n}\n/* harmony default export */ const Core_clone = (clone);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/combine.js\n\n\n\n/**\n * Merges two objects, copying their properties onto a new combined object. When two objects have the same\n * property, the value of the property on the first object is used.  If either object is undefined,\n * it will be treated as an empty object.\n *\n * @example\n * const object1 = {\n *     propOne : 1,\n *     propTwo : {\n *         value1 : 10\n *     }\n * }\n * const object2 = {\n *     propTwo : 2\n * }\n * const final = Cesium.combine(object1, object2);\n *\n * // final === {\n * //     propOne : 1,\n * //     propTwo : {\n * //         value1 : 10\n * //     }\n * // }\n *\n * @param {Object} [object1] The first object to merge.\n * @param {Object} [object2] The second object to merge.\n * @param {Boolean} [deep=false] Perform a recursive merge.\n * @returns {Object} The combined object containing all properties from both objects.\n *\n * @function\n */\nfunction combine(object1, object2, deep) {\n  deep = Core_defaultValue(deep, false);\n\n  const result = {};\n\n  const object1Defined = Core_defined(object1);\n  const object2Defined = Core_defined(object2);\n  let property;\n  let object1Value;\n  let object2Value;\n  if (object1Defined) {\n    for (property in object1) {\n      if (object1.hasOwnProperty(property)) {\n        object1Value = object1[property];\n        if (\n          object2Defined &&\n          deep &&\n          typeof object1Value === \"object\" &&\n          object2.hasOwnProperty(property)\n        ) {\n          object2Value = object2[property];\n          if (typeof object2Value === \"object\") {\n            result[property] = combine(object1Value, object2Value, deep);\n          } else {\n            result[property] = object1Value;\n          }\n        } else {\n          result[property] = object1Value;\n        }\n      }\n    }\n  }\n  if (object2Defined) {\n    for (property in object2) {\n      if (\n        object2.hasOwnProperty(property) &&\n        !result.hasOwnProperty(property)\n      ) {\n        object2Value = object2[property];\n        result[property] = object2Value;\n      }\n    }\n  }\n  return result;\n}\n/* harmony default export */ const Core_combine = (combine);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/defer.js\n/**\n * A function used to resolve a promise upon completion .\n * @callback defer.resolve\n *\n * @param {*} value The resulting value.\n */\n\n/**\n * A function used to reject a promise upon failure.\n * @callback defer.reject\n *\n * @param {*} error The error.\n */\n\n/**\n * An object which contains a promise object, and functions to resolve or reject the promise.\n *\n * @typedef {Object} defer.deferred\n * @property {defer.resolve} resolve Resolves the promise when called.\n * @property {defer.reject} reject Rejects the promise when called.\n * @property {Promise} promise Promise object.\n */\n\n/**\n * Creates a deferred object, containing a promise object, and functions to resolve or reject the promise.\n * @returns {defer.deferred}\n * @private\n */\nfunction defer() {\n  let resolve;\n  let reject;\n  const promise = new Promise(function (res, rej) {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise,\n  };\n}\n\n/* harmony default export */ const Core_defer = (defer);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/getAbsoluteUri.js\n\n\n\n\n\n/**\n * Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.\n * @function\n *\n * @param {String} relative The relative Uri.\n * @param {String} [base] The base Uri.\n * @returns {String} The absolute Uri of the given relative Uri.\n *\n * @example\n * //absolute Uri will be \"https://test.com/awesome.png\";\n * const absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');\n */\nfunction getAbsoluteUri(relative, base) {\n  let documentObject;\n  if (typeof document !== \"undefined\") {\n    documentObject = document;\n  }\n\n  return getAbsoluteUri._implementation(relative, base, documentObject);\n}\n\ngetAbsoluteUri._implementation = function (relative, base, documentObject) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(relative)) {\n    throw new Core_DeveloperError(\"relative uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(base)) {\n    if (typeof documentObject === \"undefined\") {\n      return relative;\n    }\n    base = Core_defaultValue(documentObject.baseURI, documentObject.location.href);\n  }\n\n  const relativeUri = new URI(relative);\n  if (relativeUri.scheme() !== \"\") {\n    return relativeUri.toString();\n  }\n  return relativeUri.absoluteTo(base).toString();\n};\n/* harmony default export */ const Core_getAbsoluteUri = (getAbsoluteUri);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/getBaseUri.js\n\n\n\n\n/**\n * Given a URI, returns the base path of the URI.\n * @function\n *\n * @param {String} uri The Uri.\n * @param {Boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri\n * @returns {String} The base path of the Uri.\n *\n * @example\n * // basePath will be \"/Gallery/\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false');\n *\n * // basePath will be \"/Gallery/?value=true&example=false\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);\n */\nfunction getBaseUri(uri, includeQuery) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(uri)) {\n    throw new Core_DeveloperError(\"uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let basePath = \"\";\n  const i = uri.lastIndexOf(\"/\");\n  if (i !== -1) {\n    basePath = uri.substring(0, i + 1);\n  }\n\n  if (!includeQuery) {\n    return basePath;\n  }\n\n  uri = new URI(uri);\n  if (uri.query().length !== 0) {\n    basePath += `?${uri.query()}`;\n  }\n  if (uri.fragment().length !== 0) {\n    basePath += `#${uri.fragment()}`;\n  }\n\n  return basePath;\n}\n/* harmony default export */ const Core_getBaseUri = (getBaseUri);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/getExtensionFromUri.js\n\n\n\n\n/**\n * Given a URI, returns the extension of the URI.\n * @function getExtensionFromUri\n *\n * @param {String} uri The Uri.\n * @returns {String} The extension of the Uri.\n *\n * @example\n * //extension will be \"czml\";\n * const extension = Cesium.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');\n */\nfunction getExtensionFromUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(uri)) {\n    throw new Core_DeveloperError(\"uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const uriObject = new URI(uri);\n  uriObject.normalize();\n  let path = uriObject.path();\n  let index = path.lastIndexOf(\"/\");\n  if (index !== -1) {\n    path = path.substr(index + 1);\n  }\n  index = path.lastIndexOf(\".\");\n  if (index === -1) {\n    path = \"\";\n  } else {\n    path = path.substr(index + 1);\n  }\n  return path;\n}\n/* harmony default export */ const Core_getExtensionFromUri = (getExtensionFromUri);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/getImagePixels.js\n\n\nconst context2DsByWidthAndHeight = {};\n\n/**\n * Extract a pixel array from a loaded image.  Draws the image\n * into a canvas so it can read the pixels back.\n *\n * @function getImagePixels\n *\n * @param {HTMLImageElement|ImageBitmap} image The image to extract pixels from.\n * @param {Number} width The width of the image. If not defined, then image.width is assigned.\n * @param {Number} height The height of the image. If not defined, then image.height is assigned.\n * @returns {ImageData} The pixels of the image.\n */\nfunction getImagePixels(image, width, height) {\n  if (!Core_defined(width)) {\n    width = image.width;\n  }\n  if (!Core_defined(height)) {\n    height = image.height;\n  }\n\n  let context2DsByHeight = context2DsByWidthAndHeight[width];\n  if (!Core_defined(context2DsByHeight)) {\n    context2DsByHeight = {};\n    context2DsByWidthAndHeight[width] = context2DsByHeight;\n  }\n\n  let context2d = context2DsByHeight[height];\n  if (!Core_defined(context2d)) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    context2d = canvas.getContext(\"2d\");\n    context2d.globalCompositeOperation = \"copy\";\n    context2DsByHeight[height] = context2d;\n  }\n\n  context2d.drawImage(image, 0, 0, width, height);\n  return context2d.getImageData(0, 0, width, height).data;\n}\n/* harmony default export */ const Core_getImagePixels = (getImagePixels);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/isBlobUri.js\n\n\nconst blobUriRegex = /^blob:/i;\n\n/**\n * Determines if the specified uri is a blob uri.\n *\n * @function isBlobUri\n *\n * @param {String} uri The uri to test.\n * @returns {Boolean} true when the uri is a blob uri; otherwise, false.\n *\n * @private\n */\nfunction isBlobUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.string(\"uri\", uri);\n  //>>includeEnd('debug');\n\n  return blobUriRegex.test(uri);\n}\n/* harmony default export */ const Core_isBlobUri = (isBlobUri);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/isCrossOriginUrl.js\n\n\nlet a;\n\n/**\n * Given a URL, determine whether that URL is considered cross-origin to the current page.\n *\n * @private\n */\nfunction isCrossOriginUrl(url) {\n  if (!Core_defined(a)) {\n    a = document.createElement(\"a\");\n  }\n\n  // copy window location into the anchor to get consistent results\n  // when the port is default for the protocol (e.g. 80 for HTTP)\n  a.href = window.location.href;\n\n  // host includes both hostname and port if the port is not standard\n  const host = a.host;\n  const protocol = a.protocol;\n\n  a.href = url;\n  // IE only absolutizes href on get, not set\n  // eslint-disable-next-line no-self-assign\n  a.href = a.href;\n\n  return protocol !== a.protocol || host !== a.host;\n}\n/* harmony default export */ const Core_isCrossOriginUrl = (isCrossOriginUrl);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/isDataUri.js\n\n\nconst dataUriRegex = /^data:/i;\n\n/**\n * Determines if the specified uri is a data uri.\n *\n * @function isDataUri\n *\n * @param {String} uri The uri to test.\n * @returns {Boolean} true when the uri is a data uri; otherwise, false.\n *\n * @private\n */\nfunction isDataUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.string(\"uri\", uri);\n  //>>includeEnd('debug');\n\n  return dataUriRegex.test(uri);\n}\n/* harmony default export */ const Core_isDataUri = (isDataUri);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/loadAndExecuteScript.js\n/**\n * @private\n */\nfunction loadAndExecuteScript(url) {\n  const script = document.createElement(\"script\");\n  script.async = true;\n  script.src = url;\n\n  return new Promise((resolve, reject) => {\n    if (window.crossOriginIsolated) {\n      script.setAttribute(\"crossorigin\", \"anonymous\");\n    }\n\n    const head = document.getElementsByTagName(\"head\")[0];\n    script.onload = function () {\n      script.onload = undefined;\n      head.removeChild(script);\n      resolve();\n    };\n    script.onerror = function (e) {\n      reject(e);\n    };\n\n    head.appendChild(script);\n  });\n}\n/* harmony default export */ const Core_loadAndExecuteScript = (loadAndExecuteScript);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/objectToQuery.js\n\n\n\n/**\n * Converts an object representing a set of name/value pairs into a query string,\n * with names and values encoded properly for use in a URL.  Values that are arrays\n * will produce multiple values with the same name.\n * @function objectToQuery\n *\n * @param {Object} obj The object containing data to encode.\n * @returns {String} An encoded query string.\n *\n *\n * @example\n * const str = Cesium.objectToQuery({\n *     key1 : 'some value',\n *     key2 : 'a/b',\n *     key3 : ['x', 'y']\n * });\n *\n * @see queryToObject\n * // str will be:\n * // 'key1=some%20value&key2=a%2Fb&key3=x&key3=y'\n */\nfunction objectToQuery(obj) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(obj)) {\n    throw new Core_DeveloperError(\"obj is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let result = \"\";\n  for (const propName in obj) {\n    if (obj.hasOwnProperty(propName)) {\n      const value = obj[propName];\n\n      const part = `${encodeURIComponent(propName)}=`;\n      if (Array.isArray(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          result += `${part + encodeURIComponent(value[i])}&`;\n        }\n      } else {\n        result += `${part + encodeURIComponent(value)}&`;\n      }\n    }\n  }\n\n  // trim last &\n  result = result.slice(0, -1);\n\n  // This function used to replace %20 with + which is more compact and readable.\n  // However, some servers didn't properly handle + as a space.\n  // https://github.com/CesiumGS/cesium/issues/2192\n\n  return result;\n}\n/* harmony default export */ const Core_objectToQuery = (objectToQuery);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/queryToObject.js\n\n\n\n/**\n * Parses a query string into an object, where the keys and values of the object are the\n * name/value pairs from the query string, decoded. If a name appears multiple times,\n * the value in the object will be an array of values.\n * @function queryToObject\n *\n * @param {String} queryString The query string.\n * @returns {Object} An object containing the parameters parsed from the query string.\n *\n *\n * @example\n * const obj = Cesium.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');\n * // obj will be:\n * // {\n * //   key1 : 'some value',\n * //   key2 : 'a/b',\n * //   key3 : ['x', 'y']\n * // }\n *\n * @see objectToQuery\n */\nfunction queryToObject(queryString) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(queryString)) {\n    throw new Core_DeveloperError(\"queryString is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const result = {};\n  if (queryString === \"\") {\n    return result;\n  }\n  const parts = queryString.replace(/\\+/g, \"%20\").split(/[&;]/);\n  for (let i = 0, len = parts.length; i < len; ++i) {\n    const subparts = parts[i].split(\"=\");\n\n    const name = decodeURIComponent(subparts[0]);\n    let value = subparts[1];\n    if (Core_defined(value)) {\n      value = decodeURIComponent(value);\n    } else {\n      value = \"\";\n    }\n\n    const resultValue = result[name];\n    if (typeof resultValue === \"string\") {\n      // expand the single value to an array\n      result[name] = [resultValue, value];\n    } else if (Array.isArray(resultValue)) {\n      resultValue.push(value);\n    } else {\n      result[name] = value;\n    }\n  }\n  return result;\n}\n/* harmony default export */ const Core_queryToObject = (queryToObject);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/RequestState.js\n/**\n * State of the request.\n *\n * @enum {Number}\n */\nconst RequestState = {\n  /**\n   * Initial unissued state.\n   *\n   * @type Number\n   * @constant\n   */\n  UNISSUED: 0,\n\n  /**\n   * Issued but not yet active. Will become active when open slots are available.\n   *\n   * @type Number\n   * @constant\n   */\n  ISSUED: 1,\n\n  /**\n   * Actual http request has been sent.\n   *\n   * @type Number\n   * @constant\n   */\n  ACTIVE: 2,\n\n  /**\n   * Request completed successfully.\n   *\n   * @type Number\n   * @constant\n   */\n  RECEIVED: 3,\n\n  /**\n   * Request was cancelled, either explicitly or automatically because of low priority.\n   *\n   * @type Number\n   * @constant\n   */\n  CANCELLED: 4,\n\n  /**\n   * Request failed.\n   *\n   * @type Number\n   * @constant\n   */\n  FAILED: 5,\n};\n/* harmony default export */ const Core_RequestState = (Object.freeze(RequestState));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/RequestType.js\n/**\n * An enum identifying the type of request. Used for finer grained logging and priority sorting.\n *\n * @enum {Number}\n */\nconst RequestType = {\n  /**\n   * Terrain request.\n   *\n   * @type Number\n   * @constant\n   */\n  TERRAIN: 0,\n\n  /**\n   * Imagery request.\n   *\n   * @type Number\n   * @constant\n   */\n  IMAGERY: 1,\n\n  /**\n   * 3D Tiles request.\n   *\n   * @type Number\n   * @constant\n   */\n  TILES3D: 2,\n\n  /**\n   * Other request.\n   *\n   * @type Number\n   * @constant\n   */\n  OTHER: 3,\n};\n/* harmony default export */ const Core_RequestType = (Object.freeze(RequestType));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Request.js\n\n\n\n\n\n/**\n * Stores information for making a request. In general this does not need to be constructed directly.\n *\n * @alias Request\n * @constructor\n\n * @param {Object} [options] An object with the following properties:\n * @param {String} [options.url] The url to request.\n * @param {Request.RequestCallback} [options.requestFunction] The function that makes the actual data request.\n * @param {Request.CancelCallback} [options.cancelFunction] The function that is called when the request is cancelled.\n * @param {Request.PriorityCallback} [options.priorityFunction] The function that is called to update the request's priority, which occurs once per frame.\n * @param {Number} [options.priority=0.0] The initial priority of the request.\n * @param {Boolean} [options.throttle=false] Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the request will be throttled and sent based on priority.\n * @param {Boolean} [options.throttleByServer=false] Whether to throttle the request by server.\n * @param {RequestType} [options.type=RequestType.OTHER] The type of request.\n */\nfunction Request(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n\n  const throttleByServer = Core_defaultValue(options.throttleByServer, false);\n  const throttle = Core_defaultValue(options.throttle, false);\n\n  /**\n   * The URL to request.\n   *\n   * @type {String}\n   */\n  this.url = options.url;\n\n  /**\n   * The function that makes the actual data request.\n   *\n   * @type {Request.RequestCallback}\n   */\n  this.requestFunction = options.requestFunction;\n\n  /**\n   * The function that is called when the request is cancelled.\n   *\n   * @type {Request.CancelCallback}\n   */\n  this.cancelFunction = options.cancelFunction;\n\n  /**\n   * The function that is called to update the request's priority, which occurs once per frame.\n   *\n   * @type {Request.PriorityCallback}\n   */\n  this.priorityFunction = options.priorityFunction;\n\n  /**\n   * Priority is a unit-less value where lower values represent higher priority.\n   * For world-based objects, this is usually the distance from the camera.\n   * A request that does not have a priority function defaults to a priority of 0.\n   *\n   * If priorityFunction is defined, this value is updated every frame with the result of that call.\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.priority = Core_defaultValue(options.priority, 0.0);\n\n  /**\n   * Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the\n   * request will be throttled and sent based on priority.\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  this.throttle = throttle;\n\n  /**\n   * Whether to throttle the request by server. Browsers typically support about 6-8 parallel connections\n   * for HTTP/1 servers, and an unlimited amount of connections for HTTP/2 servers. Setting this value\n   * to <code>true</code> is preferable for requests going through HTTP/1 servers.\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  this.throttleByServer = throttleByServer;\n\n  /**\n   * Type of request.\n   *\n   * @type {RequestType}\n   * @readonly\n   *\n   * @default RequestType.OTHER\n   */\n  this.type = Core_defaultValue(options.type, Core_RequestType.OTHER);\n\n  /**\n   * A key used to identify the server that a request is going to. It is derived from the url's authority and scheme.\n   *\n   * @type {String}\n   *\n   * @private\n   */\n  this.serverKey = undefined;\n\n  /**\n   * The current state of the request.\n   *\n   * @type {RequestState}\n   * @readonly\n   */\n  this.state = Core_RequestState.UNISSUED;\n\n  /**\n   * The requests's deferred promise.\n   *\n   * @type {Object}\n   *\n   * @private\n   */\n  this.deferred = undefined;\n\n  /**\n   * Whether the request was explicitly cancelled.\n   *\n   * @type {Boolean}\n   *\n   * @private\n   */\n  this.cancelled = false;\n}\n\n/**\n * Mark the request as cancelled.\n *\n * @private\n */\nRequest.prototype.cancel = function () {\n  this.cancelled = true;\n};\n\n/**\n * Duplicates a Request instance.\n *\n * @param {Request} [result] The object onto which to store the result.\n *\n * @returns {Request} The modified result parameter or a new Resource instance if one was not provided.\n */\nRequest.prototype.clone = function (result) {\n  if (!Core_defined(result)) {\n    return new Request(this);\n  }\n\n  result.url = this.url;\n  result.requestFunction = this.requestFunction;\n  result.cancelFunction = this.cancelFunction;\n  result.priorityFunction = this.priorityFunction;\n  result.priority = this.priority;\n  result.throttle = this.throttle;\n  result.throttleByServer = this.throttleByServer;\n  result.type = this.type;\n  result.serverKey = this.serverKey;\n\n  // These get defaulted because the cloned request hasn't been issued\n  result.state = this.RequestState.UNISSUED;\n  result.deferred = undefined;\n  result.cancelled = false;\n\n  return result;\n};\n\n/**\n * The function that makes the actual data request.\n * @callback Request.RequestCallback\n * @returns {Promise<void>} A promise for the requested data.\n */\n\n/**\n * The function that is called when the request is cancelled.\n * @callback Request.CancelCallback\n */\n\n/**\n * The function that is called to update the request's priority, which occurs once per frame.\n * @callback Request.PriorityCallback\n * @returns {Number} The updated priority value.\n */\n/* harmony default export */ const Core_Request = (Request);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/parseResponseHeaders.js\n/**\n * Parses the result of XMLHttpRequest's getAllResponseHeaders() method into\n * a dictionary.\n *\n * @function parseResponseHeaders\n *\n * @param {String} headerString The header string returned by getAllResponseHeaders().  The format is\n *                 described here: http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method\n * @returns {Object} A dictionary of key/value pairs, where each key is the name of a header and the corresponding value\n *                   is that header's value.\n *\n * @private\n */\nfunction parseResponseHeaders(headerString) {\n  const headers = {};\n\n  if (!headerString) {\n    return headers;\n  }\n\n  const headerPairs = headerString.split(\"\\u000d\\u000a\");\n\n  for (let i = 0; i < headerPairs.length; ++i) {\n    const headerPair = headerPairs[i];\n    // Can't use split() here because it does the wrong thing\n    // if the header value has the string \": \" in it.\n    const index = headerPair.indexOf(\"\\u003a\\u0020\");\n    if (index > 0) {\n      const key = headerPair.substring(0, index);\n      const val = headerPair.substring(index + 2);\n      headers[key] = val;\n    }\n  }\n\n  return headers;\n}\n/* harmony default export */ const Core_parseResponseHeaders = (parseResponseHeaders);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/RequestErrorEvent.js\n\n\n\n/**\n * An event that is raised when a request encounters an error.\n *\n * @constructor\n * @alias RequestErrorEvent\n *\n * @param {Number} [statusCode] The HTTP error status code, such as 404.\n * @param {Object} [response] The response included along with the error.\n * @param {String|Object} [responseHeaders] The response headers, represented either as an object literal or as a\n *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.\n */\nfunction RequestErrorEvent(statusCode, response, responseHeaders) {\n  /**\n   * The HTTP error status code, such as 404.  If the error does not have a particular\n   * HTTP code, this property will be undefined.\n   *\n   * @type {Number}\n   */\n  this.statusCode = statusCode;\n\n  /**\n   * The response included along with the error.  If the error does not include a response,\n   * this property will be undefined.\n   *\n   * @type {Object}\n   */\n  this.response = response;\n\n  /**\n   * The headers included in the response, represented as an object literal of key/value pairs.\n   * If the error does not include any headers, this property will be undefined.\n   *\n   * @type {Object}\n   */\n  this.responseHeaders = responseHeaders;\n\n  if (typeof this.responseHeaders === \"string\") {\n    this.responseHeaders = Core_parseResponseHeaders(this.responseHeaders);\n  }\n}\n\n/**\n * Creates a string representing this RequestErrorEvent.\n * @memberof RequestErrorEvent\n *\n * @returns {String} A string representing the provided RequestErrorEvent.\n */\nRequestErrorEvent.prototype.toString = function () {\n  let str = \"Request has failed.\";\n  if (Core_defined(this.statusCode)) {\n    str += ` Status Code: ${this.statusCode}`;\n  }\n  return str;\n};\n/* harmony default export */ const Core_RequestErrorEvent = (RequestErrorEvent);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Heap.js\n\n\n\n\n/**\n * Array implementation of a heap.\n *\n * @alias Heap\n * @constructor\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {Heap.ComparatorCallback} options.comparator The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n */\nfunction Heap(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"options\", options);\n  Core_Check.defined(\"options.comparator\", options.comparator);\n  //>>includeEnd('debug');\n\n  this._comparator = options.comparator;\n  this._array = [];\n  this._length = 0;\n  this._maximumLength = undefined;\n}\n\nObject.defineProperties(Heap.prototype, {\n  /**\n   * Gets the length of the heap.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Array}\n   * @readonly\n   */\n  internalArray: {\n    get: function () {\n      return this._array;\n    },\n  },\n\n  /**\n   * Gets and sets the maximum length of the heap.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Number}\n   */\n  maximumLength: {\n    get: function () {\n      return this._maximumLength;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Core_Check.typeOf.number.greaterThanOrEquals(\"maximumLength\", value, 0);\n      //>>includeEnd('debug');\n      const originalLength = this._length;\n      if (value < originalLength) {\n        const array = this._array;\n        // Remove trailing references\n        for (let i = value; i < originalLength; ++i) {\n          array[i] = undefined;\n        }\n        this._length = value;\n        array.length = value;\n      }\n      this._maximumLength = value;\n    },\n  },\n\n  /**\n   * The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Heap.ComparatorCallback}\n   */\n  comparator: {\n    get: function () {\n      return this._comparator;\n    },\n  },\n});\n\nfunction swap(array, a, b) {\n  const temp = array[a];\n  array[a] = array[b];\n  array[b] = temp;\n}\n\n/**\n * Resizes the internal array of the heap.\n *\n * @param {Number} [length] The length to resize internal array to. Defaults to the current length of the heap.\n */\nHeap.prototype.reserve = function (length) {\n  length = Core_defaultValue(length, this._length);\n  this._array.length = length;\n};\n\n/**\n * Update the heap so that index and all descendants satisfy the heap property.\n *\n * @param {Number} [index=0] The starting index to heapify from.\n */\nHeap.prototype.heapify = function (index) {\n  index = Core_defaultValue(index, 0);\n  const length = this._length;\n  const comparator = this._comparator;\n  const array = this._array;\n  let candidate = -1;\n  let inserting = true;\n\n  while (inserting) {\n    const right = 2 * (index + 1);\n    const left = right - 1;\n\n    if (left < length && comparator(array[left], array[index]) < 0) {\n      candidate = left;\n    } else {\n      candidate = index;\n    }\n\n    if (right < length && comparator(array[right], array[candidate]) < 0) {\n      candidate = right;\n    }\n    if (candidate !== index) {\n      swap(array, candidate, index);\n      index = candidate;\n    } else {\n      inserting = false;\n    }\n  }\n};\n\n/**\n * Resort the heap.\n */\nHeap.prototype.resort = function () {\n  const length = this._length;\n  for (let i = Math.ceil(length / 2); i >= 0; --i) {\n    this.heapify(i);\n  }\n};\n\n/**\n * Insert an element into the heap. If the length would grow greater than maximumLength\n * of the heap, extra elements are removed.\n *\n * @param {*} element The element to insert\n *\n * @return {*} The element that was removed from the heap if the heap is at full capacity.\n */\nHeap.prototype.insert = function (element) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"element\", element);\n  //>>includeEnd('debug');\n\n  const array = this._array;\n  const comparator = this._comparator;\n  const maximumLength = this._maximumLength;\n\n  let index = this._length++;\n  if (index < array.length) {\n    array[index] = element;\n  } else {\n    array.push(element);\n  }\n\n  while (index !== 0) {\n    const parent = Math.floor((index - 1) / 2);\n    if (comparator(array[index], array[parent]) < 0) {\n      swap(array, index, parent);\n      index = parent;\n    } else {\n      break;\n    }\n  }\n\n  let removedElement;\n\n  if (Core_defined(maximumLength) && this._length > maximumLength) {\n    removedElement = array[maximumLength];\n    this._length = maximumLength;\n  }\n\n  return removedElement;\n};\n\n/**\n * Remove the element specified by index from the heap and return it.\n *\n * @param {Number} [index=0] The index to remove.\n * @returns {*} The specified element of the heap.\n */\nHeap.prototype.pop = function (index) {\n  index = Core_defaultValue(index, 0);\n  if (this._length === 0) {\n    return undefined;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.number.lessThan(\"index\", index, this._length);\n  //>>includeEnd('debug');\n\n  const array = this._array;\n  const root = array[index];\n  swap(array, index, --this._length);\n  this.heapify(index);\n  array[this._length] = undefined; // Remove trailing reference\n  return root;\n};\n\n/**\n * The comparator to use for the heap.\n * @callback Heap.ComparatorCallback\n * @param {*} a An element in the heap.\n * @param {*} b An element in the heap.\n * @returns {Number} If the result of the comparison is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n */\n/* harmony default export */ const Core_Heap = (Heap);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/RequestScheduler.js\n\n\n\n\n\n\n\n\n\n\n\nfunction sortRequests(a, b) {\n  return a.priority - b.priority;\n}\n\nconst statistics = {\n  numberOfAttemptedRequests: 0,\n  numberOfActiveRequests: 0,\n  numberOfCancelledRequests: 0,\n  numberOfCancelledActiveRequests: 0,\n  numberOfFailedRequests: 0,\n  numberOfActiveRequestsEver: 0,\n  lastNumberOfActiveRequests: 0,\n};\n\nlet priorityHeapLength = 20;\nconst requestHeap = new Core_Heap({\n  comparator: sortRequests,\n});\nrequestHeap.maximumLength = priorityHeapLength;\nrequestHeap.reserve(priorityHeapLength);\n\nconst activeRequests = [];\nlet numberOfActiveRequestsByServer = {};\n\nconst pageUri =\n  typeof document !== \"undefined\" ? new URI(document.location.href) : new URI();\n\nconst requestCompletedEvent = new Core_Event();\n\n/**\n * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability\n * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,\n * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the\n * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.\n *\n * @namespace RequestScheduler\n *\n */\nfunction RequestScheduler() {}\n\n/**\n * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n * @type {Number}\n * @default 50\n */\nRequestScheduler.maximumRequests = 50;\n\n/**\n * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically\n * listed in {@link requestsByServer} do not observe this limit.\n * @type {Number}\n * @default 6\n */\nRequestScheduler.maximumRequestsPerServer = 6;\n\n/**\n * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>\n * @type {Object}\n *\n * @example\n * RequestScheduler.requestsByServer = {\n *   'api.cesium.com:443': 18,\n *   'assets.cesium.com:443': 18\n * };\n */\nRequestScheduler.requestsByServer = {\n  \"api.cesium.com:443\": 18,\n  \"assets.cesium.com:443\": 18,\n};\n\n/**\n * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.\n * @type {Boolean}\n * @default true\n */\nRequestScheduler.throttleRequests = true;\n\n/**\n * When true, log statistics to the console every frame\n * @type {Boolean}\n * @default false\n * @private\n */\nRequestScheduler.debugShowStatistics = false;\n\n/**\n * An event that's raised when a request is completed.  Event handlers are passed\n * the error object if the request fails.\n *\n * @type {Event}\n * @default Event()\n * @private\n */\nRequestScheduler.requestCompletedEvent = requestCompletedEvent;\n\nObject.defineProperties(RequestScheduler, {\n  /**\n   * Returns the statistics used by the request scheduler.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type Object\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return statistics;\n    },\n  },\n\n  /**\n   * The maximum size of the priority heap. This limits the number of requests that are sorted by priority. Only applies to requests that are not yet active.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {Number}\n   * @default 20\n   * @private\n   */\n  priorityHeapLength: {\n    get: function () {\n      return priorityHeapLength;\n    },\n    set: function (value) {\n      // If the new length shrinks the heap, need to cancel some of the requests.\n      // Since this value is not intended to be tweaked regularly it is fine to just cancel the high priority requests.\n      if (value < priorityHeapLength) {\n        while (requestHeap.length > value) {\n          const request = requestHeap.pop();\n          cancelRequest(request);\n        }\n      }\n      priorityHeapLength = value;\n      requestHeap.maximumLength = value;\n      requestHeap.reserve(value);\n    },\n  },\n});\n\nfunction updatePriority(request) {\n  if (Core_defined(request.priorityFunction)) {\n    request.priority = request.priorityFunction();\n  }\n}\n\n/**\n * Check if there are open slots for a particular server key. If desiredRequests is greater than 1, this checks if the queue has room for scheduling multiple requests.\n * @param {String} serverKey The server key returned by {@link RequestScheduler.getServerKey}.\n * @param {Number} [desiredRequests=1] How many requests the caller plans to request\n * @return {Boolean} True if there are enough open slots for <code>desiredRequests</code> more requests.\n * @private\n */\nRequestScheduler.serverHasOpenSlots = function (serverKey, desiredRequests) {\n  desiredRequests = Core_defaultValue(desiredRequests, 1);\n\n  const maxRequests = Core_defaultValue(\n    RequestScheduler.requestsByServer[serverKey],\n    RequestScheduler.maximumRequestsPerServer\n  );\n  const hasOpenSlotsServer =\n    numberOfActiveRequestsByServer[serverKey] + desiredRequests <= maxRequests;\n\n  return hasOpenSlotsServer;\n};\n\n/**\n * Check if the priority heap has open slots, regardless of which server they\n * are from. This is used in {@link Multiple3DTileContent} for determining when\n * all requests can be scheduled\n * @param {Number} desiredRequests The number of requests the caller intends to make\n * @return {Boolean} <code>true</code> if the heap has enough available slots to meet the desiredRequests. <code>false</code> otherwise.\n *\n * @private\n */\nRequestScheduler.heapHasOpenSlots = function (desiredRequests) {\n  const hasOpenSlotsHeap =\n    requestHeap.length + desiredRequests <= priorityHeapLength;\n  return hasOpenSlotsHeap;\n};\n\nfunction issueRequest(request) {\n  if (request.state === Core_RequestState.UNISSUED) {\n    request.state = Core_RequestState.ISSUED;\n    request.deferred = Core_defer();\n  }\n  return request.deferred.promise;\n}\n\nfunction getRequestReceivedFunction(request) {\n  return function (results) {\n    if (request.state === Core_RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    // explicitly set to undefined to ensure GC of request response data. See #8843\n    const deferred = request.deferred;\n\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent();\n    request.state = Core_RequestState.RECEIVED;\n    request.deferred = undefined;\n\n    deferred.resolve(results);\n  };\n}\n\nfunction getRequestFailedFunction(request) {\n  return function (error) {\n    if (request.state === Core_RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    ++statistics.numberOfFailedRequests;\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent(error);\n    request.state = Core_RequestState.FAILED;\n    request.deferred.reject(error);\n  };\n}\n\nfunction startRequest(request) {\n  const promise = issueRequest(request);\n  request.state = Core_RequestState.ACTIVE;\n  activeRequests.push(request);\n  ++statistics.numberOfActiveRequests;\n  ++statistics.numberOfActiveRequestsEver;\n  ++numberOfActiveRequestsByServer[request.serverKey];\n  request\n    .requestFunction()\n    .then(getRequestReceivedFunction(request))\n    .catch(getRequestFailedFunction(request));\n  return promise;\n}\n\nfunction cancelRequest(request) {\n  const active = request.state === Core_RequestState.ACTIVE;\n  request.state = Core_RequestState.CANCELLED;\n  ++statistics.numberOfCancelledRequests;\n  // check that deferred has not been cleared since cancelRequest can be called\n  // on a finished request, e.g. by clearForSpecs during tests\n  if (Core_defined(request.deferred)) {\n    const deferred = request.deferred;\n    request.deferred = undefined;\n    deferred.reject();\n  }\n\n  if (active) {\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    ++statistics.numberOfCancelledActiveRequests;\n  }\n\n  if (Core_defined(request.cancelFunction)) {\n    request.cancelFunction();\n  }\n}\n\n/**\n * Sort requests by priority and start requests.\n * @private\n */\nRequestScheduler.update = function () {\n  let i;\n  let request;\n\n  // Loop over all active requests. Cancelled, failed, or received requests are removed from the array to make room for new requests.\n  let removeCount = 0;\n  const activeLength = activeRequests.length;\n  for (i = 0; i < activeLength; ++i) {\n    request = activeRequests[i];\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n    }\n    if (request.state !== Core_RequestState.ACTIVE) {\n      // Request is no longer active, remove from array\n      ++removeCount;\n      continue;\n    }\n    if (removeCount > 0) {\n      // Shift back to fill in vacated slots from completed requests\n      activeRequests[i - removeCount] = request;\n    }\n  }\n  activeRequests.length -= removeCount;\n\n  // Update priority of issued requests and resort the heap\n  const issuedRequests = requestHeap.internalArray;\n  const issuedLength = requestHeap.length;\n  for (i = 0; i < issuedLength; ++i) {\n    updatePriority(issuedRequests[i]);\n  }\n  requestHeap.resort();\n\n  // Get the number of open slots and fill with the highest priority requests.\n  // Un-throttled requests are automatically added to activeRequests, so activeRequests.length may exceed maximumRequests\n  const openSlots = Math.max(\n    RequestScheduler.maximumRequests - activeRequests.length,\n    0\n  );\n  let filledSlots = 0;\n  while (filledSlots < openSlots && requestHeap.length > 0) {\n    // Loop until all open slots are filled or the heap becomes empty\n    request = requestHeap.pop();\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n      continue;\n    }\n\n    if (\n      request.throttleByServer &&\n      !RequestScheduler.serverHasOpenSlots(request.serverKey)\n    ) {\n      // Open slots are available, but the request is throttled by its server. Cancel and try again later.\n      cancelRequest(request);\n      continue;\n    }\n\n    startRequest(request);\n    ++filledSlots;\n  }\n\n  updateStatistics();\n};\n\n/**\n * Get the server key from a given url.\n *\n * @param {String} url The url.\n * @returns {String} The server key.\n * @private\n */\nRequestScheduler.getServerKey = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.string(\"url\", url);\n  //>>includeEnd('debug');\n\n  let uri = new URI(url);\n  if (uri.scheme() === \"\") {\n    uri = new URI(url).absoluteTo(pageUri);\n    uri.normalize();\n  }\n\n  let serverKey = uri.authority();\n  if (!/:/.test(serverKey)) {\n    // If the authority does not contain a port number, add port 443 for https or port 80 for http\n    serverKey = `${serverKey}:${uri.scheme() === \"https\" ? \"443\" : \"80\"}`;\n  }\n\n  const length = numberOfActiveRequestsByServer[serverKey];\n  if (!Core_defined(length)) {\n    numberOfActiveRequestsByServer[serverKey] = 0;\n  }\n\n  return serverKey;\n};\n\n/**\n * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be\n * queued and sorted by priority before being sent.\n *\n * @param {Request} request The request object.\n *\n * @returns {Promise|undefined} A Promise for the requested data, or undefined if this request does not have high enough priority to be issued.\n *\n * @private\n */\nRequestScheduler.request = function (request) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"request\", request);\n  Core_Check.typeOf.string(\"request.url\", request.url);\n  Core_Check.typeOf.func(\"request.requestFunction\", request.requestFunction);\n  //>>includeEnd('debug');\n\n  if (Core_isDataUri(request.url) || Core_isBlobUri(request.url)) {\n    requestCompletedEvent.raiseEvent();\n    request.state = Core_RequestState.RECEIVED;\n    return request.requestFunction();\n  }\n\n  ++statistics.numberOfAttemptedRequests;\n\n  if (!Core_defined(request.serverKey)) {\n    request.serverKey = RequestScheduler.getServerKey(request.url);\n  }\n\n  if (\n    RequestScheduler.throttleRequests &&\n    request.throttleByServer &&\n    !RequestScheduler.serverHasOpenSlots(request.serverKey)\n  ) {\n    // Server is saturated. Try again later.\n    return undefined;\n  }\n\n  if (!RequestScheduler.throttleRequests || !request.throttle) {\n    return startRequest(request);\n  }\n\n  if (activeRequests.length >= RequestScheduler.maximumRequests) {\n    // Active requests are saturated. Try again later.\n    return undefined;\n  }\n\n  // Insert into the priority heap and see if a request was bumped off. If this request is the lowest\n  // priority it will be returned.\n  updatePriority(request);\n  const removedRequest = requestHeap.insert(request);\n\n  if (Core_defined(removedRequest)) {\n    if (removedRequest === request) {\n      // Request does not have high enough priority to be issued\n      return undefined;\n    }\n    // A previously issued request has been bumped off the priority heap, so cancel it\n    cancelRequest(removedRequest);\n  }\n\n  return issueRequest(request);\n};\n\nfunction updateStatistics() {\n  if (!RequestScheduler.debugShowStatistics) {\n    return;\n  }\n\n  if (\n    statistics.numberOfActiveRequests === 0 &&\n    statistics.lastNumberOfActiveRequests > 0\n  ) {\n    if (statistics.numberOfAttemptedRequests > 0) {\n      console.log(\n        `Number of attempted requests: ${statistics.numberOfAttemptedRequests}`\n      );\n      statistics.numberOfAttemptedRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledRequests > 0) {\n      console.log(\n        `Number of cancelled requests: ${statistics.numberOfCancelledRequests}`\n      );\n      statistics.numberOfCancelledRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledActiveRequests > 0) {\n      console.log(\n        `Number of cancelled active requests: ${statistics.numberOfCancelledActiveRequests}`\n      );\n      statistics.numberOfCancelledActiveRequests = 0;\n    }\n\n    if (statistics.numberOfFailedRequests > 0) {\n      console.log(\n        `Number of failed requests: ${statistics.numberOfFailedRequests}`\n      );\n      statistics.numberOfFailedRequests = 0;\n    }\n  }\n\n  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;\n}\n\n/**\n * For testing only. Clears any requests that may not have completed from previous tests.\n *\n * @private\n */\nRequestScheduler.clearForSpecs = function () {\n  while (requestHeap.length > 0) {\n    const request = requestHeap.pop();\n    cancelRequest(request);\n  }\n  const length = activeRequests.length;\n  for (let i = 0; i < length; ++i) {\n    cancelRequest(activeRequests[i]);\n  }\n  activeRequests.length = 0;\n  numberOfActiveRequestsByServer = {};\n\n  // Clear stats\n  statistics.numberOfAttemptedRequests = 0;\n  statistics.numberOfActiveRequests = 0;\n  statistics.numberOfCancelledRequests = 0;\n  statistics.numberOfCancelledActiveRequests = 0;\n  statistics.numberOfFailedRequests = 0;\n  statistics.numberOfActiveRequestsEver = 0;\n  statistics.lastNumberOfActiveRequests = 0;\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.numberOfActiveRequestsByServer = function (serverKey) {\n  return numberOfActiveRequestsByServer[serverKey];\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.requestHeap = requestHeap;\n/* harmony default export */ const Core_RequestScheduler = (RequestScheduler);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/TrustedServers.js\n\n\n\n\n/**\n * A singleton that contains all of the servers that are trusted. Credentials will be sent with\n * any requests to these servers.\n *\n * @namespace TrustedServers\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nconst TrustedServers = {};\nlet _servers = {};\n\n/**\n * Adds a trusted server to the registry\n *\n * @param {String} host The host to be added.\n * @param {Number} port The port used to access the host.\n *\n * @example\n * // Add a trusted server\n * TrustedServers.add('my.server.com', 80);\n */\nTrustedServers.add = function (host, port) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(host)) {\n    throw new Core_DeveloperError(\"host is required.\");\n  }\n  if (!Core_defined(port) || port <= 0) {\n    throw new Core_DeveloperError(\"port is required to be greater than 0.\");\n  }\n  //>>includeEnd('debug');\n\n  const authority = `${host.toLowerCase()}:${port}`;\n  if (!Core_defined(_servers[authority])) {\n    _servers[authority] = true;\n  }\n};\n\n/**\n * Removes a trusted server from the registry\n *\n * @param {String} host The host to be removed.\n * @param {Number} port The port used to access the host.\n *\n * @example\n * // Remove a trusted server\n * TrustedServers.remove('my.server.com', 80);\n */\nTrustedServers.remove = function (host, port) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(host)) {\n    throw new Core_DeveloperError(\"host is required.\");\n  }\n  if (!Core_defined(port) || port <= 0) {\n    throw new Core_DeveloperError(\"port is required to be greater than 0.\");\n  }\n  //>>includeEnd('debug');\n\n  const authority = `${host.toLowerCase()}:${port}`;\n  if (Core_defined(_servers[authority])) {\n    delete _servers[authority];\n  }\n};\n\nfunction getAuthority(url) {\n  const uri = new URI(url);\n  uri.normalize();\n\n  // Removes username:password@ so we just have host[:port]\n  let authority = uri.authority();\n  if (authority.length === 0) {\n    return undefined; // Relative URL\n  }\n  uri.authority(authority);\n\n  if (authority.indexOf(\"@\") !== -1) {\n    const parts = authority.split(\"@\");\n    authority = parts[1];\n  }\n\n  // If the port is missing add one based on the scheme\n  if (authority.indexOf(\":\") === -1) {\n    let scheme = uri.scheme();\n    if (scheme.length === 0) {\n      scheme = window.location.protocol;\n      scheme = scheme.substring(0, scheme.length - 1);\n    }\n    if (scheme === \"http\") {\n      authority += \":80\";\n    } else if (scheme === \"https\") {\n      authority += \":443\";\n    } else {\n      return undefined;\n    }\n  }\n\n  return authority;\n}\n\n/**\n * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.\n *\n * @param {String} url The url to be tested against the trusted list\n *\n * @returns {boolean} Returns true if url is trusted, false otherwise.\n *\n * @example\n * // Add server\n * TrustedServers.add('my.server.com', 81);\n *\n * // Check if server is trusted\n * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {\n *     // my.server.com:81 is trusted\n * }\n * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {\n *     // my.server.com isn't trusted\n * }\n */\nTrustedServers.contains = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(url)) {\n    throw new Core_DeveloperError(\"url is required.\");\n  }\n  //>>includeEnd('debug');\n  const authority = getAuthority(url);\n  if (Core_defined(authority) && Core_defined(_servers[authority])) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Clears the registry\n *\n * @example\n * // Remove a trusted server\n * TrustedServers.clear();\n */\nTrustedServers.clear = function () {\n  _servers = {};\n};\n/* harmony default export */ const Core_TrustedServers = (TrustedServers);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Resource.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst xhrBlobSupported = (function () {\n  try {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", \"#\", true);\n    xhr.responseType = \"blob\";\n    return xhr.responseType === \"blob\";\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * Parses a query string and returns the object equivalent.\n *\n * @param {Uri} uri The Uri with a query object.\n * @param {Resource} resource The Resource that will be assigned queryParameters.\n * @param {Boolean} merge If true, we'll merge with the resource's existing queryParameters. Otherwise they will be replaced.\n * @param {Boolean} preserveQueryParameters If true duplicate parameters will be concatenated into an array. If false, keys in uri will take precedence.\n *\n * @private\n */\nfunction parseQuery(uri, resource, merge, preserveQueryParameters) {\n  const queryString = uri.query();\n  if (queryString.length === 0) {\n    return {};\n  }\n\n  let query;\n  // Special case we run into where the querystring is just a string, not key/value pairs\n  if (queryString.indexOf(\"=\") === -1) {\n    const result = {};\n    result[queryString] = undefined;\n    query = result;\n  } else {\n    query = Core_queryToObject(queryString);\n  }\n\n  if (merge) {\n    resource._queryParameters = combineQueryParameters(\n      query,\n      resource._queryParameters,\n      preserveQueryParameters\n    );\n  } else {\n    resource._queryParameters = query;\n  }\n  uri.search(\"\");\n}\n\n/**\n * Converts a query object into a string.\n *\n * @param {Uri} uri The Uri object that will have the query object set.\n * @param {Resource} resource The resource that has queryParameters\n *\n * @private\n */\nfunction stringifyQuery(uri, resource) {\n  const queryObject = resource._queryParameters;\n\n  const keys = Object.keys(queryObject);\n\n  // We have 1 key with an undefined value, so this is just a string, not key/value pairs\n  if (keys.length === 1 && !Core_defined(queryObject[keys[0]])) {\n    uri.search(keys[0]);\n  } else {\n    uri.search(Core_objectToQuery(queryObject));\n  }\n}\n\n/**\n * Clones a value if it is defined, otherwise returns the default value\n *\n * @param {*} [val] The value to clone.\n * @param {*} [defaultVal] The default value.\n *\n * @returns {*} A clone of val or the defaultVal.\n *\n * @private\n */\nfunction defaultClone(val, defaultVal) {\n  if (!Core_defined(val)) {\n    return defaultVal;\n  }\n\n  return Core_defined(val.clone) ? val.clone() : Core_clone(val);\n}\n\n/**\n * Checks to make sure the Resource isn't already being requested.\n *\n * @param {Request} request The request to check.\n *\n * @private\n */\nfunction checkAndResetRequest(request) {\n  if (\n    request.state === Core_RequestState.ISSUED ||\n    request.state === Core_RequestState.ACTIVE\n  ) {\n    throw new Core_RuntimeError(\"The Resource is already being fetched.\");\n  }\n\n  request.state = Core_RequestState.UNISSUED;\n  request.deferred = undefined;\n}\n\n/**\n * This combines a map of query parameters.\n *\n * @param {Object} q1 The first map of query parameters. Values in this map will take precedence if preserveQueryParameters is false.\n * @param {Object} q2 The second map of query parameters.\n * @param {Boolean} preserveQueryParameters If true duplicate parameters will be concatenated into an array. If false, keys in q1 will take precedence.\n *\n * @returns {Object} The combined map of query parameters.\n *\n * @example\n * const q1 = {\n *   a: 1,\n *   b: 2\n * };\n * const q2 = {\n *   a: 3,\n *   c: 4\n * };\n * const q3 = {\n *   b: [5, 6],\n *   d: 7\n * }\n *\n * // Returns\n * // {\n * //   a: [1, 3],\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, false);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: [2, 5, 6],\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, false);\n *\n * @private\n */\nfunction combineQueryParameters(q1, q2, preserveQueryParameters) {\n  if (!preserveQueryParameters) {\n    return Core_combine(q1, q2);\n  }\n\n  const result = Core_clone(q1, true);\n  for (const param in q2) {\n    if (q2.hasOwnProperty(param)) {\n      let value = result[param];\n      const q2Value = q2[param];\n      if (Core_defined(value)) {\n        if (!Array.isArray(value)) {\n          value = result[param] = [value];\n        }\n\n        result[param] = value.concat(q2Value);\n      } else {\n        result[param] = Array.isArray(q2Value) ? q2Value.slice() : q2Value;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * @typedef {Object} Resource.ConstructorOptions\n *\n * Initialization options for the Resource constructor\n *\n * @property {String} url The url of the resource.\n * @property {Object} [queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @property {Object} [templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @property {Object} [headers={}] Additional HTTP headers that will be sent.\n * @property {Proxy} [proxy] A proxy to be used when loading the resource.\n * @property {Resource.RetryCallback} [retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @property {Number} [retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @property {Request} [request] A Request object that will be used. Intended for internal use only.\n */\n\n/**\n * A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.\n *\n * @alias Resource\n * @constructor\n *\n * @param {String|Resource.ConstructorOptions} options A url or an object describing initialization options\n *\n * @example\n * function refreshTokenRetryCallback(resource, error) {\n *   if (error.statusCode === 403) {\n *     // 403 status code means a new token should be generated\n *     return getNewAccessToken()\n *       .then(function(token) {\n *         resource.queryParameters.access_token = token;\n *         return true;\n *       })\n *       .catch(function() {\n *         return false;\n *       });\n *   }\n *\n *   return false;\n * }\n *\n * const resource = new Resource({\n *    url: 'http://server.com/path/to/resource.json',\n *    proxy: new DefaultProxy('/proxy/'),\n *    headers: {\n *      'X-My-Header': 'valueOfHeader'\n *    },\n *    queryParameters: {\n *      'access_token': '123-435-456-000'\n *    },\n *    retryCallback: refreshTokenRetryCallback,\n *    retryAttempts: 1\n * });\n */\nfunction Resource(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n  if (typeof options === \"string\") {\n    options = {\n      url: options,\n    };\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.string(\"options.url\", options.url);\n  //>>includeEnd('debug');\n\n  this._url = undefined;\n  this._templateValues = defaultClone(options.templateValues, {});\n  this._queryParameters = defaultClone(options.queryParameters, {});\n\n  /**\n   * Additional HTTP headers that will be sent with the request.\n   *\n   * @type {Object}\n   */\n  this.headers = defaultClone(options.headers, {});\n\n  /**\n   * A Request object that will be used. Intended for internal use only.\n   *\n   * @type {Request}\n   */\n  this.request = Core_defaultValue(options.request, new Core_Request());\n\n  /**\n   * A proxy to be used when loading the resource.\n   *\n   * @type {Proxy}\n   */\n  this.proxy = options.proxy;\n\n  /**\n   * Function to call when a request for this resource fails. If it returns true or a Promise that resolves to true, the request will be retried.\n   *\n   * @type {Function}\n   */\n  this.retryCallback = options.retryCallback;\n\n  /**\n   * The number of times the retryCallback should be called before giving up.\n   *\n   * @type {Number}\n   */\n  this.retryAttempts = Core_defaultValue(options.retryAttempts, 0);\n  this._retryCount = 0;\n\n  const uri = new URI(options.url);\n  parseQuery(uri, this, true, true);\n\n  // Remove the fragment as it's not sent with a request\n  uri.fragment(\"\");\n\n  this._url = uri.toString();\n}\n\n/**\n * A helper function to create a resource depending on whether we have a String or a Resource\n *\n * @param {Resource|String} resource A Resource or a String to use when creating a new Resource.\n *\n * @returns {Resource} If resource is a String, a Resource constructed with the url and options. Otherwise the resource parameter is returned.\n *\n * @private\n */\nResource.createIfNeeded = function (resource) {\n  if (resource instanceof Resource) {\n    // Keep existing request object. This function is used internally to duplicate a Resource, so that it can't\n    //  be modified outside of a class that holds it (eg. an imagery or terrain provider). Since the Request objects\n    //  are managed outside of the providers, by the tile loading code, we want to keep the request property the same so if it is changed\n    //  in the underlying tiling code the requests for this resource will use it.\n    return resource.getDerivedResource({\n      request: resource.request,\n    });\n  }\n\n  if (typeof resource !== \"string\") {\n    return resource;\n  }\n\n  return new Resource({\n    url: resource,\n  });\n};\n\nlet supportsImageBitmapOptionsPromise;\n/**\n * A helper function to check whether createImageBitmap supports passing ImageBitmapOptions.\n *\n * @returns {Promise<Boolean>} A promise that resolves to true if this browser supports creating an ImageBitmap with options.\n *\n * @private\n */\nResource.supportsImageBitmapOptions = function () {\n  // Until the HTML folks figure out what to do about this, we need to actually try loading an image to\n  // know if this browser supports passing options to the createImageBitmap function.\n  // https://github.com/whatwg/html/pull/4248\n  //\n  // We also need to check whether the colorSpaceConversion option is supported.\n  // We do this by loading a PNG with an embedded color profile, first with\n  // colorSpaceConversion: \"none\" and then with colorSpaceConversion: \"default\".\n  // If the pixel color is different then we know the option is working.\n  // As of Webkit 17612.3.6.1.6 the createImageBitmap promise resolves but the\n  // option is not actually supported.\n  if (Core_defined(supportsImageBitmapOptionsPromise)) {\n    return supportsImageBitmapOptionsPromise;\n  }\n\n  if (typeof createImageBitmap !== \"function\") {\n    supportsImageBitmapOptionsPromise = Promise.resolve(false);\n    return supportsImageBitmapOptionsPromise;\n  }\n\n  const imageDataUri =\n    \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAABGdBTUEAAE4g3rEiDgAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADElEQVQI12Ng6GAAAAEUAIngE3ZiAAAAAElFTkSuQmCC\";\n\n  supportsImageBitmapOptionsPromise = Resource.fetchBlob({\n    url: imageDataUri,\n  })\n    .then(function (blob) {\n      const imageBitmapOptions = {\n        imageOrientation: \"flipY\", // default is \"none\"\n        premultiplyAlpha: \"none\", // default is \"default\"\n        colorSpaceConversion: \"none\", // default is \"default\"\n      };\n      return Promise.all([\n        createImageBitmap(blob, imageBitmapOptions),\n        createImageBitmap(blob),\n      ]);\n    })\n    .then(function (imageBitmaps) {\n      // Check whether the colorSpaceConversion option had any effect on the green channel\n      const colorWithOptions = Core_getImagePixels(imageBitmaps[0]);\n      const colorWithDefaults = Core_getImagePixels(imageBitmaps[1]);\n      return colorWithOptions[1] !== colorWithDefaults[1];\n    })\n    .catch(function () {\n      return false;\n    });\n\n  return supportsImageBitmapOptionsPromise;\n};\n\nObject.defineProperties(Resource, {\n  /**\n   * Returns true if blobs are supported.\n   *\n   * @memberof Resource\n   * @type {Boolean}\n   *\n   * @readonly\n   */\n  isBlobSupported: {\n    get: function () {\n      return xhrBlobSupported;\n    },\n  },\n});\n\nObject.defineProperties(Resource.prototype, {\n  /**\n   * Query parameters appended to the url.\n   *\n   * @memberof Resource.prototype\n   * @type {Object}\n   *\n   * @readonly\n   */\n  queryParameters: {\n    get: function () {\n      return this._queryParameters;\n    },\n  },\n\n  /**\n   * The key/value pairs used to replace template parameters in the url.\n   *\n   * @memberof Resource.prototype\n   * @type {Object}\n   *\n   * @readonly\n   */\n  templateValues: {\n    get: function () {\n      return this._templateValues;\n    },\n  },\n\n  /**\n   * The url to the resource with template values replaced, query string appended and encoded by proxy if one was set.\n   *\n   * @memberof Resource.prototype\n   * @type {String}\n   */\n  url: {\n    get: function () {\n      return this.getUrlComponent(true, true);\n    },\n    set: function (value) {\n      const uri = new URI(value);\n\n      parseQuery(uri, this, false);\n\n      // Remove the fragment as it's not sent with a request\n      uri.fragment(\"\");\n\n      this._url = uri.toString();\n    },\n  },\n\n  /**\n   * The file extension of the resource.\n   *\n   * @memberof Resource.prototype\n   * @type {String}\n   *\n   * @readonly\n   */\n  extension: {\n    get: function () {\n      return Core_getExtensionFromUri(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource refers to a data URI.\n   *\n   * @memberof Resource.prototype\n   * @type {Boolean}\n   */\n  isDataUri: {\n    get: function () {\n      return Core_isDataUri(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource refers to a blob URI.\n   *\n   * @memberof Resource.prototype\n   * @type {Boolean}\n   */\n  isBlobUri: {\n    get: function () {\n      return Core_isBlobUri(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource refers to a cross origin URL.\n   *\n   * @memberof Resource.prototype\n   * @type {Boolean}\n   */\n  isCrossOriginUrl: {\n    get: function () {\n      return Core_isCrossOriginUrl(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource has request headers. This is equivalent to checking if the headers property has any keys.\n   *\n   * @memberof Resource.prototype\n   * @type {Boolean}\n   */\n  hasHeaders: {\n    get: function () {\n      return Object.keys(this.headers).length > 0;\n    },\n  },\n});\n\n/**\n * Override Object#toString so that implicit string conversion gives the\n * complete URL represented by this Resource.\n *\n * @returns {String} The URL represented by this Resource\n */\nResource.prototype.toString = function () {\n  return this.getUrlComponent(true, true);\n};\n\n/**\n * Returns the url, optional with the query string and processed by a proxy.\n *\n * @param {Boolean} [query=false] If true, the query string is included.\n * @param {Boolean} [proxy=false] If true, the url is processed by the proxy object, if defined.\n *\n * @returns {String} The url with all the requested components.\n */\nResource.prototype.getUrlComponent = function (query, proxy) {\n  if (this.isDataUri) {\n    return this._url;\n  }\n\n  const uri = new URI(this._url);\n\n  if (query) {\n    stringifyQuery(uri, this);\n  }\n\n  // objectToQuery escapes the placeholders.  Undo that.\n  let url = uri.toString().replace(/%7B/g, \"{\").replace(/%7D/g, \"}\");\n\n  const templateValues = this._templateValues;\n  url = url.replace(/{(.*?)}/g, function (match, key) {\n    const replacement = templateValues[key];\n    if (Core_defined(replacement)) {\n      // use the replacement value from templateValues if there is one...\n      return encodeURIComponent(replacement);\n    }\n    // otherwise leave it unchanged\n    return match;\n  });\n\n  if (proxy && Core_defined(this.proxy)) {\n    url = this.proxy.getURL(url);\n  }\n  return url;\n};\n\n/**\n * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,\n *  as opposed to adding them one at a time to the queryParameters property. If a value is already set, it will be replaced with the new value.\n *\n * @param {Object} params The query parameters\n * @param {Boolean} [useAsDefault=false] If true the params will be used as the default values, so they will only be set if they are undefined.\n */\nResource.prototype.setQueryParameters = function (params, useAsDefault) {\n  if (useAsDefault) {\n    this._queryParameters = combineQueryParameters(\n      this._queryParameters,\n      params,\n      false\n    );\n  } else {\n    this._queryParameters = combineQueryParameters(\n      params,\n      this._queryParameters,\n      false\n    );\n  }\n};\n\n/**\n * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,\n *  as opposed to adding them one at a time to the queryParameters property.\n *\n * @param {Object} params The query parameters\n */\nResource.prototype.appendQueryParameters = function (params) {\n  this._queryParameters = combineQueryParameters(\n    params,\n    this._queryParameters,\n    true\n  );\n};\n\n/**\n * Combines the specified object and the existing template values. This allows you to add many values at once,\n *  as opposed to adding them one at a time to the templateValues property. If a value is already set, it will become an array and the new value will be appended.\n *\n * @param {Object} template The template values\n * @param {Boolean} [useAsDefault=false] If true the values will be used as the default values, so they will only be set if they are undefined.\n */\nResource.prototype.setTemplateValues = function (template, useAsDefault) {\n  if (useAsDefault) {\n    this._templateValues = Core_combine(this._templateValues, template);\n  } else {\n    this._templateValues = Core_combine(template, this._templateValues);\n  }\n};\n\n/**\n * Returns a resource relative to the current instance. All properties remain the same as the current instance unless overridden in options.\n *\n * @param {Object} options An object with the following properties\n * @param {String} [options.url]  The url that will be resolved relative to the url of the current instance.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be combined with those of the current instance.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}). These will be combined with those of the current instance.\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The function to call when loading the resource fails.\n * @param {Number} [options.retryAttempts] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {Boolean} [options.preserveQueryParameters=false] If true, this will keep all query parameters from the current resource and derived resource. If false, derived parameters will replace those of the current resource.\n *\n * @returns {Resource} The resource derived from the current one.\n */\nResource.prototype.getDerivedResource = function (options) {\n  const resource = this.clone();\n  resource._retryCount = 0;\n\n  if (Core_defined(options.url)) {\n    const uri = new URI(options.url);\n\n    const preserveQueryParameters = Core_defaultValue(\n      options.preserveQueryParameters,\n      false\n    );\n    parseQuery(uri, resource, true, preserveQueryParameters);\n\n    // Remove the fragment as it's not sent with a request\n    uri.fragment(\"\");\n\n    if (uri.scheme() !== \"\") {\n      resource._url = uri.toString();\n    } else {\n      resource._url = uri\n        .absoluteTo(new URI(Core_getAbsoluteUri(this._url)))\n        .toString();\n    }\n  }\n\n  if (Core_defined(options.queryParameters)) {\n    resource._queryParameters = Core_combine(\n      options.queryParameters,\n      resource._queryParameters\n    );\n  }\n  if (Core_defined(options.templateValues)) {\n    resource._templateValues = Core_combine(\n      options.templateValues,\n      resource.templateValues\n    );\n  }\n  if (Core_defined(options.headers)) {\n    resource.headers = Core_combine(options.headers, resource.headers);\n  }\n  if (Core_defined(options.proxy)) {\n    resource.proxy = options.proxy;\n  }\n  if (Core_defined(options.request)) {\n    resource.request = options.request;\n  }\n  if (Core_defined(options.retryCallback)) {\n    resource.retryCallback = options.retryCallback;\n  }\n  if (Core_defined(options.retryAttempts)) {\n    resource.retryAttempts = options.retryAttempts;\n  }\n\n  return resource;\n};\n\n/**\n * Called when a resource fails to load. This will call the retryCallback function if defined until retryAttempts is reached.\n *\n * @param {Error} [error] The error that was encountered.\n *\n * @returns {Promise<Boolean>} A promise to a boolean, that if true will cause the resource request to be retried.\n *\n * @private\n */\nResource.prototype.retryOnError = function (error) {\n  const retryCallback = this.retryCallback;\n  if (\n    typeof retryCallback !== \"function\" ||\n    this._retryCount >= this.retryAttempts\n  ) {\n    return Promise.resolve(false);\n  }\n\n  const that = this;\n  return Promise.resolve(retryCallback(this, error)).then(function (result) {\n    ++that._retryCount;\n\n    return result;\n  });\n};\n\n/**\n * Duplicates a Resource instance.\n *\n * @param {Resource} [result] The object onto which to store the result.\n *\n * @returns {Resource} The modified result parameter or a new Resource instance if one was not provided.\n */\nResource.prototype.clone = function (result) {\n  if (!Core_defined(result)) {\n    result = new Resource({\n      url: this._url,\n    });\n  }\n\n  result._url = this._url;\n  result._queryParameters = Core_clone(this._queryParameters);\n  result._templateValues = Core_clone(this._templateValues);\n  result.headers = Core_clone(this.headers);\n  result.proxy = this.proxy;\n  result.retryCallback = this.retryCallback;\n  result.retryAttempts = this.retryAttempts;\n  result._retryCount = 0;\n  result.request = this.request.clone();\n\n  return result;\n};\n\n/**\n * Returns the base path of the Resource.\n *\n * @param {Boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri\n *\n * @returns {String} The base URI of the resource\n */\nResource.prototype.getBaseUri = function (includeQuery) {\n  return Core_getBaseUri(this.getUrlComponent(includeQuery), includeQuery);\n};\n\n/**\n * Appends a forward slash to the URL.\n */\nResource.prototype.appendForwardSlash = function () {\n  this._url = Core_appendForwardSlash(this._url);\n};\n\n/**\n * Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to\n * an ArrayBuffer once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise.<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n * @example\n * // load a single URL asynchronously\n * resource.fetchArrayBuffer().then(function(arrayBuffer) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchArrayBuffer = function () {\n  return this.fetch({\n    responseType: \"arraybuffer\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchArrayBuffer() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise.<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchArrayBuffer = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchArrayBuffer();\n};\n\n/**\n * Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to\n * a Blob once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise.<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n * @example\n * // load a single URL asynchronously\n * resource.fetchBlob().then(function(blob) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchBlob = function () {\n  return this.fetch({\n    responseType: \"blob\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchBlob() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise.<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchBlob = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchBlob();\n};\n\n/**\n * Asynchronously loads the given image resource.  Returns a promise that will resolve to\n * an {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap|ImageBitmap} if <code>preferImageBitmap</code> is true and the browser supports <code>createImageBitmap</code> or otherwise an\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement|Image} once loaded, or reject if the image failed to load.\n *\n * @param {Object} [options] An object with the following properties.\n * @param {Boolean} [options.preferBlob=false] If true, we will load the image via a blob.\n * @param {Boolean} [options.preferImageBitmap=false] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.\n * @param {Boolean} [options.flipY=false] If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.\n * @param {Boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.\n * @returns {Promise.<ImageBitmap|HTMLImageElement>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * // load a single image asynchronously\n * resource.fetchImage().then(function(image) {\n *     // use the loaded image\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * // load several images in parallel\n * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {\n *     // images is an array containing all the loaded images\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchImage = function (options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n  const preferImageBitmap = Core_defaultValue(options.preferImageBitmap, false);\n  const preferBlob = Core_defaultValue(options.preferBlob, false);\n  const flipY = Core_defaultValue(options.flipY, false);\n  const skipColorSpaceConversion = Core_defaultValue(\n    options.skipColorSpaceConversion,\n    false\n  );\n\n  checkAndResetRequest(this.request);\n  // We try to load the image normally if\n  // 1. Blobs aren't supported\n  // 2. It's a data URI\n  // 3. It's a blob URI\n  // 4. It doesn't have request headers and we preferBlob is false\n  if (\n    !xhrBlobSupported ||\n    this.isDataUri ||\n    this.isBlobUri ||\n    (!this.hasHeaders && !preferBlob)\n  ) {\n    return fetchImage({\n      resource: this,\n      flipY: flipY,\n      skipColorSpaceConversion: skipColorSpaceConversion,\n      preferImageBitmap: preferImageBitmap,\n    });\n  }\n\n  const blobPromise = this.fetchBlob();\n  if (!Core_defined(blobPromise)) {\n    return;\n  }\n\n  let supportsImageBitmap;\n  let useImageBitmap;\n  let generatedBlobResource;\n  let generatedBlob;\n  return Resource.supportsImageBitmapOptions()\n    .then(function (result) {\n      supportsImageBitmap = result;\n      useImageBitmap = supportsImageBitmap && preferImageBitmap;\n      return blobPromise;\n    })\n    .then(function (blob) {\n      if (!Core_defined(blob)) {\n        return;\n      }\n      generatedBlob = blob;\n      if (useImageBitmap) {\n        return Resource.createImageBitmapFromBlob(blob, {\n          flipY: flipY,\n          premultiplyAlpha: false,\n          skipColorSpaceConversion: skipColorSpaceConversion,\n        });\n      }\n      const blobUrl = window.URL.createObjectURL(blob);\n      generatedBlobResource = new Resource({\n        url: blobUrl,\n      });\n\n      return fetchImage({\n        resource: generatedBlobResource,\n        flipY: flipY,\n        skipColorSpaceConversion: skipColorSpaceConversion,\n        preferImageBitmap: false,\n      });\n    })\n    .then(function (image) {\n      if (!Core_defined(image)) {\n        return;\n      }\n\n      // The blob object may be needed for use by a TileDiscardPolicy,\n      // so attach it to the image.\n      image.blob = generatedBlob;\n\n      if (useImageBitmap) {\n        return image;\n      }\n\n      window.URL.revokeObjectURL(generatedBlobResource.url);\n      return image;\n    })\n    .catch(function (error) {\n      if (Core_defined(generatedBlobResource)) {\n        window.URL.revokeObjectURL(generatedBlobResource.url);\n      }\n\n      // If the blob load succeeded but the image decode failed, attach the blob\n      // to the error object for use by a TileDiscardPolicy.\n      // In particular, BingMapsImageryProvider uses this to detect the\n      // zero-length response that is returned when a tile is not available.\n      error.blob = generatedBlob;\n\n      return Promise.reject(error);\n    });\n};\n\n/**\n * Fetches an image and returns a promise to it.\n *\n * @param {Object} [options] An object with the following properties.\n * @param {Resource} [options.resource] Resource object that points to an image to fetch.\n * @param {Boolean} [options.preferImageBitmap] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.\n * @param {Boolean} [options.flipY] If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.\n * @param {Boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.\n * @private\n */\nfunction fetchImage(options) {\n  const resource = options.resource;\n  const flipY = options.flipY;\n  const skipColorSpaceConversion = options.skipColorSpaceConversion;\n  const preferImageBitmap = options.preferImageBitmap;\n\n  const request = resource.request;\n  request.url = resource.url;\n  request.requestFunction = function () {\n    let crossOrigin = false;\n\n    // data URIs can't have crossorigin set.\n    if (!resource.isDataUri && !resource.isBlobUri) {\n      crossOrigin = resource.isCrossOriginUrl;\n    }\n\n    const deferred = Core_defer();\n    Resource._Implementations.createImage(\n      request,\n      crossOrigin,\n      deferred,\n      flipY,\n      skipColorSpaceConversion,\n      preferImageBitmap\n    );\n\n    return deferred.promise;\n  };\n\n  const promise = Core_RequestScheduler.request(request);\n  if (!Core_defined(promise)) {\n    return;\n  }\n\n  return promise.catch(function (e) {\n    // Don't retry cancelled or otherwise aborted requests\n    if (request.state !== Core_RequestState.FAILED) {\n      return Promise.reject(e);\n    }\n    return resource.retryOnError(e).then(function (retry) {\n      if (retry) {\n        // Reset request so it can try again\n        request.state = Core_RequestState.UNISSUED;\n        request.deferred = undefined;\n\n        return fetchImage({\n          resource: resource,\n          flipY: flipY,\n          skipColorSpaceConversion: skipColorSpaceConversion,\n          preferImageBitmap: preferImageBitmap,\n        });\n      }\n      return Promise.reject(e);\n    });\n  });\n}\n\n/**\n * Creates a Resource and calls fetchImage() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Boolean} [options.flipY=false] Whether to vertically flip the image during fetch and decode. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {Boolean} [options.preferBlob=false]  If true, we will load the image via a blob.\n * @param {Boolean} [options.preferImageBitmap=false] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.\n * @param {Boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.\n * @returns {Promise.<ImageBitmap|HTMLImageElement>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchImage = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchImage({\n    flipY: options.flipY,\n    skipColorSpaceConversion: options.skipColorSpaceConversion,\n    preferBlob: options.preferBlob,\n    preferImageBitmap: options.preferImageBitmap,\n  });\n};\n\n/**\n * Asynchronously loads the given resource as text.  Returns a promise that will resolve to\n * a String once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise.<String>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n * @example\n * // load text from a URL, setting a custom header\n * const resource = new Resource({\n *   url: 'http://someUrl.com/someJson.txt',\n *   headers: {\n *     'X-Custom-Header' : 'some value'\n *   }\n * });\n * resource.fetchText().then(function(text) {\n *     // Do something with the text\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchText = function () {\n  return this.fetch({\n    responseType: \"text\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchText() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise.<String>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchText = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchText();\n};\n\n// note: &#42;&#47;&#42; below is */* but that ends the comment block early\n/**\n * Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to\n * a JSON object once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function\n * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not\n * already specified.\n *\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.fetchJson().then(function(jsonData) {\n *     // Do something with the JSON object\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchJson = function () {\n  const promise = this.fetch({\n    responseType: \"text\",\n    headers: {\n      Accept: \"application/json,*/*;q=0.01\",\n    },\n  });\n\n  if (!Core_defined(promise)) {\n    return undefined;\n  }\n\n  return promise.then(function (value) {\n    if (!Core_defined(value)) {\n      return;\n    }\n    return JSON.parse(value);\n  });\n};\n\n/**\n * Creates a Resource and calls fetchJson() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchJson = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchJson();\n};\n\n/**\n * Asynchronously loads the given resource as XML.  Returns a promise that will resolve to\n * an XML Document once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise.<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * // load XML from a URL, setting a custom header\n * Cesium.loadXML('http://someUrl.com/someXML.xml', {\n *   'X-Custom-Header' : 'some value'\n * }).then(function(document) {\n *     // Do something with the document\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchXML = function () {\n  return this.fetch({\n    responseType: \"document\",\n    overrideMimeType: \"text/xml\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchXML() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise.<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchXML = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchXML();\n};\n\n/**\n * Requests a resource using JSONP.\n *\n * @param {String} [callbackParameterName='callback'] The callback parameter name that the server expects.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * // load a data asynchronously\n * resource.fetchJsonp().then(function(data) {\n *     // use the loaded data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchJsonp = function (callbackParameterName) {\n  callbackParameterName = Core_defaultValue(callbackParameterName, \"callback\");\n\n  checkAndResetRequest(this.request);\n\n  //generate a unique function name\n  let functionName;\n  do {\n    functionName = `loadJsonp${Core_Math.nextRandomNumber()\n      .toString()\n      .substring(2, 8)}`;\n  } while (Core_defined(window[functionName]));\n\n  return fetchJsonp(this, callbackParameterName, functionName);\n};\n\nfunction fetchJsonp(resource, callbackParameterName, functionName) {\n  const callbackQuery = {};\n  callbackQuery[callbackParameterName] = functionName;\n  resource.setQueryParameters(callbackQuery);\n\n  const request = resource.request;\n  request.url = resource.url;\n  request.requestFunction = function () {\n    const deferred = Core_defer();\n\n    //assign a function with that name in the global scope\n    window[functionName] = function (data) {\n      deferred.resolve(data);\n\n      try {\n        delete window[functionName];\n      } catch (e) {\n        window[functionName] = undefined;\n      }\n    };\n\n    Resource._Implementations.loadAndExecuteScript(\n      resource.url,\n      functionName,\n      deferred\n    );\n    return deferred.promise;\n  };\n\n  const promise = Core_RequestScheduler.request(request);\n  if (!Core_defined(promise)) {\n    return;\n  }\n\n  return promise.catch(function (e) {\n    if (request.state !== Core_RequestState.FAILED) {\n      return Promise.reject(e);\n    }\n\n    return resource.retryOnError(e).then(function (retry) {\n      if (retry) {\n        // Reset request so it can try again\n        request.state = Core_RequestState.UNISSUED;\n        request.deferred = undefined;\n\n        return fetchJsonp(resource, callbackParameterName, functionName);\n      }\n\n      return Promise.reject(e);\n    });\n  });\n}\n\n/**\n * Creates a Resource from a URL and calls fetchJsonp() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.callbackParameterName='callback'] The callback parameter name that the server expects.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchJsonp = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchJsonp(options.callbackParameterName);\n};\n\n/**\n * @private\n */\nResource.prototype._makeRequest = function (options) {\n  const resource = this;\n  checkAndResetRequest(resource.request);\n\n  const request = resource.request;\n  request.url = resource.url;\n\n  request.requestFunction = function () {\n    const responseType = options.responseType;\n    const headers = Core_combine(options.headers, resource.headers);\n    const overrideMimeType = options.overrideMimeType;\n    const method = options.method;\n    const data = options.data;\n    const deferred = Core_defer();\n    const xhr = Resource._Implementations.loadWithXhr(\n      resource.url,\n      responseType,\n      method,\n      data,\n      headers,\n      deferred,\n      overrideMimeType\n    );\n    if (Core_defined(xhr) && Core_defined(xhr.abort)) {\n      request.cancelFunction = function () {\n        xhr.abort();\n      };\n    }\n    return deferred.promise;\n  };\n\n  const promise = Core_RequestScheduler.request(request);\n  if (!Core_defined(promise)) {\n    return;\n  }\n\n  return promise\n    .then(function (data) {\n      // explicitly set to undefined to ensure GC of request response data. See #8843\n      request.cancelFunction = undefined;\n      return data;\n    })\n    .catch(function (e) {\n      request.cancelFunction = undefined;\n      if (request.state !== Core_RequestState.FAILED) {\n        return Promise.reject(e);\n      }\n\n      return resource.retryOnError(e).then(function (retry) {\n        if (retry) {\n          // Reset request so it can try again\n          request.state = Core_RequestState.UNISSUED;\n          request.deferred = undefined;\n\n          return resource.fetch(options);\n        }\n\n        return Promise.reject(e);\n      });\n    });\n};\n\nconst Resource_dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\nfunction decodeDataUriText(isBase64, data) {\n  const result = decodeURIComponent(data);\n  if (isBase64) {\n    return atob(result);\n  }\n  return result;\n}\n\nfunction decodeDataUriArrayBuffer(isBase64, data) {\n  const byteString = decodeDataUriText(isBase64, data);\n  const buffer = new ArrayBuffer(byteString.length);\n  const view = new Uint8Array(buffer);\n  for (let i = 0; i < byteString.length; i++) {\n    view[i] = byteString.charCodeAt(i);\n  }\n  return buffer;\n}\n\nfunction decodeDataUri(dataUriRegexResult, responseType) {\n  responseType = Core_defaultValue(responseType, \"\");\n  const mimeType = dataUriRegexResult[1];\n  const isBase64 = !!dataUriRegexResult[2];\n  const data = dataUriRegexResult[3];\n  let buffer;\n  let parser;\n\n  switch (responseType) {\n    case \"\":\n    case \"text\":\n      return decodeDataUriText(isBase64, data);\n    case \"arraybuffer\":\n      return decodeDataUriArrayBuffer(isBase64, data);\n    case \"blob\":\n      buffer = decodeDataUriArrayBuffer(isBase64, data);\n      return new Blob([buffer], {\n        type: mimeType,\n      });\n    case \"document\":\n      parser = new DOMParser();\n      return parser.parseFromString(\n        decodeDataUriText(isBase64, data),\n        mimeType\n      );\n    case \"json\":\n      return JSON.parse(decodeDataUriText(isBase64, data));\n    default:\n      //>>includeStart('debug', pragmas.debug);\n      throw new Core_DeveloperError(`Unhandled responseType: ${responseType}`);\n    //>>includeEnd('debug');\n  }\n}\n\n/**\n * Asynchronously loads the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. It's recommended that you use\n * the more specific functions eg. fetchJson, fetchBlob, etc.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.fetch()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetch = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"GET\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls fetch() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetch = function (options) {\n  const resource = new Resource(options);\n  return resource.fetch({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously deletes the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.delete()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.delete = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"DELETE\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls delete() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.data] Data that is posted with the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.delete = function (options) {\n  const resource = new Resource(options);\n  return resource.delete({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n    data: options.data,\n  });\n};\n\n/**\n * Asynchronously gets headers the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.head()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.head = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"HEAD\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls head() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.head = function (options) {\n  const resource = new Resource(options);\n  return resource.head({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously gets options the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.options()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.options = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"OPTIONS\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls options() on it.\n *\n * @param {String|Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.options = function (options) {\n  const resource = new Resource(options);\n  return resource.options({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously posts data to the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {Object} data Data that is posted with the resource.\n * @param {Object} [options] Object with the following properties:\n * @param {Object} [options.data] Data that is posted with the resource.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.post(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.post = function (data, options) {\n  Core_Check.defined(\"data\", data);\n\n  options = defaultClone(options, {});\n  options.method = \"POST\";\n  options.data = data;\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls post() on it.\n *\n * @param {Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} options.data Data that is posted with the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.post = function (options) {\n  const resource = new Resource(options);\n  return resource.post(options.data, {\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to post\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously puts data to the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {Object} data Data that is posted with the resource.\n * @param {Object} [options] Object with the following properties:\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.put(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.put = function (data, options) {\n  Core_Check.defined(\"data\", data);\n\n  options = defaultClone(options, {});\n  options.method = \"PUT\";\n  options.data = data;\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls put() on it.\n *\n * @param {Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} options.data Data that is posted with the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.put = function (options) {\n  const resource = new Resource(options);\n  return resource.put(options.data, {\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to post\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously patches data to the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {Object} data Data that is posted with the resource.\n * @param {Object} [options] Object with the following properties:\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.patch(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.patch = function (data, options) {\n  Core_Check.defined(\"data\", data);\n\n  options = defaultClone(options, {});\n  options.method = \"PATCH\";\n  options.data = data;\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls patch() on it.\n *\n * @param {Object} options A url or an object with the following properties\n * @param {String} options.url The url of the resource.\n * @param {Object} options.data Data that is posted with the resource.\n * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {Number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise.<*>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.patch = function (options) {\n  const resource = new Resource(options);\n  return resource.patch(options.data, {\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to post\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Contains implementations of functions that can be replaced for testing\n *\n * @private\n */\nResource._Implementations = {};\n\nResource._Implementations.loadImageElement = function (\n  url,\n  crossOrigin,\n  deferred\n) {\n  const image = new Image();\n\n  image.onload = function () {\n    // work-around a known issue with Firefox and dimensionless SVG, see:\n    //   - https://github.com/whatwg/html/issues/3510\n    //   - https://bugzilla.mozilla.org/show_bug.cgi?id=700533\n    if (\n      image.naturalWidth === 0 &&\n      image.naturalHeight === 0 &&\n      image.width === 0 &&\n      image.height === 0\n    ) {\n      // these values affect rasterization and will likely mar the content\n      // until Firefox takes a stance on the issue, marred content is better than no content\n      // Chromium uses a more refined heuristic about its choice given nil viewBox, and a better stance and solution is\n      // proposed later in the original issue thread:\n      //   - Chromium behavior: https://github.com/CesiumGS/cesium/issues/9188#issuecomment-704400825\n      //   - Cesium's stance/solve: https://github.com/CesiumGS/cesium/issues/9188#issuecomment-720645777\n      image.width = 300;\n      image.height = 150;\n    }\n    deferred.resolve(image);\n  };\n\n  image.onerror = function (e) {\n    deferred.reject(e);\n  };\n\n  if (crossOrigin) {\n    if (Core_TrustedServers.contains(url)) {\n      image.crossOrigin = \"use-credentials\";\n    } else {\n      image.crossOrigin = \"\";\n    }\n  }\n\n  image.src = url;\n};\n\nResource._Implementations.createImage = function (\n  request,\n  crossOrigin,\n  deferred,\n  flipY,\n  skipColorSpaceConversion,\n  preferImageBitmap\n) {\n  const url = request.url;\n  // Passing an Image to createImageBitmap will force it to run on the main thread\n  // since DOM elements don't exist on workers. We convert it to a blob so it's non-blocking.\n  // See:\n  //    https://bugzilla.mozilla.org/show_bug.cgi?id=1044102#c38\n  //    https://bugs.chromium.org/p/chromium/issues/detail?id=580202#c10\n  Resource.supportsImageBitmapOptions()\n    .then(function (supportsImageBitmap) {\n      // We can only use ImageBitmap if we can flip on decode.\n      // See: https://github.com/CesiumGS/cesium/pull/7579#issuecomment-466146898\n      if (!(supportsImageBitmap && preferImageBitmap)) {\n        Resource._Implementations.loadImageElement(url, crossOrigin, deferred);\n        return;\n      }\n      const responseType = \"blob\";\n      const method = \"GET\";\n      const xhrDeferred = Core_defer();\n      const xhr = Resource._Implementations.loadWithXhr(\n        url,\n        responseType,\n        method,\n        undefined,\n        undefined,\n        xhrDeferred,\n        undefined,\n        undefined,\n        undefined\n      );\n\n      if (Core_defined(xhr) && Core_defined(xhr.abort)) {\n        request.cancelFunction = function () {\n          xhr.abort();\n        };\n      }\n      return xhrDeferred.promise\n        .then(function (blob) {\n          if (!Core_defined(blob)) {\n            deferred.reject(\n              new Core_RuntimeError(\n                `Successfully retrieved ${url} but it contained no content.`\n              )\n            );\n            return;\n          }\n\n          return Resource.createImageBitmapFromBlob(blob, {\n            flipY: flipY,\n            premultiplyAlpha: false,\n            skipColorSpaceConversion: skipColorSpaceConversion,\n          });\n        })\n        .then(function (image) {\n          deferred.resolve(image);\n        });\n    })\n    .catch(function (e) {\n      deferred.reject(e);\n    });\n};\n\n/**\n * Wrapper for createImageBitmap\n *\n * @private\n */\nResource.createImageBitmapFromBlob = function (blob, options) {\n  Core_Check.defined(\"options\", options);\n  Core_Check.typeOf.bool(\"options.flipY\", options.flipY);\n  Core_Check.typeOf.bool(\"options.premultiplyAlpha\", options.premultiplyAlpha);\n  Core_Check.typeOf.bool(\n    \"options.skipColorSpaceConversion\",\n    options.skipColorSpaceConversion\n  );\n\n  return createImageBitmap(blob, {\n    imageOrientation: options.flipY ? \"flipY\" : \"none\",\n    premultiplyAlpha: options.premultiplyAlpha ? \"premultiply\" : \"none\",\n    colorSpaceConversion: options.skipColorSpaceConversion ? \"none\" : \"default\",\n  });\n};\n\nfunction decodeResponse(loadWithHttpResponse, responseType) {\n  switch (responseType) {\n    case \"text\":\n      return loadWithHttpResponse.toString(\"utf8\");\n    case \"json\":\n      return JSON.parse(loadWithHttpResponse.toString(\"utf8\"));\n    default:\n      return new Uint8Array(loadWithHttpResponse).buffer;\n  }\n}\n\nfunction loadWithHttpRequest(\n  url,\n  responseType,\n  method,\n  data,\n  headers,\n  deferred,\n  overrideMimeType\n) {\n  // Note: only the 'json' and 'text' responseTypes transforms the loaded buffer\n  let URL;\n  let zlib;\n  Promise.all([Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! url */ \"./node_modules/url/url.js\", 19)), __webpack_require__.e(/*! import() */ \"_a45b\").then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ \"?a45b\", 19))])\n    .then(([urlImport, zlibImport]) => {\n      URL = urlImport.parse(url);\n      zlib = zlibImport;\n\n      return URL.protocol === \"https:\" ? __webpack_require__.e(/*! import() */ \"_51ab\").then(__webpack_require__.t.bind(__webpack_require__, /*! https */ \"?51ab\", 19)) : __webpack_require__.e(/*! import() */ \"_a2d6\").then(__webpack_require__.t.bind(__webpack_require__, /*! http */ \"?a2d6\", 19));\n    })\n    .then((http) => {\n      const options = {\n        protocol: URL.protocol,\n        hostname: URL.hostname,\n        port: URL.port,\n        path: URL.path,\n        query: URL.query,\n        method: method,\n        headers: headers,\n      };\n      http\n        .request(options)\n        .on(\"response\", function (res) {\n          if (res.statusCode < 200 || res.statusCode >= 300) {\n            deferred.reject(\n              new Core_RequestErrorEvent(res.statusCode, res, res.headers)\n            );\n            return;\n          }\n\n          const chunkArray = [];\n          res.on(\"data\", function (chunk) {\n            chunkArray.push(chunk);\n          });\n\n          res.on(\"end\", function () {\n            // eslint-disable-next-line no-undef\n            const result = Buffer.concat(chunkArray);\n            if (res.headers[\"content-encoding\"] === \"gzip\") {\n              zlib.gunzip(result, function (error, resultUnzipped) {\n                if (error) {\n                  deferred.reject(\n                    new Core_RuntimeError(\"Error decompressing response.\")\n                  );\n                } else {\n                  deferred.resolve(\n                    decodeResponse(resultUnzipped, responseType)\n                  );\n                }\n              });\n            } else {\n              deferred.resolve(decodeResponse(result, responseType));\n            }\n          });\n        })\n        .on(\"error\", function (e) {\n          deferred.reject(new Core_RequestErrorEvent());\n        })\n        .end();\n    });\n}\n\nconst noXMLHttpRequest = typeof XMLHttpRequest === \"undefined\";\nResource._Implementations.loadWithXhr = function (\n  url,\n  responseType,\n  method,\n  data,\n  headers,\n  deferred,\n  overrideMimeType\n) {\n  const dataUriRegexResult = Resource_dataUriRegex.exec(url);\n  if (dataUriRegexResult !== null) {\n    deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));\n    return;\n  }\n\n  if (noXMLHttpRequest) {\n    loadWithHttpRequest(\n      url,\n      responseType,\n      method,\n      data,\n      headers,\n      deferred,\n      overrideMimeType\n    );\n    return;\n  }\n\n  const xhr = new XMLHttpRequest();\n\n  if (Core_TrustedServers.contains(url)) {\n    xhr.withCredentials = true;\n  }\n\n  xhr.open(method, url, true);\n\n  if (Core_defined(overrideMimeType) && Core_defined(xhr.overrideMimeType)) {\n    xhr.overrideMimeType(overrideMimeType);\n  }\n\n  if (Core_defined(headers)) {\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  }\n\n  if (Core_defined(responseType)) {\n    xhr.responseType = responseType;\n  }\n\n  // While non-standard, file protocol always returns a status of 0 on success\n  let localFile = false;\n  if (typeof url === \"string\") {\n    localFile =\n      url.indexOf(\"file://\") === 0 ||\n      (typeof window !== \"undefined\" && window.location.origin === \"file://\");\n  }\n\n  xhr.onload = function () {\n    if (\n      (xhr.status < 200 || xhr.status >= 300) &&\n      !(localFile && xhr.status === 0)\n    ) {\n      deferred.reject(\n        new Core_RequestErrorEvent(\n          xhr.status,\n          xhr.response,\n          xhr.getAllResponseHeaders()\n        )\n      );\n      return;\n    }\n\n    const response = xhr.response;\n    const browserResponseType = xhr.responseType;\n\n    if (method === \"HEAD\" || method === \"OPTIONS\") {\n      const responseHeaderString = xhr.getAllResponseHeaders();\n      const splitHeaders = responseHeaderString.trim().split(/[\\r\\n]+/);\n\n      const responseHeaders = {};\n      splitHeaders.forEach(function (line) {\n        const parts = line.split(\": \");\n        const header = parts.shift();\n        responseHeaders[header] = parts.join(\": \");\n      });\n\n      deferred.resolve(responseHeaders);\n      return;\n    }\n\n    //All modern browsers will go into either the first or second if block or last else block.\n    //Other code paths support older browsers that either do not support the supplied responseType\n    //or do not support the xhr.response property.\n    if (xhr.status === 204) {\n      // accept no content\n      deferred.resolve();\n    } else if (\n      Core_defined(response) &&\n      (!Core_defined(responseType) || browserResponseType === responseType)\n    ) {\n      deferred.resolve(response);\n    } else if (responseType === \"json\" && typeof response === \"string\") {\n      try {\n        deferred.resolve(JSON.parse(response));\n      } catch (e) {\n        deferred.reject(e);\n      }\n    } else if (\n      (browserResponseType === \"\" || browserResponseType === \"document\") &&\n      Core_defined(xhr.responseXML) &&\n      xhr.responseXML.hasChildNodes()\n    ) {\n      deferred.resolve(xhr.responseXML);\n    } else if (\n      (browserResponseType === \"\" || browserResponseType === \"text\") &&\n      Core_defined(xhr.responseText)\n    ) {\n      deferred.resolve(xhr.responseText);\n    } else {\n      deferred.reject(\n        new Core_RuntimeError(\"Invalid XMLHttpRequest response type.\")\n      );\n    }\n  };\n\n  xhr.onerror = function (e) {\n    deferred.reject(new Core_RequestErrorEvent());\n  };\n\n  xhr.send(data);\n\n  return xhr;\n};\n\nResource._Implementations.loadAndExecuteScript = function (\n  url,\n  functionName,\n  deferred\n) {\n  return Core_loadAndExecuteScript(url, functionName).catch(function (e) {\n    deferred.reject(e);\n  });\n};\n\n/**\n * The default implementations\n *\n * @private\n */\nResource._DefaultImplementations = {};\nResource._DefaultImplementations.createImage =\n  Resource._Implementations.createImage;\nResource._DefaultImplementations.loadWithXhr =\n  Resource._Implementations.loadWithXhr;\nResource._DefaultImplementations.loadAndExecuteScript =\n  Resource._Implementations.loadAndExecuteScript;\n\n/**\n * A resource instance initialized to the current browser location\n *\n * @type {Resource}\n * @constant\n */\nResource.DEFAULT = Object.freeze(\n  new Resource({\n    url:\n      typeof document === \"undefined\"\n        ? \"\"\n        : document.location.href.split(\"?\")[0],\n  })\n);\n\n/**\n * A function that returns the value of the property.\n * @callback Resource.RetryCallback\n *\n * @param {Resource} [resource] The resource that failed to load.\n * @param {Error} [error] The error that occurred during the loading of the resource.\n * @returns {Boolean|Promise<Boolean>} If true or a promise that resolved to true, the resource will be retried. Otherwise the failure will be returned.\n */\n/* harmony default export */ const Core_Resource = (Resource);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/EarthOrientationParameters.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n * Reference Frame (ITRF).\n *\n * @alias EarthOrientationParameters\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Resource|String} [options.url] The URL from which to obtain EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.  If options.data is specified, this parameter is\n *                 ignored.\n * @param {Object} [options.data] The actual EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.\n * @param {Boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @example\n * // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n * @example\n * // Loading the EOP data\n * const eop = new Cesium.EarthOrientationParameters({ url : 'Data/EOP.json' });\n * Cesium.Transforms.earthOrientationParameters = eop;\n *\n * @private\n */\nfunction EarthOrientationParameters(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n\n  this._dates = undefined;\n  this._samples = undefined;\n\n  this._dateColumn = -1;\n  this._xPoleWanderRadiansColumn = -1;\n  this._yPoleWanderRadiansColumn = -1;\n  this._ut1MinusUtcSecondsColumn = -1;\n  this._xCelestialPoleOffsetRadiansColumn = -1;\n  this._yCelestialPoleOffsetRadiansColumn = -1;\n  this._taiMinusUtcSecondsColumn = -1;\n\n  this._columnCount = 0;\n  this._lastIndex = -1;\n\n  this._downloadPromise = undefined;\n  this._dataError = undefined;\n\n  this._addNewLeapSeconds = Core_defaultValue(options.addNewLeapSeconds, true);\n\n  if (Core_defined(options.data)) {\n    // Use supplied EOP data.\n    onDataReady(this, options.data);\n  } else if (Core_defined(options.url)) {\n    const resource = Core_Resource.createIfNeeded(options.url);\n\n    // Download EOP data.\n    const that = this;\n    this._downloadPromise = resource\n      .fetchJson()\n      .then(function (eopData) {\n        onDataReady(that, eopData);\n      })\n      .catch(function () {\n        that._dataError = `An error occurred while retrieving the EOP data from the URL ${resource.url}.`;\n      });\n  } else {\n    // Use all zeros for EOP data.\n    onDataReady(this, {\n      columnNames: [\n        \"dateIso8601\",\n        \"modifiedJulianDateUtc\",\n        \"xPoleWanderRadians\",\n        \"yPoleWanderRadians\",\n        \"ut1MinusUtcSeconds\",\n        \"lengthOfDayCorrectionSeconds\",\n        \"xCelestialPoleOffsetRadians\",\n        \"yCelestialPoleOffsetRadians\",\n        \"taiMinusUtcSeconds\",\n      ],\n      samples: [],\n    });\n  }\n}\n\n/**\n * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n */\nEarthOrientationParameters.NONE = Object.freeze({\n  getPromiseToLoad: function () {\n    return Promise.resolve();\n  },\n  compute: function (date, result) {\n    if (!Core_defined(result)) {\n      result = new Core_EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n    } else {\n      result.xPoleWander = 0.0;\n      result.yPoleWander = 0.0;\n      result.xPoleOffset = 0.0;\n      result.yPoleOffset = 0.0;\n      result.ut1MinusUtc = 0.0;\n    }\n    return result;\n  },\n});\n\n/**\n * Gets a promise that, when resolved, indicates that the EOP data has been loaded and is\n * ready to use.\n *\n * @returns {Promise<void>} The promise.\n */\nEarthOrientationParameters.prototype.getPromiseToLoad = function () {\n  return Promise.resolve(this._downloadPromise);\n};\n\n/**\n * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n * If the EOP data has not yet been download, this method returns undefined.\n *\n * @param {JulianDate} date The date for each to evaluate the EOP.\n * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n *        If this parameter is undefined, a new instance is created and returned.\n * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n *          undefined if the data necessary to evaluate EOP at the date has not yet been\n *          downloaded.\n *\n * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n *\n * @see EarthOrientationParameters#getPromiseToLoad\n */\nEarthOrientationParameters.prototype.compute = function (date, result) {\n  // We cannot compute until the samples are available.\n  if (!Core_defined(this._samples)) {\n    if (Core_defined(this._dataError)) {\n      throw new Core_RuntimeError(this._dataError);\n    }\n\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    result = new Core_EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n  }\n\n  if (this._samples.length === 0) {\n    result.xPoleWander = 0.0;\n    result.yPoleWander = 0.0;\n    result.xPoleOffset = 0.0;\n    result.yPoleOffset = 0.0;\n    result.ut1MinusUtc = 0.0;\n    return result;\n  }\n\n  const dates = this._dates;\n  const lastIndex = this._lastIndex;\n\n  let before = 0;\n  let after = 0;\n  if (Core_defined(lastIndex)) {\n    const previousIndexDate = dates[lastIndex];\n    const nextIndexDate = dates[lastIndex + 1];\n    const isAfterPrevious = Core_JulianDate.lessThanOrEquals(\n      previousIndexDate,\n      date\n    );\n    const isAfterLastSample = !Core_defined(nextIndexDate);\n    const isBeforeNext =\n      isAfterLastSample || Core_JulianDate.greaterThanOrEquals(nextIndexDate, date);\n\n    if (isAfterPrevious && isBeforeNext) {\n      before = lastIndex;\n\n      if (!isAfterLastSample && nextIndexDate.equals(date)) {\n        ++before;\n      }\n      after = before + 1;\n\n      interpolate(this, dates, this._samples, date, before, after, result);\n      return result;\n    }\n  }\n\n  let index = Core_binarySearch(dates, date, Core_JulianDate.compare, this._dateColumn);\n  if (index >= 0) {\n    // If the next entry is the same date, use the later entry.  This way, if two entries\n    // describe the same moment, one before a leap second and the other after, then we will use\n    // the post-leap second data.\n    if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n      ++index;\n    }\n    before = index;\n    after = index;\n  } else {\n    after = ~index;\n    before = after - 1;\n\n    // Use the first entry if the date requested is before the beginning of the data.\n    if (before < 0) {\n      before = 0;\n    }\n  }\n\n  this._lastIndex = before;\n\n  interpolate(this, dates, this._samples, date, before, after, result);\n  return result;\n};\n\nfunction EarthOrientationParameters_compareLeapSecondDates(leapSecond, dateToFind) {\n  return Core_JulianDate.compare(leapSecond.julianDate, dateToFind);\n}\n\nfunction onDataReady(eop, eopData) {\n  if (!Core_defined(eopData.columnNames)) {\n    eop._dataError =\n      \"Error in loaded EOP data: The columnNames property is required.\";\n    return;\n  }\n\n  if (!Core_defined(eopData.samples)) {\n    eop._dataError =\n      \"Error in loaded EOP data: The samples property is required.\";\n    return;\n  }\n\n  const dateColumn = eopData.columnNames.indexOf(\"modifiedJulianDateUtc\");\n  const xPoleWanderRadiansColumn = eopData.columnNames.indexOf(\n    \"xPoleWanderRadians\"\n  );\n  const yPoleWanderRadiansColumn = eopData.columnNames.indexOf(\n    \"yPoleWanderRadians\"\n  );\n  const ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf(\n    \"ut1MinusUtcSeconds\"\n  );\n  const xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"xCelestialPoleOffsetRadians\"\n  );\n  const yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"yCelestialPoleOffsetRadians\"\n  );\n  const taiMinusUtcSecondsColumn = eopData.columnNames.indexOf(\n    \"taiMinusUtcSeconds\"\n  );\n\n  if (\n    dateColumn < 0 ||\n    xPoleWanderRadiansColumn < 0 ||\n    yPoleWanderRadiansColumn < 0 ||\n    ut1MinusUtcSecondsColumn < 0 ||\n    xCelestialPoleOffsetRadiansColumn < 0 ||\n    yCelestialPoleOffsetRadiansColumn < 0 ||\n    taiMinusUtcSecondsColumn < 0\n  ) {\n    eop._dataError =\n      \"Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns\";\n    return;\n  }\n\n  const samples = (eop._samples = eopData.samples);\n  const dates = (eop._dates = []);\n\n  eop._dateColumn = dateColumn;\n  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n\n  eop._columnCount = eopData.columnNames.length;\n  eop._lastIndex = undefined;\n\n  let lastTaiMinusUtc;\n\n  const addNewLeapSeconds = eop._addNewLeapSeconds;\n\n  // Convert the ISO8601 dates to JulianDates.\n  for (let i = 0, len = samples.length; i < len; i += eop._columnCount) {\n    const mjd = samples[i + dateColumn];\n    const taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n    const day = mjd + Core_TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n    const date = new Core_JulianDate(day, taiMinusUtc, Core_TimeStandard.TAI);\n    dates.push(date);\n\n    if (addNewLeapSeconds) {\n      if (taiMinusUtc !== lastTaiMinusUtc && Core_defined(lastTaiMinusUtc)) {\n        // We crossed a leap second boundary, so add the leap second\n        // if it does not already exist.\n        const leapSeconds = Core_JulianDate.leapSeconds;\n        const leapSecondIndex = Core_binarySearch(\n          leapSeconds,\n          date,\n          EarthOrientationParameters_compareLeapSecondDates\n        );\n        if (leapSecondIndex < 0) {\n          const leapSecond = new Core_LeapSecond(date, taiMinusUtc);\n          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n        }\n      }\n      lastTaiMinusUtc = taiMinusUtc;\n    }\n  }\n}\n\nfunction fillResultFromIndex(eop, samples, index, columnCount, result) {\n  const start = index * columnCount;\n  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n}\n\nfunction linearInterp(dx, y1, y2) {\n  return y1 + dx * (y2 - y1);\n}\n\nfunction interpolate(eop, dates, samples, date, before, after, result) {\n  const columnCount = eop._columnCount;\n\n  // First check the bounds on the EOP data\n  // If we are after the bounds of the data, return zeros.\n  // The 'before' index should never be less than zero.\n  if (after > dates.length - 1) {\n    result.xPoleWander = 0;\n    result.yPoleWander = 0;\n    result.xPoleOffset = 0;\n    result.yPoleOffset = 0;\n    result.ut1MinusUtc = 0;\n    return result;\n  }\n\n  const beforeDate = dates[before];\n  const afterDate = dates[after];\n  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n    fillResultFromIndex(eop, samples, before, columnCount, result);\n    return result;\n  } else if (date.equals(afterDate)) {\n    fillResultFromIndex(eop, samples, after, columnCount, result);\n    return result;\n  }\n\n  const factor =\n    Core_JulianDate.secondsDifference(date, beforeDate) /\n    Core_JulianDate.secondsDifference(afterDate, beforeDate);\n\n  const startBefore = before * columnCount;\n  const startAfter = after * columnCount;\n\n  // Handle UT1 leap second edge case\n  let beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n  let afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n\n  const offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n  if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n    // The absolute difference between the values is more than 0.5, so we may have\n    // crossed a leap second.  Check if this is the case and, if so, adjust the\n    // afterValue to account for the leap second.  This way, our interpolation will\n    // produce reasonable results.\n    const beforeTaiMinusUtc =\n      samples[startBefore + eop._taiMinusUtcSecondsColumn];\n    const afterTaiMinusUtc =\n      samples[startAfter + eop._taiMinusUtcSecondsColumn];\n    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n      if (afterDate.equals(date)) {\n        // If we are at the end of the leap second interval, take the second value\n        // Otherwise, the interpolation below will yield the wrong side of the\n        // discontinuity\n        // At the end of the leap second, we need to start accounting for the jump\n        beforeUt1MinusUtc = afterUt1MinusUtc;\n      } else {\n        // Otherwise, remove the leap second so that the interpolation is correct\n        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n      }\n    }\n  }\n\n  result.xPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._xPoleWanderRadiansColumn],\n    samples[startAfter + eop._xPoleWanderRadiansColumn]\n  );\n  result.yPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._yPoleWanderRadiansColumn],\n    samples[startAfter + eop._yPoleWanderRadiansColumn]\n  );\n  result.xPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]\n  );\n  result.yPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]\n  );\n  result.ut1MinusUtc = linearInterp(\n    factor,\n    beforeUt1MinusUtc,\n    afterUt1MinusUtc\n  );\n  return result;\n}\n/* harmony default export */ const Core_EarthOrientationParameters = (EarthOrientationParameters);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/HeadingPitchRoll.js\n\n\n\n\n\n/**\n * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n * @alias HeadingPitchRoll\n * @constructor\n *\n * @param {Number} [heading=0.0] The heading component in radians.\n * @param {Number} [pitch=0.0] The pitch component in radians.\n * @param {Number} [roll=0.0] The roll component in radians.\n */\nfunction HeadingPitchRoll(heading, pitch, roll) {\n  /**\n   * Gets or sets the heading.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.heading = Core_defaultValue(heading, 0.0);\n  /**\n   * Gets or sets the pitch.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.pitch = Core_defaultValue(pitch, 0.0);\n  /**\n   * Gets or sets the roll.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.roll = Core_defaultValue(roll, 0.0);\n}\n\n/**\n * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {Quaternion} quaternion The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.\n * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.\n */\nHeadingPitchRoll.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(quaternion)) {\n    throw new Core_DeveloperError(\"quaternion is required\");\n  }\n  //>>includeEnd('debug');\n  if (!Core_defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n  const test = 2 * (quaternion.w * quaternion.y - quaternion.z * quaternion.x);\n  const denominatorRoll =\n    1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);\n  const numeratorRoll =\n    2 * (quaternion.w * quaternion.x + quaternion.y * quaternion.z);\n  const denominatorHeading =\n    1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);\n  const numeratorHeading =\n    2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);\n  result.heading = -Math.atan2(numeratorHeading, denominatorHeading);\n  result.roll = Math.atan2(numeratorRoll, denominatorRoll);\n  result.pitch = -Core_Math.asinClamped(test);\n  return result;\n};\n\n/**\n * Returns a new HeadingPitchRoll instance from angles given in degrees.\n *\n * @param {Number} heading the heading in degrees\n * @param {Number} pitch the pitch in degrees\n * @param {Number} roll the heading in degrees\n * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.\n * @returns {HeadingPitchRoll} A new HeadingPitchRoll instance\n */\nHeadingPitchRoll.fromDegrees = function (heading, pitch, roll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(heading)) {\n    throw new Core_DeveloperError(\"heading is required\");\n  }\n  if (!Core_defined(pitch)) {\n    throw new Core_DeveloperError(\"pitch is required\");\n  }\n  if (!Core_defined(roll)) {\n    throw new Core_DeveloperError(\"roll is required\");\n  }\n  //>>includeEnd('debug');\n  if (!Core_defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n  result.heading = heading * Core_Math.RADIANS_PER_DEGREE;\n  result.pitch = pitch * Core_Math.RADIANS_PER_DEGREE;\n  result.roll = roll * Core_Math.RADIANS_PER_DEGREE;\n  return result;\n};\n\n/**\n * Duplicates a HeadingPitchRoll instance.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The HeadingPitchRoll to duplicate.\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)\n */\nHeadingPitchRoll.clone = function (headingPitchRoll, result) {\n  if (!Core_defined(headingPitchRoll)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new HeadingPitchRoll(\n      headingPitchRoll.heading,\n      headingPitchRoll.pitch,\n      headingPitchRoll.roll\n    );\n  }\n  result.heading = headingPitchRoll.heading;\n  result.pitch = headingPitchRoll.pitch;\n  result.roll = headingPitchRoll.roll;\n  return result;\n};\n\n/**\n * Compares the provided HeadingPitchRolls componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.\n * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nHeadingPitchRoll.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.heading === right.heading &&\n      left.pitch === right.pitch &&\n      left.roll === right.roll)\n  );\n};\n\n/**\n * Compares the provided HeadingPitchRolls componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.\n * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nHeadingPitchRoll.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Core_Math.equalsEpsilon(\n        left.heading,\n        right.heading,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.pitch,\n        right.pitch,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        left.roll,\n        right.roll,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * Duplicates this HeadingPitchRoll instance.\n *\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.\n */\nHeadingPitchRoll.prototype.clone = function (result) {\n  return HeadingPitchRoll.clone(this, result);\n};\n\n/**\n * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nHeadingPitchRoll.prototype.equals = function (right) {\n  return HeadingPitchRoll.equals(this, right);\n};\n\n/**\n * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nHeadingPitchRoll.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return HeadingPitchRoll.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.\n *\n * @returns {String} A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.\n */\nHeadingPitchRoll.prototype.toString = function () {\n  return `(${this.heading}, ${this.pitch}, ${this.roll})`;\n};\n/* harmony default export */ const Core_HeadingPitchRoll = (HeadingPitchRoll);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/buildModuleUrl.js\n\n\n\n\n\n/*global CESIUM_BASE_URL,define,require*/\n\nconst cesiumScriptRegex = /((?:.*\\/)|^)Cesium\\.js(?:\\?|\\#|$)/;\nfunction getBaseUrlFromCesiumScript() {\n  const scripts = document.getElementsByTagName(\"script\");\n  for (let i = 0, len = scripts.length; i < len; ++i) {\n    const src = scripts[i].getAttribute(\"src\");\n    const result = cesiumScriptRegex.exec(src);\n    if (result !== null) {\n      return result[1];\n    }\n  }\n  return undefined;\n}\n\nlet buildModuleUrl_a;\nfunction tryMakeAbsolute(url) {\n  if (typeof document === \"undefined\") {\n    //Node.js and Web Workers. In both cases, the URL will already be absolute.\n    return url;\n  }\n\n  if (!Core_defined(buildModuleUrl_a)) {\n    buildModuleUrl_a = document.createElement(\"a\");\n  }\n  buildModuleUrl_a.href = url;\n\n  // IE only absolutizes href on get, not set\n  // eslint-disable-next-line no-self-assign\n  buildModuleUrl_a.href = buildModuleUrl_a.href;\n  return buildModuleUrl_a.href;\n}\n\nlet baseResource;\nfunction getCesiumBaseUrl() {\n  if (Core_defined(baseResource)) {\n    return baseResource;\n  }\n\n  let baseUrlString;\n  if (typeof CESIUM_BASE_URL !== \"undefined\") {\n    baseUrlString = CESIUM_BASE_URL;\n  } else if (\n    typeof define === \"object\" &&\n    Core_defined(define.amd) &&\n    !define.amd.toUrlUndefined &&\n    Core_defined(require.toUrl)\n  ) {\n    baseUrlString = Core_getAbsoluteUri(\n      \"..\",\n      buildModuleUrl(\"Core/buildModuleUrl.js\")\n    );\n  } else {\n    baseUrlString = getBaseUrlFromCesiumScript();\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(baseUrlString)) {\n    throw new Core_DeveloperError(\n      \"Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  baseResource = new Core_Resource({\n    url: tryMakeAbsolute(baseUrlString),\n  });\n  baseResource.appendForwardSlash();\n\n  return baseResource;\n}\n\nfunction buildModuleUrlFromRequireToUrl(moduleID) {\n  //moduleID will be non-relative, so require it relative to this module, in Core.\n  return tryMakeAbsolute(require.toUrl(`../${moduleID}`));\n}\n\nfunction buildModuleUrlFromBaseUrl(moduleID) {\n  const resource = getCesiumBaseUrl().getDerivedResource({\n    url: moduleID,\n  });\n  return resource.url;\n}\n\nlet implementation;\n\n/**\n * Given a relative URL under the Cesium base URL, returns an absolute URL.\n * @function\n *\n * @param {String} relativeUrl The relative path.\n * @returns {String} The absolutely URL representation of the provided path.\n *\n * @example\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   imageryProvider: new Cesium.TileMapServiceImageryProvider({\n *   url: Cesium.buildModuleUrl(\"Assets/Textures/NaturalEarthII\"),\n *   }),\n *   baseLayerPicker: false,\n * });\n */\nfunction buildModuleUrl(relativeUrl) {\n  if (!Core_defined(implementation)) {\n    //select implementation\n    if (\n      typeof define === \"object\" &&\n      Core_defined(define.amd) &&\n      !define.amd.toUrlUndefined &&\n      Core_defined(require.toUrl)\n    ) {\n      implementation = buildModuleUrlFromRequireToUrl;\n    } else {\n      implementation = buildModuleUrlFromBaseUrl;\n    }\n  }\n\n  const url = implementation(relativeUrl);\n  return url;\n}\n\n// exposed for testing\nbuildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;\nbuildModuleUrl._buildModuleUrlFromBaseUrl = buildModuleUrlFromBaseUrl;\nbuildModuleUrl._clearBaseResource = function () {\n  baseResource = undefined;\n};\n\n/**\n * Sets the base URL for resolving modules.\n * @param {String} value The new base URL.\n */\nbuildModuleUrl.setBaseUrl = function (value) {\n  baseResource = Core_Resource.DEFAULT.getDerivedResource({\n    url: value,\n  });\n};\n\n/**\n * Gets the base URL for resolving modules.\n *\n * @function\n * @returns {String} The configured base URL\n */\nbuildModuleUrl.getCesiumBaseUrl = getCesiumBaseUrl;\n\n/* harmony default export */ const Core_buildModuleUrl = (buildModuleUrl);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Iau2006XysSample.js\n/**\n * An IAU 2006 XYS value sampled at a particular time.\n *\n * @alias Iau2006XysSample\n * @constructor\n *\n * @param {Number} x The X value.\n * @param {Number} y The Y value.\n * @param {Number} s The S value.\n *\n * @private\n */\nfunction Iau2006XysSample(x, y, s) {\n  /**\n   * The X value.\n   * @type {Number}\n   */\n  this.x = x;\n\n  /**\n   * The Y value.\n   * @type {Number}\n   */\n  this.y = y;\n\n  /**\n   * The S value.\n   * @type {Number}\n   */\n  this.s = s;\n}\n/* harmony default export */ const Core_Iau2006XysSample = (Iau2006XysSample);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Iau2006XysData.js\n\n\n\n\n\n\n\n\n/**\n * A set of IAU2006 XYS data that is used to evaluate the transformation between the International\n * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).\n *\n * @alias Iau2006XysData\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Resource|String} [options.xysFileUrlTemplate='Assets/IAU2006_XYS/IAU2006_XYS_{0}.json'] A template URL for obtaining the XYS data.  In the template,\n *                 `{0}` will be replaced with the file index.\n * @param {Number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.\n * @param {Number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the\n *                 first XYS sample.\n * @param {Number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.\n * @param {Number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.\n * @param {Number} [options.totalSamples=27426] The total number of samples in all XYS files.\n *\n * @private\n */\nfunction Iau2006XysData(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n\n  this._xysFileUrlTemplate = Core_Resource.createIfNeeded(\n    options.xysFileUrlTemplate\n  );\n  this._interpolationOrder = Core_defaultValue(options.interpolationOrder, 9);\n  this._sampleZeroJulianEphemerisDate = Core_defaultValue(\n    options.sampleZeroJulianEphemerisDate,\n    2442396.5\n  );\n  this._sampleZeroDateTT = new Core_JulianDate(\n    this._sampleZeroJulianEphemerisDate,\n    0.0,\n    Core_TimeStandard.TAI\n  );\n  this._stepSizeDays = Core_defaultValue(options.stepSizeDays, 1.0);\n  this._samplesPerXysFile = Core_defaultValue(options.samplesPerXysFile, 1000);\n  this._totalSamples = Core_defaultValue(options.totalSamples, 27426);\n  this._samples = new Array(this._totalSamples * 3);\n  this._chunkDownloadsInProgress = [];\n\n  const order = this._interpolationOrder;\n\n  // Compute denominators and X values for interpolation.\n  const denom = (this._denominators = new Array(order + 1));\n  const xTable = (this._xTable = new Array(order + 1));\n\n  const stepN = Math.pow(this._stepSizeDays, order);\n\n  for (let i = 0; i <= order; ++i) {\n    denom[i] = stepN;\n    xTable[i] = i * this._stepSizeDays;\n\n    for (let j = 0; j <= order; ++j) {\n      if (j !== i) {\n        denom[i] *= i - j;\n      }\n    }\n\n    denom[i] = 1.0 / denom[i];\n  }\n\n  // Allocate scratch arrays for interpolation.\n  this._work = new Array(order + 1);\n  this._coef = new Array(order + 1);\n}\n\nconst julianDateScratch = new Core_JulianDate(0, 0.0, Core_TimeStandard.TAI);\n\nfunction getDaysSinceEpoch(xys, dayTT, secondTT) {\n  const dateTT = julianDateScratch;\n  dateTT.dayNumber = dayTT;\n  dateTT.secondsOfDay = secondTT;\n  return Core_JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);\n}\n\n/**\n * Preloads XYS data for a specified date range.\n *\n * @param {Number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} stopDayTT The Julian day number of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the requested interval has been\n *                    preloaded.\n */\nIau2006XysData.prototype.preload = function (\n  startDayTT,\n  startSecondTT,\n  stopDayTT,\n  stopSecondTT\n) {\n  const startDaysSinceEpoch = getDaysSinceEpoch(\n    this,\n    startDayTT,\n    startSecondTT\n  );\n  const stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);\n\n  let startIndex =\n    (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    0;\n  if (startIndex < 0) {\n    startIndex = 0;\n  }\n\n  let stopIndex =\n    (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    (0 + this._interpolationOrder);\n  if (stopIndex >= this._totalSamples) {\n    stopIndex = this._totalSamples - 1;\n  }\n\n  const startChunk = (startIndex / this._samplesPerXysFile) | 0;\n  const stopChunk = (stopIndex / this._samplesPerXysFile) | 0;\n\n  const promises = [];\n  for (let i = startChunk; i <= stopChunk; ++i) {\n    promises.push(requestXysChunk(this, i));\n  }\n\n  return Promise.all(promises);\n};\n\n/**\n * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,\n * this method will return undefined.\n *\n * @param {Number} dayTT The Julian day number for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter\n *                           is undefined, a new instance is allocated and returned.\n * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this\n *                             computation has not yet been downloaded.\n *\n * @see Iau2006XysData#preload\n */\nIau2006XysData.prototype.computeXysRadians = function (\n  dayTT,\n  secondTT,\n  result\n) {\n  const daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);\n  if (daysSinceEpoch < 0.0) {\n    // Can't evaluate prior to the epoch of the data.\n    return undefined;\n  }\n\n  const centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;\n  if (centerIndex >= this._totalSamples) {\n    // Can't evaluate after the last sample in the data.\n    return undefined;\n  }\n\n  const degree = this._interpolationOrder;\n\n  let firstIndex = centerIndex - ((degree / 2) | 0);\n  if (firstIndex < 0) {\n    firstIndex = 0;\n  }\n  let lastIndex = firstIndex + degree;\n  if (lastIndex >= this._totalSamples) {\n    lastIndex = this._totalSamples - 1;\n    firstIndex = lastIndex - degree;\n    if (firstIndex < 0) {\n      firstIndex = 0;\n    }\n  }\n\n  // Are all the samples we need present?\n  // We can assume so if the first and last are present\n  let isDataMissing = false;\n  const samples = this._samples;\n  if (!Core_defined(samples[firstIndex * 3])) {\n    requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (!Core_defined(samples[lastIndex * 3])) {\n    requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (isDataMissing) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    result = new Core_Iau2006XysSample(0.0, 0.0, 0.0);\n  } else {\n    result.x = 0.0;\n    result.y = 0.0;\n    result.s = 0.0;\n  }\n\n  const x = daysSinceEpoch - firstIndex * this._stepSizeDays;\n\n  const work = this._work;\n  const denom = this._denominators;\n  const coef = this._coef;\n  const xTable = this._xTable;\n\n  let i, j;\n  for (i = 0; i <= degree; ++i) {\n    work[i] = x - xTable[i];\n  }\n\n  for (i = 0; i <= degree; ++i) {\n    coef[i] = 1.0;\n\n    for (j = 0; j <= degree; ++j) {\n      if (j !== i) {\n        coef[i] *= work[j];\n      }\n    }\n\n    coef[i] *= denom[i];\n\n    let sampleIndex = (firstIndex + i) * 3;\n    result.x += coef[i] * samples[sampleIndex++];\n    result.y += coef[i] * samples[sampleIndex++];\n    result.s += coef[i] * samples[sampleIndex];\n  }\n\n  return result;\n};\n\nfunction requestXysChunk(xysData, chunkIndex) {\n  if (xysData._chunkDownloadsInProgress[chunkIndex]) {\n    // Chunk has already been requested.\n    return xysData._chunkDownloadsInProgress[chunkIndex];\n  }\n\n  let chunkUrl;\n  const xysFileUrlTemplate = xysData._xysFileUrlTemplate;\n  if (Core_defined(xysFileUrlTemplate)) {\n    chunkUrl = xysFileUrlTemplate.getDerivedResource({\n      templateValues: {\n        0: chunkIndex,\n      },\n    });\n  } else {\n    chunkUrl = new Core_Resource({\n      url: Core_buildModuleUrl(`Assets/IAU2006_XYS/IAU2006_XYS_${chunkIndex}.json`),\n    });\n  }\n\n  const promise = chunkUrl.fetchJson().then(function (chunk) {\n    xysData._chunkDownloadsInProgress[chunkIndex] = false;\n\n    const samples = xysData._samples;\n    const newSamples = chunk.samples;\n    const startIndex = chunkIndex * xysData._samplesPerXysFile * 3;\n\n    for (let i = 0, len = newSamples.length; i < len; ++i) {\n      samples[startIndex + i] = newSamples[i];\n    }\n  });\n  xysData._chunkDownloadsInProgress[chunkIndex] = promise;\n\n  return promise;\n}\n/* harmony default export */ const Core_Iau2006XysData = (Iau2006XysData);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Fullscreen.js\n\n\nlet _supportsFullscreen;\nconst _names = {\n  requestFullscreen: undefined,\n  exitFullscreen: undefined,\n  fullscreenEnabled: undefined,\n  fullscreenElement: undefined,\n  fullscreenchange: undefined,\n  fullscreenerror: undefined,\n};\n\n/**\n * Browser-independent functions for working with the standard fullscreen API.\n *\n * @namespace Fullscreen\n *\n * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n */\nconst Fullscreen = {};\n\nObject.defineProperties(Fullscreen, {\n  /**\n   * The element that is currently fullscreen, if any.  To simply check if the\n   * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.\n   * @memberof Fullscreen\n   * @type {Object}\n   * @readonly\n   */\n  element: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return document[_names.fullscreenElement];\n    },\n  },\n\n  /**\n   * The name of the event on the document that is fired when fullscreen is\n   * entered or exited.  This event name is intended for use with addEventListener.\n   * In your event handler, to determine if the browser is in fullscreen mode or not,\n   * use {@link Fullscreen#fullscreen}.\n   * @memberof Fullscreen\n   * @type {String}\n   * @readonly\n   */\n  changeEventName: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return _names.fullscreenchange;\n    },\n  },\n\n  /**\n   * The name of the event that is fired when a fullscreen error\n   * occurs.  This event name is intended for use with addEventListener.\n   * @memberof Fullscreen\n   * @type {String}\n   * @readonly\n   */\n  errorEventName: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return _names.fullscreenerror;\n    },\n  },\n\n  /**\n   * Determine whether the browser will allow an element to be made fullscreen, or not.\n   * For example, by default, iframes cannot go fullscreen unless the containing page\n   * adds an \"allowfullscreen\" attribute (or prefixed equivalent).\n   * @memberof Fullscreen\n   * @type {Boolean}\n   * @readonly\n   */\n  enabled: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return document[_names.fullscreenEnabled];\n    },\n  },\n\n  /**\n   * Determines if the browser is currently in fullscreen mode.\n   * @memberof Fullscreen\n   * @type {Boolean}\n   * @readonly\n   */\n  fullscreen: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return Fullscreen.element !== null;\n    },\n  },\n});\n\n/**\n * Detects whether the browser supports the standard fullscreen API.\n *\n * @returns {Boolean} <code>true</code> if the browser supports the standard fullscreen API,\n * <code>false</code> otherwise.\n */\nFullscreen.supportsFullscreen = function () {\n  if (Core_defined(_supportsFullscreen)) {\n    return _supportsFullscreen;\n  }\n\n  _supportsFullscreen = false;\n\n  const body = document.body;\n  if (typeof body.requestFullscreen === \"function\") {\n    // go with the unprefixed, standard set of names\n    _names.requestFullscreen = \"requestFullscreen\";\n    _names.exitFullscreen = \"exitFullscreen\";\n    _names.fullscreenEnabled = \"fullscreenEnabled\";\n    _names.fullscreenElement = \"fullscreenElement\";\n    _names.fullscreenchange = \"fullscreenchange\";\n    _names.fullscreenerror = \"fullscreenerror\";\n    _supportsFullscreen = true;\n    return _supportsFullscreen;\n  }\n\n  //check for the correct combination of prefix plus the various names that browsers use\n  const prefixes = [\"webkit\", \"moz\", \"o\", \"ms\", \"khtml\"];\n  let name;\n  for (let i = 0, len = prefixes.length; i < len; ++i) {\n    const prefix = prefixes[i];\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}RequestFullscreen`;\n    if (typeof body[name] === \"function\") {\n      _names.requestFullscreen = name;\n      _supportsFullscreen = true;\n    } else {\n      name = `${prefix}RequestFullScreen`;\n      if (typeof body[name] === \"function\") {\n        _names.requestFullscreen = name;\n        _supportsFullscreen = true;\n      }\n    }\n\n    // disagreement about whether it's \"exit\" as per spec, or \"cancel\"\n    name = `${prefix}ExitFullscreen`;\n    if (typeof document[name] === \"function\") {\n      _names.exitFullscreen = name;\n    } else {\n      name = `${prefix}CancelFullScreen`;\n      if (typeof document[name] === \"function\") {\n        _names.exitFullscreen = name;\n      }\n    }\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}FullscreenEnabled`;\n    if (document[name] !== undefined) {\n      _names.fullscreenEnabled = name;\n    } else {\n      name = `${prefix}FullScreenEnabled`;\n      if (document[name] !== undefined) {\n        _names.fullscreenEnabled = name;\n      }\n    }\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}FullscreenElement`;\n    if (document[name] !== undefined) {\n      _names.fullscreenElement = name;\n    } else {\n      name = `${prefix}FullScreenElement`;\n      if (document[name] !== undefined) {\n        _names.fullscreenElement = name;\n      }\n    }\n\n    // thankfully, event names are all lowercase per spec\n    name = `${prefix}fullscreenchange`;\n    // event names do not have 'on' in the front, but the property on the document does\n    if (document[`on${name}`] !== undefined) {\n      //except on IE\n      if (prefix === \"ms\") {\n        name = \"MSFullscreenChange\";\n      }\n      _names.fullscreenchange = name;\n    }\n\n    name = `${prefix}fullscreenerror`;\n    if (document[`on${name}`] !== undefined) {\n      //except on IE\n      if (prefix === \"ms\") {\n        name = \"MSFullscreenError\";\n      }\n      _names.fullscreenerror = name;\n    }\n  }\n\n  return _supportsFullscreen;\n};\n\n/**\n * Asynchronously requests the browser to enter fullscreen mode on the given element.\n * If fullscreen mode is not supported by the browser, does nothing.\n *\n * @param {Object} element The HTML element which will be placed into fullscreen mode.\n * @param {Object} [vrDevice] The HMDVRDevice device.\n *\n * @example\n * // Put the entire page into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(document.body)\n *\n * // Place only the Cesium canvas into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(scene.canvas)\n */\nFullscreen.requestFullscreen = function (element, vrDevice) {\n  if (!Fullscreen.supportsFullscreen()) {\n    return;\n  }\n\n  element[_names.requestFullscreen]({ vrDisplay: vrDevice });\n};\n\n/**\n * Asynchronously exits fullscreen mode.  If the browser is not currently\n * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.\n */\nFullscreen.exitFullscreen = function () {\n  if (!Fullscreen.supportsFullscreen()) {\n    return;\n  }\n\n  document[_names.exitFullscreen]();\n};\n\n//For unit tests\nFullscreen._names = _names;\n/* harmony default export */ const Core_Fullscreen = (Fullscreen);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/FeatureDetection.js\n\n\n\n\n\nlet theNavigator;\nif (typeof navigator !== \"undefined\") {\n  theNavigator = navigator;\n} else {\n  theNavigator = {};\n}\n\nfunction extractVersion(versionString) {\n  const parts = versionString.split(\".\");\n  for (let i = 0, len = parts.length; i < len; ++i) {\n    parts[i] = parseInt(parts[i], 10);\n  }\n  return parts;\n}\n\nlet isChromeResult;\nlet chromeVersionResult;\nfunction isChrome() {\n  if (!Core_defined(isChromeResult)) {\n    isChromeResult = false;\n    // Edge contains Chrome in the user agent too\n    if (!isEdge()) {\n      const fields = / Chrome\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isChromeResult = true;\n        chromeVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n\n  return isChromeResult;\n}\n\nfunction chromeVersion() {\n  return isChrome() && chromeVersionResult;\n}\n\nlet isSafariResult;\nlet safariVersionResult;\nfunction isSafari() {\n  if (!Core_defined(isSafariResult)) {\n    isSafariResult = false;\n\n    // Chrome and Edge contain Safari in the user agent too\n    if (\n      !isChrome() &&\n      !isEdge() &&\n      / Safari\\/[\\.0-9]+/.test(theNavigator.userAgent)\n    ) {\n      const fields = / Version\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isSafariResult = true;\n        safariVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n\n  return isSafariResult;\n}\n\nfunction safariVersion() {\n  return isSafari() && safariVersionResult;\n}\n\nlet isWebkitResult;\nlet webkitVersionResult;\nfunction isWebkit() {\n  if (!Core_defined(isWebkitResult)) {\n    isWebkitResult = false;\n\n    const fields = / AppleWebKit\\/([\\.0-9]+)(\\+?)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isWebkitResult = true;\n      webkitVersionResult = extractVersion(fields[1]);\n      webkitVersionResult.isNightly = !!fields[2];\n    }\n  }\n\n  return isWebkitResult;\n}\n\nfunction webkitVersion() {\n  return isWebkit() && webkitVersionResult;\n}\n\nlet isInternetExplorerResult;\nlet internetExplorerVersionResult;\nfunction isInternetExplorer() {\n  if (!Core_defined(isInternetExplorerResult)) {\n    isInternetExplorerResult = false;\n\n    let fields;\n    if (theNavigator.appName === \"Microsoft Internet Explorer\") {\n      fields = /MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isInternetExplorerResult = true;\n        internetExplorerVersionResult = extractVersion(fields[1]);\n      }\n    } else if (theNavigator.appName === \"Netscape\") {\n      fields = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(\n        theNavigator.userAgent\n      );\n      if (fields !== null) {\n        isInternetExplorerResult = true;\n        internetExplorerVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n  return isInternetExplorerResult;\n}\n\nfunction internetExplorerVersion() {\n  return isInternetExplorer() && internetExplorerVersionResult;\n}\n\nlet isEdgeResult;\nlet edgeVersionResult;\nfunction isEdge() {\n  if (!Core_defined(isEdgeResult)) {\n    isEdgeResult = false;\n    const fields = / Edg\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isEdgeResult = true;\n      edgeVersionResult = extractVersion(fields[1]);\n    }\n  }\n  return isEdgeResult;\n}\n\nfunction edgeVersion() {\n  return isEdge() && edgeVersionResult;\n}\n\nlet isFirefoxResult;\nlet firefoxVersionResult;\nfunction isFirefox() {\n  if (!Core_defined(isFirefoxResult)) {\n    isFirefoxResult = false;\n\n    const fields = /Firefox\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isFirefoxResult = true;\n      firefoxVersionResult = extractVersion(fields[1]);\n    }\n  }\n  return isFirefoxResult;\n}\n\nlet isWindowsResult;\nfunction isWindows() {\n  if (!Core_defined(isWindowsResult)) {\n    isWindowsResult = /Windows/i.test(theNavigator.appVersion);\n  }\n  return isWindowsResult;\n}\n\nlet isIPadOrIOSResult;\nfunction isIPadOrIOS() {\n  if (!Core_defined(isIPadOrIOSResult)) {\n    isIPadOrIOSResult =\n      navigator.platform === \"iPhone\" ||\n      navigator.platform === \"iPod\" ||\n      navigator.platform === \"iPad\";\n  }\n\n  return isIPadOrIOSResult;\n}\n\nfunction firefoxVersion() {\n  return isFirefox() && firefoxVersionResult;\n}\n\nlet hasPointerEvents;\nfunction supportsPointerEvents() {\n  if (!Core_defined(hasPointerEvents)) {\n    //While navigator.pointerEnabled is deprecated in the W3C specification\n    //we still need to use it if it exists in order to support browsers\n    //that rely on it, such as the Windows WebBrowser control which defines\n    //PointerEvent but sets navigator.pointerEnabled to false.\n\n    //Firefox disabled because of https://github.com/CesiumGS/cesium/issues/6372\n    hasPointerEvents =\n      !isFirefox() &&\n      typeof PointerEvent !== \"undefined\" &&\n      (!Core_defined(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);\n  }\n  return hasPointerEvents;\n}\n\nlet imageRenderingValueResult;\nlet supportsImageRenderingPixelatedResult;\nfunction supportsImageRenderingPixelated() {\n  if (!Core_defined(supportsImageRenderingPixelatedResult)) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\n      \"style\",\n      \"image-rendering: -moz-crisp-edges;\" + \"image-rendering: pixelated;\"\n    );\n    //canvas.style.imageRendering will be undefined, null or an empty string on unsupported browsers.\n    const tmp = canvas.style.imageRendering;\n    supportsImageRenderingPixelatedResult = Core_defined(tmp) && tmp !== \"\";\n    if (supportsImageRenderingPixelatedResult) {\n      imageRenderingValueResult = tmp;\n    }\n  }\n  return supportsImageRenderingPixelatedResult;\n}\n\nfunction imageRenderingValue() {\n  return supportsImageRenderingPixelated()\n    ? imageRenderingValueResult\n    : undefined;\n}\n\nfunction supportsWebP() {\n  //>>includeStart('debug', pragmas.debug);\n  if (!supportsWebP.initialized) {\n    throw new Core_DeveloperError(\n      \"You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP\"\n    );\n  }\n  //>>includeEnd('debug');\n  return supportsWebP._result;\n}\nsupportsWebP._promise = undefined;\nsupportsWebP._result = undefined;\nsupportsWebP.initialize = function () {\n  // From https://developers.google.com/speed/webp/faq#how_can_i_detect_browser_support_for_webp\n  if (Core_defined(supportsWebP._promise)) {\n    return supportsWebP._promise;\n  }\n\n  supportsWebP._promise = new Promise((resolve) => {\n    const image = new Image();\n    image.onload = function () {\n      supportsWebP._result = image.width > 0 && image.height > 0;\n      resolve(supportsWebP._result);\n    };\n\n    image.onerror = function () {\n      supportsWebP._result = false;\n      resolve(supportsWebP._result);\n    };\n    image.src =\n      \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n  });\n\n  return supportsWebP._promise;\n};\nObject.defineProperties(supportsWebP, {\n  initialized: {\n    get: function () {\n      return Core_defined(supportsWebP._result);\n    },\n  },\n});\n\nconst typedArrayTypes = [];\nif (typeof ArrayBuffer !== \"undefined\") {\n  typedArrayTypes.push(\n    Int8Array,\n    Uint8Array,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array\n  );\n\n  if (typeof Uint8ClampedArray !== \"undefined\") {\n    typedArrayTypes.push(Uint8ClampedArray);\n  }\n\n  if (typeof Uint8ClampedArray !== \"undefined\") {\n    typedArrayTypes.push(Uint8ClampedArray);\n  }\n\n  if (typeof BigInt64Array !== \"undefined\") {\n    // eslint-disable-next-line no-undef\n    typedArrayTypes.push(BigInt64Array);\n  }\n\n  if (typeof BigUint64Array !== \"undefined\") {\n    // eslint-disable-next-line no-undef\n    typedArrayTypes.push(BigUint64Array);\n  }\n}\n\n/**\n * A set of functions to detect whether the current browser supports\n * various features.\n *\n * @namespace FeatureDetection\n */\nconst FeatureDetection = {\n  isChrome: isChrome,\n  chromeVersion: chromeVersion,\n  isSafari: isSafari,\n  safariVersion: safariVersion,\n  isWebkit: isWebkit,\n  webkitVersion: webkitVersion,\n  isInternetExplorer: isInternetExplorer,\n  internetExplorerVersion: internetExplorerVersion,\n  isEdge: isEdge,\n  edgeVersion: edgeVersion,\n  isFirefox: isFirefox,\n  firefoxVersion: firefoxVersion,\n  isWindows: isWindows,\n  isIPadOrIOS: isIPadOrIOS,\n  hardwareConcurrency: Core_defaultValue(theNavigator.hardwareConcurrency, 3),\n  supportsPointerEvents: supportsPointerEvents,\n  supportsImageRenderingPixelated: supportsImageRenderingPixelated,\n  supportsWebP: supportsWebP,\n  imageRenderingValue: imageRenderingValue,\n  typedArrayTypes: typedArrayTypes,\n};\n\n/**\n * Detects whether the current browser supports Basis Universal textures and the web assembly modules needed to transcode them.\n *\n * @param {Scene} scene\n * @returns {Boolean} true if the browser supports web assembly modules and the scene supports Basis Universal textures, false if not.\n */\nFeatureDetection.supportsBasis = function (scene) {\n  return FeatureDetection.supportsWebAssembly() && scene.context.supportsBasis;\n};\n\n/**\n * Detects whether the current browser supports the full screen standard.\n *\n * @returns {Boolean} true if the browser supports the full screen standard, false if not.\n *\n * @see Fullscreen\n * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n */\nFeatureDetection.supportsFullscreen = function () {\n  return Core_Fullscreen.supportsFullscreen();\n};\n\n/**\n * Detects whether the current browser supports typed arrays.\n *\n * @returns {Boolean} true if the browser supports typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsTypedArrays = function () {\n  return typeof ArrayBuffer !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigInt64Array typed arrays.\n *\n * @returns {Boolean} true if the browser supports BigInt64Array typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsBigInt64Array = function () {\n  return typeof BigInt64Array !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigUint64Array typed arrays.\n *\n * @returns {Boolean} true if the browser supports BigUint64Array typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsBigUint64Array = function () {\n  return typeof BigUint64Array !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigInt.\n *\n * @returns {Boolean} true if the browser supports BigInt, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-bigint-objects|BigInt Specification}\n */\nFeatureDetection.supportsBigInt = function () {\n  return typeof BigInt !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports Web Workers.\n *\n * @returns {Boolean} true if the browsers supports Web Workers, false if not.\n *\n * @see {@link http://www.w3.org/TR/workers/}\n */\nFeatureDetection.supportsWebWorkers = function () {\n  return typeof Worker !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports Web Assembly.\n *\n * @returns {Boolean} true if the browsers supports Web Assembly, false if not.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/WebAssembly}\n */\nFeatureDetection.supportsWebAssembly = function () {\n  return typeof WebAssembly !== \"undefined\";\n};\n/* harmony default export */ const Core_FeatureDetection = (FeatureDetection);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Quaternion.js\n\n\n\n\n\n\n\n\n/**\n * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n * @alias Quaternion\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see PackableForInterpolation\n */\nfunction Quaternion(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = Core_defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = Core_defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = Core_defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = Core_defaultValue(w, 0.0);\n}\n\nlet fromAxisAngleScratch = new Core_Cartesian3();\n\n/**\n * Computes a quaternion representing a rotation around an axis.\n *\n * @param {Cartesian3} axis The axis of rotation.\n * @param {Number} angle The angle in radians to rotate around the axis.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.fromAxisAngle = function (axis, angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"axis\", axis);\n  Core_Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const halfAngle = angle / 2.0;\n  const s = Math.sin(halfAngle);\n  fromAxisAngleScratch = Core_Cartesian3.normalize(axis, fromAxisAngleScratch);\n\n  const x = fromAxisAngleScratch.x * s;\n  const y = fromAxisAngleScratch.y * s;\n  const z = fromAxisAngleScratch.z * s;\n  const w = Math.cos(halfAngle);\n  if (!Core_defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst fromRotationMatrixNext = [1, 2, 0];\nconst fromRotationMatrixQuat = new Array(3);\n/**\n * Computes a Quaternion from the provided Matrix3 instance.\n *\n * @param {Matrix3} matrix The rotation matrix.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n *\n * @see Matrix3.fromQuaternion\n */\nQuaternion.fromRotationMatrix = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  let root;\n  let x;\n  let y;\n  let z;\n  let w;\n\n  const m00 = matrix[Core_Matrix3.COLUMN0ROW0];\n  const m11 = matrix[Core_Matrix3.COLUMN1ROW1];\n  const m22 = matrix[Core_Matrix3.COLUMN2ROW2];\n  const trace = m00 + m11 + m22;\n\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    root = Math.sqrt(trace + 1.0); // 2w\n    w = 0.5 * root;\n    root = 0.5 / root; // 1/(4w)\n\n    x = (matrix[Core_Matrix3.COLUMN1ROW2] - matrix[Core_Matrix3.COLUMN2ROW1]) * root;\n    y = (matrix[Core_Matrix3.COLUMN2ROW0] - matrix[Core_Matrix3.COLUMN0ROW2]) * root;\n    z = (matrix[Core_Matrix3.COLUMN0ROW1] - matrix[Core_Matrix3.COLUMN1ROW0]) * root;\n  } else {\n    // |w| <= 1/2\n    const next = fromRotationMatrixNext;\n\n    let i = 0;\n    if (m11 > m00) {\n      i = 1;\n    }\n    if (m22 > m00 && m22 > m11) {\n      i = 2;\n    }\n    const j = next[i];\n    const k = next[j];\n\n    root = Math.sqrt(\n      matrix[Core_Matrix3.getElementIndex(i, i)] -\n        matrix[Core_Matrix3.getElementIndex(j, j)] -\n        matrix[Core_Matrix3.getElementIndex(k, k)] +\n        1.0\n    );\n\n    const quat = fromRotationMatrixQuat;\n    quat[i] = 0.5 * root;\n    root = 0.5 / root;\n    w =\n      (matrix[Core_Matrix3.getElementIndex(k, j)] -\n        matrix[Core_Matrix3.getElementIndex(j, k)]) *\n      root;\n    quat[j] =\n      (matrix[Core_Matrix3.getElementIndex(j, i)] +\n        matrix[Core_Matrix3.getElementIndex(i, j)]) *\n      root;\n    quat[k] =\n      (matrix[Core_Matrix3.getElementIndex(k, i)] +\n        matrix[Core_Matrix3.getElementIndex(i, k)]) *\n      root;\n\n    x = -quat[0];\n    y = -quat[1];\n    z = -quat[2];\n  }\n\n  if (!Core_defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst scratchHPRQuaternion = new Quaternion();\nlet scratchHeadingQuaternion = new Quaternion();\nlet scratchPitchQuaternion = new Quaternion();\nlet scratchRollQuaternion = new Quaternion();\n\n/**\n * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n */\nQuaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  scratchRollQuaternion = Quaternion.fromAxisAngle(\n    Core_Cartesian3.UNIT_X,\n    headingPitchRoll.roll,\n    scratchHPRQuaternion\n  );\n  scratchPitchQuaternion = Quaternion.fromAxisAngle(\n    Core_Cartesian3.UNIT_Y,\n    -headingPitchRoll.pitch,\n    result\n  );\n  result = Quaternion.multiply(\n    scratchPitchQuaternion,\n    scratchRollQuaternion,\n    scratchPitchQuaternion\n  );\n  scratchHeadingQuaternion = Quaternion.fromAxisAngle(\n    Core_Cartesian3.UNIT_Z,\n    -headingPitchRoll.heading,\n    scratchHPRQuaternion\n  );\n  return Quaternion.multiply(scratchHeadingQuaternion, result, result);\n};\n\nconst sampledQuaternionAxis = new Core_Cartesian3();\nconst sampledQuaternionRotation = new Core_Cartesian3();\nconst sampledQuaternionTempQuaternion = new Quaternion();\nconst sampledQuaternionQuaternion0 = new Quaternion();\nconst sampledQuaternionQuaternion0Conjugate = new Quaternion();\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nQuaternion.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Quaternion} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nQuaternion.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new Quaternion();\n  }\n  result.x = array[startingIndex];\n  result.y = array[startingIndex + 1];\n  result.z = array[startingIndex + 2];\n  result.w = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * The number of elements used to store the object into an array in its interpolatable form.\n * @type {Number}\n */\nQuaternion.packedInterpolationLength = 3;\n\n/**\n * Converts a packed array into a form suitable for interpolation.\n *\n * @param {Number[]} packedArray The packed array.\n * @param {Number} [startingIndex=0] The index of the first element to be converted.\n * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n * @param {Number[]} [result] The object into which to store the result.\n */\nQuaternion.convertPackedArrayForInterpolation = function (\n  packedArray,\n  startingIndex,\n  lastIndex,\n  result\n) {\n  Quaternion.unpack(\n    packedArray,\n    lastIndex * 4,\n    sampledQuaternionQuaternion0Conjugate\n  );\n  Quaternion.conjugate(\n    sampledQuaternionQuaternion0Conjugate,\n    sampledQuaternionQuaternion0Conjugate\n  );\n\n  for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n    const offset = i * 3;\n    Quaternion.unpack(\n      packedArray,\n      (startingIndex + i) * 4,\n      sampledQuaternionTempQuaternion\n    );\n\n    Quaternion.multiply(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionQuaternion0Conjugate,\n      sampledQuaternionTempQuaternion\n    );\n\n    if (sampledQuaternionTempQuaternion.w < 0) {\n      Quaternion.negate(\n        sampledQuaternionTempQuaternion,\n        sampledQuaternionTempQuaternion\n      );\n    }\n\n    Quaternion.computeAxis(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionAxis\n    );\n    const angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n    if (!Core_defined(result)) {\n      result = [];\n    }\n    result[offset] = sampledQuaternionAxis.x * angle;\n    result[offset + 1] = sampledQuaternionAxis.y * angle;\n    result[offset + 2] = sampledQuaternionAxis.z * angle;\n  }\n};\n\n/**\n * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n *\n * @param {Number[]} array The array previously packed for interpolation.\n * @param {Number[]} sourceArray The original packed array.\n * @param {Number} [firstIndex=0] The firstIndex used to convert the array.\n * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpackInterpolationResult = function (\n  array,\n  sourceArray,\n  firstIndex,\n  lastIndex,\n  result\n) {\n  if (!Core_defined(result)) {\n    result = new Quaternion();\n  }\n  Core_Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n  const magnitude = Core_Cartesian3.magnitude(sampledQuaternionRotation);\n\n  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n\n  if (magnitude === 0) {\n    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n  } else {\n    Quaternion.fromAxisAngle(\n      sampledQuaternionRotation,\n      magnitude,\n      sampledQuaternionTempQuaternion\n    );\n  }\n\n  return Quaternion.multiply(\n    sampledQuaternionTempQuaternion,\n    sampledQuaternionQuaternion0,\n    result\n  );\n};\n\n/**\n * Duplicates a Quaternion instance.\n *\n * @param {Quaternion} quaternion The quaternion to duplicate.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n */\nQuaternion.clone = function (quaternion, result) {\n  if (!Core_defined(quaternion)) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    return new Quaternion(\n      quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      quaternion.w\n    );\n  }\n\n  result.x = quaternion.x;\n  result.y = quaternion.y;\n  result.z = quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes the conjugate of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.conjugate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes magnitude squared for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude squared.\n */\nQuaternion.magnitudeSquared = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  return (\n    quaternion.x * quaternion.x +\n    quaternion.y * quaternion.y +\n    quaternion.z * quaternion.z +\n    quaternion.w * quaternion.w\n  );\n};\n\n/**\n * Computes magnitude for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude.\n */\nQuaternion.magnitude = function (quaternion) {\n  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n};\n\n/**\n * Computes the normalized form of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.normalize = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n  const x = quaternion.x * inverseMagnitude;\n  const y = quaternion.y * inverseMagnitude;\n  const z = quaternion.z * inverseMagnitude;\n  const w = quaternion.w * inverseMagnitude;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.inverse = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n  result = Quaternion.conjugate(quaternion, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n};\n\n/**\n * Computes the componentwise sum of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Negates the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to be negated.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.negate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = -quaternion.w;\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @returns {Number} The dot product.\n */\nQuaternion.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const leftW = left.w;\n\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n  const rightW = right.w;\n\n  const x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n  const y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n  const z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n  const w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Multiplies the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiplyByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  result.w = quaternion.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.divideByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  Core_Check.typeOf.number(\"scalar\", scalar);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x / scalar;\n  result.y = quaternion.y / scalar;\n  result.z = quaternion.z / scalar;\n  result.w = quaternion.w / scalar;\n  return result;\n};\n\n/**\n * Computes the axis of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.computeAxis = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const w = quaternion.w;\n  if (Math.abs(w - 1.0) < Core_Math.EPSILON6) {\n    result.x = result.y = result.z = 0;\n    return result;\n  }\n\n  const scalar = 1.0 / Math.sqrt(1.0 - w * w);\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  return result;\n};\n\n/**\n * Computes the angle of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @returns {Number} The angle of rotation.\n */\nQuaternion.computeAngle = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  if (Math.abs(quaternion.w - 1.0) < Core_Math.EPSILON6) {\n    return 0.0;\n  }\n  return 2.0 * Math.acos(quaternion.w);\n};\n\nlet Quaternion_lerpScratch = new Quaternion();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"start\", start);\n  Core_Check.typeOf.object(\"end\", end);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Quaternion_lerpScratch = Quaternion.multiplyByScalar(end, t, Quaternion_lerpScratch);\n  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n  return Quaternion.add(Quaternion_lerpScratch, result, result);\n};\n\nlet slerpEndNegated = new Quaternion();\nlet slerpScaledP = new Quaternion();\nlet slerpScaledR = new Quaternion();\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#fastSlerp\n */\nQuaternion.slerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"start\", start);\n  Core_Check.typeOf.object(\"end\", end);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let dot = Quaternion.dot(start, end);\n\n  // The angle between start must be acute. Since q and -q represent\n  // the same rotation, negate q to get the acute angle.\n  let r = end;\n  if (dot < 0.0) {\n    dot = -dot;\n    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n  }\n\n  // dot > 0, as the dot product approaches 1, the angle between the\n  // quaternions vanishes. use linear interpolation.\n  if (1.0 - dot < Core_Math.EPSILON6) {\n    return Quaternion.lerp(start, r, t, result);\n  }\n\n  const theta = Math.acos(dot);\n  slerpScaledP = Quaternion.multiplyByScalar(\n    start,\n    Math.sin((1 - t) * theta),\n    slerpScaledP\n  );\n  slerpScaledR = Quaternion.multiplyByScalar(\n    r,\n    Math.sin(t * theta),\n    slerpScaledR\n  );\n  result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n};\n\n/**\n * The logarithmic quaternion function.\n *\n * @param {Quaternion} quaternion The unit quaternion.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.log = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"quaternion\", quaternion);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = Core_Math.acosClamped(quaternion.w);\n  let thetaOverSinTheta = 0.0;\n\n  if (theta !== 0.0) {\n    thetaOverSinTheta = theta / Math.sin(theta);\n  }\n\n  return Core_Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n};\n\n/**\n * The exponential quaternion function.\n *\n * @param {Cartesian3} cartesian The cartesian.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.exp = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"cartesian\", cartesian);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = Core_Cartesian3.magnitude(cartesian);\n  let sinThetaOverTheta = 0.0;\n\n  if (theta !== 0.0) {\n    sinThetaOverTheta = Math.sin(theta) / theta;\n  }\n\n  result.x = cartesian.x * sinThetaOverTheta;\n  result.y = cartesian.y * sinThetaOverTheta;\n  result.z = cartesian.z * sinThetaOverTheta;\n  result.w = Math.cos(theta);\n\n  return result;\n};\n\nconst squadScratchCartesian0 = new Core_Cartesian3();\nconst squadScratchCartesian1 = new Core_Cartesian3();\nconst squadScratchQuaternion0 = new Quaternion();\nconst squadScratchQuaternion1 = new Quaternion();\n\n/**\n * Computes an inner quadrangle point.\n * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} q2 The third quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#squad\n */\nQuaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"q0\", q0);\n  Core_Check.typeOf.object(\"q1\", q1);\n  Core_Check.typeOf.object(\"q2\", q2);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n  const cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n\n  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n  const cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n\n  Core_Cartesian3.add(cart0, cart1, cart0);\n  Core_Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n  Core_Cartesian3.negate(cart0, cart0);\n  Quaternion.exp(cart0, squadScratchQuaternion0);\n\n  return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n *\n * @example\n * // 1. compute the squad interpolation between two quaternions on a curve\n * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n * @see Quaternion#computeInnerQuadrangle\n */\nQuaternion.squad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"q0\", q0);\n  Core_Check.typeOf.object(\"q1\", q1);\n  Core_Check.typeOf.object(\"s0\", s0);\n  Core_Check.typeOf.object(\"s1\", s1);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\nconst fastSlerpScratchQuaternion = new Quaternion();\n// eslint-disable-next-line no-loss-of-precision\nconst opmu = 1.90110745351730037;\nconst u = Core_FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst v = Core_FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bT = Core_FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bD = Core_FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n\nfor (let i = 0; i < 7; ++i) {\n  const s = i + 1.0;\n  const t = 2.0 * s + 1.0;\n  u[i] = 1.0 / (s * t);\n  v[i] = s / t;\n}\n\nu[7] = opmu / (8.0 * 17.0);\nv[7] = (opmu * 8.0) / 17.0;\n\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#slerp\n */\nQuaternion.fastSlerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"start\", start);\n  Core_Check.typeOf.object(\"end\", end);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let x = Quaternion.dot(start, end);\n\n  let sign;\n  if (x >= 0) {\n    sign = 1.0;\n  } else {\n    sign = -1.0;\n    x = -x;\n  }\n\n  const xm1 = x - 1.0;\n  const d = 1.0 - t;\n  const sqrT = t * t;\n  const sqrD = d * d;\n\n  for (let i = 7; i >= 0; --i) {\n    bT[i] = (u[i] * sqrT - v[i]) * xm1;\n    bD[i] = (u[i] * sqrD - v[i]) * xm1;\n  }\n\n  const cT =\n    sign *\n    t *\n    (1.0 +\n      bT[0] *\n        (1.0 +\n          bT[1] *\n            (1.0 +\n              bT[2] *\n                (1.0 +\n                  bT[3] *\n                    (1.0 +\n                      bT[4] *\n                        (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n  const cD =\n    d *\n    (1.0 +\n      bD[0] *\n        (1.0 +\n          bD[1] *\n            (1.0 +\n              bD[2] *\n                (1.0 +\n                  bD[3] *\n                    (1.0 +\n                      bD[4] *\n                        (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n\n  const temp = Quaternion.multiplyByScalar(\n    start,\n    cD,\n    fastSlerpScratchQuaternion\n  );\n  Quaternion.multiplyByScalar(end, cT, result);\n  return Quaternion.add(temp, result, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n *\n * @see Quaternion#squad\n */\nQuaternion.fastSquad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"q0\", q0);\n  Core_Check.typeOf.object(\"q1\", q1);\n  Core_Check.typeOf.object(\"s0\", s0);\n  Core_Check.typeOf.object(\"s1\", s1);\n  Core_Check.typeOf.number(\"t\", t);\n  Core_Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.equals = function (left, right) {\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = Core_defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (Core_defined(left) &&\n      Core_defined(right) &&\n      Math.abs(left.x - right.x) <= epsilon &&\n      Math.abs(left.y - right.y) <= epsilon &&\n      Math.abs(left.z - right.z) <= epsilon &&\n      Math.abs(left.w - right.w) <= epsilon)\n  );\n};\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Quaternion instance.\n *\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.prototype.clone = function (result) {\n  return Quaternion.clone(this, result);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.prototype.equals = function (right) {\n  return Quaternion.equals(this, right);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.prototype.equalsEpsilon = function (right, epsilon) {\n  return Quaternion.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Returns a string representing this quaternion in the format (x, y, z, w).\n *\n * @returns {String} A string representing this Quaternion.\n */\nQuaternion.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\n/* harmony default export */ const Core_Quaternion = (Quaternion);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Transforms.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Contains functions for transforming positions to various reference frames.\n *\n * @namespace Transforms\n */\nconst Transforms = {};\n\nconst vectorProductLocalFrame = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\",\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\",\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\",\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\",\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\",\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\",\n  },\n};\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1],\n};\n\nconst localFrameToFixedFrameCache = {};\n\nconst scratchCalculateCartesian = {\n  east: new Core_Cartesian3(),\n  north: new Core_Cartesian3(),\n  up: new Core_Cartesian3(),\n  west: new Core_Cartesian3(),\n  south: new Core_Cartesian3(),\n  down: new Core_Cartesian3(),\n};\nlet scratchFirstCartesian = new Core_Cartesian3();\nlet scratchSecondCartesian = new Core_Cartesian3();\nlet scratchThirdCartesian = new Core_Cartesian3();\n/**\n * Generates a function that computes a 4x4 transformation matrix from a reference frame\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * @param  {String} firstAxis  name of the first axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @param  {String} secondAxis  name of the second axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @return {Transforms.LocalFrameToFixedFrame} The function that will computes a\n * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,\n */\nTransforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {\n  if (\n    !vectorProductLocalFrame.hasOwnProperty(firstAxis) ||\n    !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)\n  ) {\n    throw new Core_DeveloperError(\n      \"firstAxis and secondAxis must be east, north, up, west, south or down.\"\n    );\n  }\n  const thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];\n\n  /**\n   * Computes a 4x4 transformation matrix from a reference frame\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n   * @callback Transforms.LocalFrameToFixedFrame\n   * @param {Cartesian3} origin The center point of the local reference frame.\n   * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n   * @param {Matrix4} [result] The object onto which to store the result.\n   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n   */\n  let resultat;\n  const hashAxis = firstAxis + secondAxis;\n  if (Core_defined(localFrameToFixedFrameCache[hashAxis])) {\n    resultat = localFrameToFixedFrameCache[hashAxis];\n  } else {\n    resultat = function (origin, ellipsoid, result) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!Core_defined(origin)) {\n        throw new Core_DeveloperError(\"origin is required.\");\n      }\n      //>>includeEnd('debug');\n      if (!Core_defined(result)) {\n        result = new Core_Matrix4();\n      }\n      if (\n        Core_Cartesian3.equalsEpsilon(origin, Core_Cartesian3.ZERO, Core_Math.EPSILON14)\n      ) {\n        // If x, y, and z are zero, use the degenerate local frame, which is a special case\n        Core_Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian\n        );\n        Core_Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian\n        );\n        Core_Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian\n        );\n      } else if (\n        Core_Math.equalsEpsilon(origin.x, 0.0, Core_Math.EPSILON14) &&\n        Core_Math.equalsEpsilon(origin.y, 0.0, Core_Math.EPSILON14)\n      ) {\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        const sign = Core_Math.sign(origin.z);\n\n        Core_Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian\n        );\n        if (firstAxis !== \"east\" && firstAxis !== \"west\") {\n          Core_Cartesian3.multiplyByScalar(\n            scratchFirstCartesian,\n            sign,\n            scratchFirstCartesian\n          );\n        }\n\n        Core_Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian\n        );\n        if (secondAxis !== \"east\" && secondAxis !== \"west\") {\n          Core_Cartesian3.multiplyByScalar(\n            scratchSecondCartesian,\n            sign,\n            scratchSecondCartesian\n          );\n        }\n\n        Core_Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian\n        );\n        if (thirdAxis !== \"east\" && thirdAxis !== \"west\") {\n          Core_Cartesian3.multiplyByScalar(\n            scratchThirdCartesian,\n            sign,\n            scratchThirdCartesian\n          );\n        }\n      } else {\n        ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);\n\n        const up = scratchCalculateCartesian.up;\n        const east = scratchCalculateCartesian.east;\n        east.x = -origin.y;\n        east.y = origin.x;\n        east.z = 0.0;\n        Core_Cartesian3.normalize(east, scratchCalculateCartesian.east);\n        Core_Cartesian3.cross(up, east, scratchCalculateCartesian.north);\n\n        Core_Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.up,\n          -1,\n          scratchCalculateCartesian.down\n        );\n        Core_Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.east,\n          -1,\n          scratchCalculateCartesian.west\n        );\n        Core_Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.north,\n          -1,\n          scratchCalculateCartesian.south\n        );\n\n        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];\n        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];\n        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];\n      }\n      result[0] = scratchFirstCartesian.x;\n      result[1] = scratchFirstCartesian.y;\n      result[2] = scratchFirstCartesian.z;\n      result[3] = 0.0;\n      result[4] = scratchSecondCartesian.x;\n      result[5] = scratchSecondCartesian.y;\n      result[6] = scratchSecondCartesian.z;\n      result[7] = 0.0;\n      result[8] = scratchThirdCartesian.x;\n      result[9] = scratchThirdCartesian.y;\n      result[10] = scratchThirdCartesian.z;\n      result[11] = 0.0;\n      result[12] = origin.x;\n      result[13] = origin.y;\n      result[14] = origin.z;\n      result[15] = 1.0;\n      return result;\n    };\n    localFrameToFixedFrameCache[hashAxis] = resultat;\n  }\n  return resultat;\n};\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local east direction.</li>\n * <li>The <code>y</code> axis points in the local north direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n */\nTransforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"east\",\n  \"north\"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local east direction.</li>\n * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n */\nTransforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"east\"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * <li>The <code>z</code> axis points in the local east direction.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n */\nTransforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"up\"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local west direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);\n */\nTransforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"west\"\n);\n\nconst Transforms_scratchHPRQuaternion = new Core_Quaternion();\nconst scratchScale = new Core_Cartesian3(1.0, 1.0, 1.0);\nconst scratchHPRMatrix4 = new Core_Matrix4();\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);\n */\nTransforms.headingPitchRollToFixedFrame = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  fixedFrameTransform = Core_defaultValue(\n    fixedFrameTransform,\n    Transforms.eastNorthUpToFixedFrame\n  );\n  const hprQuaternion = Core_Quaternion.fromHeadingPitchRoll(\n    headingPitchRoll,\n    Transforms_scratchHPRQuaternion\n  );\n  const hprMatrix = Core_Matrix4.fromTranslationQuaternionRotationScale(\n    Core_Cartesian3.ZERO,\n    hprQuaternion,\n    scratchScale,\n    scratchHPRMatrix4\n  );\n  result = fixedFrameTransform(origin, ellipsoid, result);\n  return Core_Matrix4.multiply(result, hprMatrix, result);\n};\n\nconst scratchENUMatrix4 = new Core_Matrix4();\nconst scratchHPRMatrix3 = new Core_Matrix3();\n\n/**\n * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n *\n * @example\n * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new HeadingPitchRoll(heading, pitch, roll);\n * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);\n */\nTransforms.headingPitchRollQuaternion = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const transform = Transforms.headingPitchRollToFixedFrame(\n    origin,\n    headingPitchRoll,\n    ellipsoid,\n    fixedFrameTransform,\n    scratchENUMatrix4\n  );\n  const rotation = Core_Matrix4.getMatrix3(transform, scratchHPRMatrix3);\n  return Core_Quaternion.fromRotationMatrix(rotation, result);\n};\n\nconst noScale = new Core_Cartesian3(1.0, 1.0, 1.0);\nconst hprCenterScratch = new Core_Cartesian3();\nconst ffScratch = new Core_Matrix4();\nconst hprTransformScratch = new Core_Matrix4();\nconst hprRotationScratch = new Core_Matrix3();\nconst hprQuaternionScratch = new Core_Quaternion();\n/**\n * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Matrix4} transform The transform\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.\n */\nTransforms.fixedFrameToHeadingPitchRoll = function (\n  transform,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n  fixedFrameTransform = Core_defaultValue(\n    fixedFrameTransform,\n    Transforms.eastNorthUpToFixedFrame\n  );\n  if (!Core_defined(result)) {\n    result = new Core_HeadingPitchRoll();\n  }\n\n  const center = Core_Matrix4.getTranslation(transform, hprCenterScratch);\n  if (Core_Cartesian3.equals(center, Core_Cartesian3.ZERO)) {\n    result.heading = 0;\n    result.pitch = 0;\n    result.roll = 0;\n    return result;\n  }\n  let toFixedFrame = Core_Matrix4.inverseTransformation(\n    fixedFrameTransform(center, ellipsoid, ffScratch),\n    ffScratch\n  );\n  let transformCopy = Core_Matrix4.setScale(transform, noScale, hprTransformScratch);\n  transformCopy = Core_Matrix4.setTranslation(\n    transformCopy,\n    Core_Cartesian3.ZERO,\n    transformCopy\n  );\n\n  toFixedFrame = Core_Matrix4.multiply(toFixedFrame, transformCopy, toFixedFrame);\n  let quaternionRotation = Core_Quaternion.fromRotationMatrix(\n    Core_Matrix4.getMatrix3(toFixedFrame, hprRotationScratch),\n    hprQuaternionScratch\n  );\n  quaternionRotation = Core_Quaternion.normalize(\n    quaternionRotation,\n    quaternionRotation\n  );\n\n  return Core_HeadingPitchRoll.fromQuaternion(quaternionRotation, result);\n};\n\nconst gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\nconst gmstConstant1 = 8640184.812866;\nconst gmstConstant2 = 0.093104;\nconst gmstConstant3 = -6.2e-6;\nconst rateCoef = 1.1772758384668e-19;\nconst wgs84WRPrecessing = 7.2921158553e-5;\nconst twoPiOverSecondsInDay = Core_Math.TWO_PI / 86400.0;\nlet dateInUtc = new Core_JulianDate();\n\n/**\n * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n *\n * @example\n * //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    const now = Cesium.JulianDate.now();\n *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });\n */\nTransforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(date)) {\n    throw new Core_DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.\n  // We do not want to use the function like convertTaiToUtc in JulianDate because\n  // we explicitly do not want to fail when inside the leap second.\n\n  dateInUtc = Core_JulianDate.addSeconds(\n    date,\n    -Core_JulianDate.computeTaiMinusUtc(date),\n    dateInUtc\n  );\n  const utcDayNumber = dateInUtc.dayNumber;\n  const utcSecondsIntoDay = dateInUtc.secondsOfDay;\n\n  let t;\n  const diffDays = utcDayNumber - 2451545;\n  if (utcSecondsIntoDay >= 43200.0) {\n    t = (diffDays + 0.5) / Core_TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  } else {\n    t = (diffDays - 0.5) / Core_TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  }\n\n  const gmst0 =\n    gmstConstant0 +\n    t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n  const angle = (gmst0 * twoPiOverSecondsInDay) % Core_Math.TWO_PI;\n  const ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n  const secondsSinceMidnight =\n    (utcSecondsIntoDay + Core_TimeConstants.SECONDS_PER_DAY * 0.5) %\n    Core_TimeConstants.SECONDS_PER_DAY;\n  const gha = angle + ratio * secondsSinceMidnight;\n  const cosGha = Math.cos(gha);\n  const sinGha = Math.sin(gha);\n\n  if (!Core_defined(result)) {\n    return new Core_Matrix3(\n      cosGha,\n      sinGha,\n      0.0,\n      -sinGha,\n      cosGha,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n  result[0] = cosGha;\n  result[1] = -sinGha;\n  result[2] = 0.0;\n  result[3] = sinGha;\n  result[4] = cosGha;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n\n/**\n * The source of IAU 2006 XYS data, used for computing the transformation between the\n * Fixed and ICRF axes.\n * @type {Iau2006XysData}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.iau2006XysData = new Core_Iau2006XysData();\n\n/**\n * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n * yielding a reasonable but not completely accurate representation of the ICRF axes.\n * @type {EarthOrientationParameters}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.earthOrientationParameters = Core_EarthOrientationParameters.NONE;\n\nconst ttMinusTai = 32.184;\nconst j2000ttDays = 2451545.0;\n\n/**\n * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n * direction, over a given interval.  This function returns a promise that, when resolved,\n * indicates that the preload has completed.\n *\n * @param {TimeInterval} timeInterval The interval to preload.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the preload has completed\n *          and evaluation of the transformation between the fixed and ICRF axes will\n *          no longer return undefined for a time inside the interval.\n *\n *\n * @example\n * const interval = new Cesium.TimeInterval(...);\n * Promise.resolve(Cesium.Transforms.preloadIcrfFixed(interval)).then(function() {\n *     // the data is now loaded\n * });\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n */\nTransforms.preloadIcrfFixed = function (timeInterval) {\n  const startDayTT = timeInterval.start.dayNumber;\n  const startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n  const stopDayTT = timeInterval.stop.dayNumber;\n  const stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n\n  const xysPromise = Transforms.iau2006XysData.preload(\n    startDayTT,\n    startSecondTT,\n    stopDayTT,\n    stopSecondTT\n  );\n  const eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();\n\n  return Promise.all([xysPromise, eopPromise]);\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     const offset = Cesium.Cartesian3.clone(camera.position);\n *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeIcrfToFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(date)) {\n    throw new Core_DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!Core_defined(result)) {\n    result = new Core_Matrix3();\n  }\n\n  const fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n  if (!Core_defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return Core_Matrix3.transpose(fixedToIcrfMtx, result);\n};\n\nconst xysScratch = new Core_Iau2006XysSample(0.0, 0.0, 0.0);\nconst eopScratch = new Core_EarthOrientationParametersSample(\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0\n);\nconst rotation1Scratch = new Core_Matrix3();\nconst rotation2Scratch = new Core_Matrix3();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * // Transform a point from the ICRF axes to the Fixed axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(date)) {\n    throw new Core_DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Matrix3();\n  }\n\n  // Compute pole wander\n  const eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n  if (!Core_defined(eop)) {\n    return undefined;\n  }\n\n  // There is no external conversion to Terrestrial Time (TT).\n  // So use International Atomic Time (TAI) and convert using offsets.\n  // Here we are assuming that dayTT and secondTT are positive\n  const dayTT = date.dayNumber;\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const secondTT = date.secondsOfDay + ttMinusTai;\n\n  const xys = Transforms.iau2006XysData.computeXysRadians(\n    dayTT,\n    secondTT,\n    xysScratch\n  );\n  if (!Core_defined(xys)) {\n    return undefined;\n  }\n\n  const x = xys.x + eop.xPoleOffset;\n  const y = xys.y + eop.yPoleOffset;\n\n  // Compute XYS rotation\n  const a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n\n  const rotation1 = rotation1Scratch;\n  rotation1[0] = 1.0 - a * x * x;\n  rotation1[3] = -a * x * y;\n  rotation1[6] = x;\n  rotation1[1] = -a * x * y;\n  rotation1[4] = 1 - a * y * y;\n  rotation1[7] = y;\n  rotation1[2] = -x;\n  rotation1[5] = -y;\n  rotation1[8] = 1 - a * (x * x + y * y);\n\n  const rotation2 = Core_Matrix3.fromRotationZ(-xys.s, rotation2Scratch);\n  const matrixQ = Core_Matrix3.multiply(rotation1, rotation2, rotation1Scratch);\n\n  // Similar to TT conversions above\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const dateUt1day = date.dayNumber;\n  const dateUt1sec =\n    date.secondsOfDay - Core_JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;\n\n  // Compute Earth rotation angle\n  // The IERS standard for era is\n  //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n  // where\n  //    Tu = JulianDateInUt1 - 2451545.0\n  // However, you get much more precision if you make the following simplification\n  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n  const daysSinceJ2000 = dateUt1day - 2451545;\n  const fractionOfDay = dateUt1sec / Core_TimeConstants.SECONDS_PER_DAY;\n  let era =\n    0.779057273264 +\n    fractionOfDay +\n    0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n  era = (era % 1.0) * Core_Math.TWO_PI;\n\n  const earthRotation = Core_Matrix3.fromRotationZ(era, rotation2Scratch);\n\n  // pseudoFixed to ICRF\n  const pfToIcrf = Core_Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);\n\n  // Compute pole wander matrix\n  const cosxp = Math.cos(eop.xPoleWander);\n  const cosyp = Math.cos(eop.yPoleWander);\n  const sinxp = Math.sin(eop.xPoleWander);\n  const sinyp = Math.sin(eop.yPoleWander);\n\n  let ttt = dayTT - j2000ttDays + secondTT / Core_TimeConstants.SECONDS_PER_DAY;\n  ttt /= 36525.0;\n\n  // approximate sp value in rad\n  const sp = (-47.0e-6 * ttt * Core_Math.RADIANS_PER_DEGREE) / 3600.0;\n  const cossp = Math.cos(sp);\n  const sinsp = Math.sin(sp);\n\n  const fToPfMtx = rotation2Scratch;\n  fToPfMtx[0] = cosxp * cossp;\n  fToPfMtx[1] = cosxp * sinsp;\n  fToPfMtx[2] = sinxp;\n  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n  fToPfMtx[5] = -sinyp * cosxp;\n  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n  fToPfMtx[8] = cosyp * cosxp;\n\n  return Core_Matrix3.multiply(pfToIcrf, fToPfMtx, result);\n};\n\nconst pointToWindowCoordinatesTemp = new Core_Cartesian4();\n\n/**\n * Transform a point from model coordinates to window coordinates.\n *\n * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n * @param {Cartesian3} point The point to transform.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nTransforms.pointToWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result\n) {\n  result = Transforms.pointToGLWindowCoordinates(\n    modelViewProjectionMatrix,\n    viewportTransformation,\n    point,\n    result\n  );\n  result.y = 2.0 * viewportTransformation[5] - result.y;\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.pointToGLWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(modelViewProjectionMatrix)) {\n    throw new Core_DeveloperError(\"modelViewProjectionMatrix is required.\");\n  }\n\n  if (!Core_defined(viewportTransformation)) {\n    throw new Core_DeveloperError(\"viewportTransformation is required.\");\n  }\n\n  if (!Core_defined(point)) {\n    throw new Core_DeveloperError(\"point is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian2();\n  }\n\n  const tmp = pointToWindowCoordinatesTemp;\n\n  Core_Matrix4.multiplyByVector(\n    modelViewProjectionMatrix,\n    Core_Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp),\n    tmp\n  );\n  Core_Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n  Core_Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);\n  return Core_Cartesian2.fromCartesian4(tmp, result);\n};\n\nconst normalScratch = new Core_Cartesian3();\nconst rightScratch = new Core_Cartesian3();\nconst upScratch = new Core_Cartesian3();\n\n/**\n * Transform a position and velocity to a rotation matrix.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} velocity The velocity vector to transform.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n */\nTransforms.rotationMatrixFromPositionVelocity = function (\n  position,\n  velocity,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(position)) {\n    throw new Core_DeveloperError(\"position is required.\");\n  }\n\n  if (!Core_defined(velocity)) {\n    throw new Core_DeveloperError(\"velocity is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const normal = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84).geodeticSurfaceNormal(\n    position,\n    normalScratch\n  );\n  let right = Core_Cartesian3.cross(velocity, normal, rightScratch);\n\n  if (Core_Cartesian3.equalsEpsilon(right, Core_Cartesian3.ZERO, Core_Math.EPSILON6)) {\n    right = Core_Cartesian3.clone(Core_Cartesian3.UNIT_X, right);\n  }\n\n  const up = Core_Cartesian3.cross(right, velocity, upScratch);\n  Core_Cartesian3.normalize(up, up);\n  Core_Cartesian3.cross(velocity, up, right);\n  Core_Cartesian3.negate(right, right);\n  Core_Cartesian3.normalize(right, right);\n\n  if (!Core_defined(result)) {\n    result = new Core_Matrix3();\n  }\n\n  result[0] = velocity.x;\n  result[1] = velocity.y;\n  result[2] = velocity.z;\n  result[3] = right.x;\n  result[4] = right.y;\n  result[5] = right.z;\n  result[6] = up.x;\n  result[7] = up.y;\n  result[8] = up.z;\n\n  return result;\n};\n\nconst swizzleMatrix = new Core_Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\nconst scratchCartographic = new Core_Cartographic();\nconst scratchCartesian3Projection = new Core_Cartesian3();\nconst scratchCenter = new Core_Cartesian3();\nconst scratchRotation = new Core_Matrix3();\nconst scratchFromENU = new Core_Matrix4();\nconst scratchToENU = new Core_Matrix4();\n\n/**\n * @private\n */\nTransforms.basisTo2D = function (projection, matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(projection)) {\n    throw new Core_DeveloperError(\"projection is required.\");\n  }\n  if (!Core_defined(matrix)) {\n    throw new Core_DeveloperError(\"matrix is required.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const rtcCenter = Core_Matrix4.getTranslation(matrix, scratchCenter);\n  const ellipsoid = projection.ellipsoid;\n\n  // Get the 2D Center\n  const cartographic = ellipsoid.cartesianToCartographic(\n    rtcCenter,\n    scratchCartographic\n  );\n  const projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  Core_Cartesian3.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition\n  );\n\n  // Assuming the instance are positioned in WGS84, invert the WGS84 transform to get the local transform and then convert to 2D\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    rtcCenter,\n    ellipsoid,\n    scratchFromENU\n  );\n  const toENU = Core_Matrix4.inverseTransformation(fromENU, scratchToENU);\n  const rotation = Core_Matrix4.getMatrix3(matrix, scratchRotation);\n  const local = Core_Matrix4.multiplyByMatrix3(toENU, rotation, result);\n  Core_Matrix4.multiply(swizzleMatrix, local, result); // Swap x, y, z for 2D\n  Core_Matrix4.setTranslation(result, projectedPosition, result); // Use the projected center\n\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.wgs84To2DModelMatrix = function (projection, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(projection)) {\n    throw new Core_DeveloperError(\"projection is required.\");\n  }\n  if (!Core_defined(center)) {\n    throw new Core_DeveloperError(\"center is required.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ellipsoid = projection.ellipsoid;\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    scratchFromENU\n  );\n  const toENU = Core_Matrix4.inverseTransformation(fromENU, scratchToENU);\n\n  const cartographic = ellipsoid.cartesianToCartographic(\n    center,\n    scratchCartographic\n  );\n  const projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  Core_Cartesian3.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition\n  );\n\n  const translation = Core_Matrix4.fromTranslation(\n    projectedPosition,\n    scratchFromENU\n  );\n  Core_Matrix4.multiply(swizzleMatrix, toENU, result);\n  Core_Matrix4.multiply(translation, result, result);\n\n  return result;\n};\n/* harmony default export */ const Core_Transforms = (Transforms);\n\n;// CONCATENATED MODULE: ./node_modules/@tweenjs/tween.js/dist/tween.esm.js\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\nvar Easing = {\n    Linear: {\n        None: function (amount) {\n            return amount;\n        },\n    },\n    Quadratic: {\n        In: function (amount) {\n            return amount * amount;\n        },\n        Out: function (amount) {\n            return amount * (2 - amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount;\n            }\n            return -0.5 * (--amount * (amount - 2) - 1);\n        },\n    },\n    Cubic: {\n        In: function (amount) {\n            return amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\n        },\n    },\n    Quartic: {\n        In: function (amount) {\n            return amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return 1 - --amount * amount * amount * amount;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount;\n            }\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n        },\n    },\n    Quintic: {\n        In: function (amount) {\n            return amount * amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n        },\n    },\n    Sinusoidal: {\n        In: function (amount) {\n            return 1 - Math.cos((amount * Math.PI) / 2);\n        },\n        Out: function (amount) {\n            return Math.sin((amount * Math.PI) / 2);\n        },\n        InOut: function (amount) {\n            return 0.5 * (1 - Math.cos(Math.PI * amount));\n        },\n    },\n    Exponential: {\n        In: function (amount) {\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n        },\n        Out: function (amount) {\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            if ((amount *= 2) < 1) {\n                return 0.5 * Math.pow(1024, amount - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n        },\n    },\n    Circular: {\n        In: function (amount) {\n            return 1 - Math.sqrt(1 - amount * amount);\n        },\n        Out: function (amount) {\n            return Math.sqrt(1 - --amount * amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n        },\n    },\n    Elastic: {\n        In: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n        },\n        Out: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            amount *= 2;\n            if (amount < 1) {\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n            }\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n        },\n    },\n    Back: {\n        In: function (amount) {\n            var s = 1.70158;\n            return amount * amount * ((s + 1) * amount - s);\n        },\n        Out: function (amount) {\n            var s = 1.70158;\n            return --amount * amount * ((s + 1) * amount + s) + 1;\n        },\n        InOut: function (amount) {\n            var s = 1.70158 * 1.525;\n            if ((amount *= 2) < 1) {\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\n            }\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n        },\n    },\n    Bounce: {\n        In: function (amount) {\n            return 1 - Easing.Bounce.Out(1 - amount);\n        },\n        Out: function (amount) {\n            if (amount < 1 / 2.75) {\n                return 7.5625 * amount * amount;\n            }\n            else if (amount < 2 / 2.75) {\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n            }\n            else if (amount < 2.5 / 2.75) {\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n            }\n            else {\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n            }\n        },\n        InOut: function (amount) {\n            if (amount < 0.5) {\n                return Easing.Bounce.In(amount * 2) * 0.5;\n            }\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n        },\n    },\n};\n\nvar now;\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\n// eslint-disable-next-line\n// @ts-ignore\nif (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {\n    now = function () {\n        // eslint-disable-next-line\n        // @ts-ignore\n        var time = process.hrtime();\n        // Convert [seconds, nanoseconds] to milliseconds.\n        return time[0] * 1000 + time[1] / 1000000;\n    };\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {\n    // This must be bound, because directly assigning this function\n    // leads to an invocation exception in Chrome.\n    now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n    now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n    now = function () {\n        return new Date().getTime();\n    };\n}\nvar now$1 = now;\n\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tween\n */\nvar Group = /** @class */ (function () {\n    function Group() {\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n    }\n    Group.prototype.getAll = function () {\n        var _this = this;\n        return Object.keys(this._tweens).map(function (tweenId) {\n            return _this._tweens[tweenId];\n        });\n    };\n    Group.prototype.removeAll = function () {\n        this._tweens = {};\n    };\n    Group.prototype.add = function (tween) {\n        this._tweens[tween.getId()] = tween;\n        this._tweensAddedDuringUpdate[tween.getId()] = tween;\n    };\n    Group.prototype.remove = function (tween) {\n        delete this._tweens[tween.getId()];\n        delete this._tweensAddedDuringUpdate[tween.getId()];\n    };\n    Group.prototype.update = function (time, preserve) {\n        if (time === void 0) { time = now$1(); }\n        if (preserve === void 0) { preserve = false; }\n        var tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0) {\n            return false;\n        }\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (var i = 0; i < tweenIds.length; i++) {\n                var tween = this._tweens[tweenIds[i]];\n                var autoStart = !preserve;\n                if (tween && tween.update(time, autoStart) === false && !preserve) {\n                    delete this._tweens[tweenIds[i]];\n                }\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n        return true;\n    };\n    return Group;\n}());\n\n/**\n *\n */\nvar Interpolation = {\n    Linear: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.Linear;\n        if (k < 0) {\n            return fn(v[0], v[1], f);\n        }\n        if (k > 1) {\n            return fn(v[m], v[m - 1], m - f);\n        }\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: function (v, k) {\n        var b = 0;\n        var n = v.length - 1;\n        var pw = Math.pow;\n        var bn = Interpolation.Utils.Bernstein;\n        for (var i = 0; i <= n; i++) {\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        }\n        return b;\n    },\n    CatmullRom: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor((f = m * (1 + k)));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0) {\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n            if (k > 1) {\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: function (p0, p1, t) {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: function (n, i) {\n            var fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (function () {\n            var a = [1];\n            return function (n) {\n                var s = 1;\n                if (a[n]) {\n                    return a[n];\n                }\n                for (var i = n; i > 1; i--) {\n                    s *= i;\n                }\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: function (p0, p1, p2, p3, t) {\n            var v0 = (p2 - p0) * 0.5;\n            var v1 = (p3 - p1) * 0.5;\n            var t2 = t * t;\n            var t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n\n/**\n * Utils\n */\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n    }\n    Sequence.nextId = function () {\n        return Sequence._nextId++;\n    };\n    Sequence._nextId = 0;\n    return Sequence;\n}());\n\nvar mainGroup = new Group();\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar Tween = /** @class */ (function () {\n    function Tween(_object, _group) {\n        if (_group === void 0) { _group = mainGroup; }\n        this._object = _object;\n        this._group = _group;\n        this._isPaused = false;\n        this._pauseStart = 0;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._initialRepeat = 0;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._startTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._id = Sequence.nextId();\n        this._isChainStopped = false;\n        this._goToEnd = false;\n    }\n    Tween.prototype.getId = function () {\n        return this._id;\n    };\n    Tween.prototype.isPlaying = function () {\n        return this._isPlaying;\n    };\n    Tween.prototype.isPaused = function () {\n        return this._isPaused;\n    };\n    Tween.prototype.to = function (properties, duration) {\n        // TODO? restore this, then update the 07_dynamic_to example to set fox\n        // tween's to on each update. That way the behavior is opt-in (there's\n        // currently no opt-out).\n        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]\n        this._valuesEnd = Object.create(properties);\n        if (duration !== undefined) {\n            this._duration = duration;\n        }\n        return this;\n    };\n    Tween.prototype.duration = function (d) {\n        this._duration = d;\n        return this;\n    };\n    Tween.prototype.start = function (time) {\n        if (this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        this._repeat = this._initialRepeat;\n        if (this._reversed) {\n            // If we were reversed (f.e. using the yoyo feature) then we need to\n            // flip the tween direction back to forward.\n            this._reversed = false;\n            for (var property in this._valuesStartRepeat) {\n                this._swapEndStartRepeatValues(property);\n                this._valuesStart[property] = this._valuesStartRepeat[property];\n            }\n        }\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._isChainStopped = false;\n        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();\n        this._startTime += this._delayTime;\n        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);\n        return this;\n    };\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {\n        for (var property in _valuesEnd) {\n            var startValue = _object[property];\n            var startValueIsArray = Array.isArray(startValue);\n            var propType = startValueIsArray ? 'array' : typeof startValue;\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (propType === 'undefined' || propType === 'function') {\n                continue;\n            }\n            // Check if an Array was provided as property value\n            if (isInterpolationList) {\n                var endValues = _valuesEnd[property];\n                if (endValues.length === 0) {\n                    continue;\n                }\n                // handle an array of relative values\n                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));\n                // Create a local copy of the Array with the start value at the front\n                _valuesEnd[property] = [startValue].concat(endValues);\n            }\n            // handle the deepness of the values\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\n                _valuesStart[property] = startValueIsArray ? [] : {};\n                // eslint-disable-next-line\n                for (var prop in startValue) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property][prop] = startValue[prop];\n                }\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);\n            }\n            else {\n                // Save the starting value, but only once.\n                if (typeof _valuesStart[property] === 'undefined') {\n                    _valuesStart[property] = startValue;\n                }\n                if (!startValueIsArray) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n                if (isInterpolationList) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n                }\n                else {\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\n                }\n            }\n        }\n    };\n    Tween.prototype.stop = function () {\n        if (!this._isChainStopped) {\n            this._isChainStopped = true;\n            this.stopChainedTweens();\n        }\n        if (!this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback) {\n            this._onStopCallback(this._object);\n        }\n        return this;\n    };\n    Tween.prototype.end = function () {\n        this._goToEnd = true;\n        this.update(Infinity);\n        return this;\n    };\n    Tween.prototype.pause = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = true;\n        this._pauseStart = time;\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        return this;\n    };\n    Tween.prototype.resume = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (!this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = false;\n        this._startTime += time - this._pauseStart;\n        this._pauseStart = 0;\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        return this;\n    };\n    Tween.prototype.stopChainedTweens = function () {\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n        return this;\n    };\n    Tween.prototype.group = function (group) {\n        this._group = group;\n        return this;\n    };\n    Tween.prototype.delay = function (amount) {\n        this._delayTime = amount;\n        return this;\n    };\n    Tween.prototype.repeat = function (times) {\n        this._initialRepeat = times;\n        this._repeat = times;\n        return this;\n    };\n    Tween.prototype.repeatDelay = function (amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    };\n    Tween.prototype.yoyo = function (yoyo) {\n        this._yoyo = yoyo;\n        return this;\n    };\n    Tween.prototype.easing = function (easingFunction) {\n        this._easingFunction = easingFunction;\n        return this;\n    };\n    Tween.prototype.interpolation = function (interpolationFunction) {\n        this._interpolationFunction = interpolationFunction;\n        return this;\n    };\n    Tween.prototype.chain = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._chainedTweens = tweens;\n        return this;\n    };\n    Tween.prototype.onStart = function (callback) {\n        this._onStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onUpdate = function (callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    };\n    Tween.prototype.onRepeat = function (callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    };\n    Tween.prototype.onComplete = function (callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    };\n    Tween.prototype.onStop = function (callback) {\n        this._onStopCallback = callback;\n        return this;\n    };\n    /**\n     * @returns true if the tween is still playing after the update, false\n     * otherwise (calling update on a paused tween still returns true because\n     * it is still playing, just paused).\n     */\n    Tween.prototype.update = function (time, autoStart) {\n        if (time === void 0) { time = now$1(); }\n        if (autoStart === void 0) { autoStart = true; }\n        if (this._isPaused)\n            return true;\n        var property;\n        var elapsed;\n        var endTime = this._startTime + this._duration;\n        if (!this._goToEnd && !this._isPlaying) {\n            if (time > endTime)\n                return false;\n            if (autoStart)\n                this.start(time);\n        }\n        this._goToEnd = false;\n        if (time < this._startTime) {\n            return true;\n        }\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        elapsed = (time - this._startTime) / this._duration;\n        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n        var value = this._easingFunction(elapsed);\n        // properties transformations\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\n        if (this._onUpdateCallback) {\n            this._onUpdateCallback(this._object, elapsed);\n        }\n        if (elapsed === 1) {\n            if (this._repeat > 0) {\n                if (isFinite(this._repeat)) {\n                    this._repeat--;\n                }\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\n                        this._valuesStartRepeat[property] =\n                            // eslint-disable-next-line\n                            // @ts-ignore FIXME?\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        this._swapEndStartRepeatValues(property);\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo) {\n                    this._reversed = !this._reversed;\n                }\n                if (this._repeatDelayTime !== undefined) {\n                    this._startTime = time + this._repeatDelayTime;\n                }\n                else {\n                    this._startTime = time + this._delayTime;\n                }\n                if (this._onRepeatCallback) {\n                    this._onRepeatCallback(this._object);\n                }\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback) {\n                    this._onCompleteCallback(this._object);\n                }\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration);\n                }\n                this._isPlaying = false;\n                return false;\n            }\n        }\n        return true;\n    };\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\n        for (var property in _valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (_valuesStart[property] === undefined) {\n                continue;\n            }\n            var start = _valuesStart[property] || 0;\n            var end = _valuesEnd[property];\n            var startIsArray = Array.isArray(_object[property]);\n            var endIsArray = Array.isArray(end);\n            var isInterpolationList = !startIsArray && endIsArray;\n            if (isInterpolationList) {\n                _object[property] = this._interpolationFunction(end, value);\n            }\n            else if (typeof end === 'object' && end) {\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._updateProperties(_object[property], start, end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                end = this._handleRelativeValue(start, end);\n                // Protect against non numeric properties.\n                if (typeof end === 'number') {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _object[property] = start + (end - start) * value;\n                }\n            }\n        }\n    };\n    Tween.prototype._handleRelativeValue = function (start, end) {\n        if (typeof end !== 'string') {\n            return end;\n        }\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            return start + parseFloat(end);\n        }\n        else {\n            return parseFloat(end);\n        }\n    };\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\n        var tmp = this._valuesStartRepeat[property];\n        var endValue = this._valuesEnd[property];\n        if (typeof endValue === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n        }\n        else {\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n        }\n        this._valuesEnd[property] = tmp;\n    };\n    return Tween;\n}());\n\nvar VERSION = '18.6.4';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar nextId = Sequence.nextId;\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tweens.\n */\nvar TWEEN = mainGroup;\n// This is the best way to export things in a way that's compatible with both ES\n// Modules and CommonJS, without build hacks, and so as not to break the\n// existing API.\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\nvar getAll = TWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nvar add = TWEEN.add.bind(TWEEN);\nvar remove = TWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN);\nvar tween_esm_exports = {\n    Easing: Easing,\n    Group: Group,\n    Interpolation: Interpolation,\n    now: now$1,\n    Sequence: Sequence,\n    nextId: nextId,\n    Tween: Tween,\n    VERSION: VERSION,\n    getAll: getAll,\n    removeAll: removeAll,\n    add: add,\n    remove: remove,\n    update: update,\n};\n\n/* harmony default export */ const tween_esm = (tween_esm_exports);\n\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/EasingFunction.js\n\n\n/**\n * Easing functions for use with TweenCollection.  These function are from\n * {@link https://github.com/sole/tween.js/|Tween.js} and Robert Penner.  See the\n * {@link http://sole.github.io/tween.js/examples/03_graphs.html|Tween.js graphs for each function}.\n *\n * @namespace\n */\nconst EasingFunction = {\n  /**\n   * Linear easing.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  LINEAR_NONE: Easing.Linear.None,\n\n  /**\n   * Quadratic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_IN: Easing.Quadratic.In,\n  /**\n   * Quadratic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_OUT: Easing.Quadratic.Out,\n  /**\n   * Quadratic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_IN_OUT: Easing.Quadratic.InOut,\n\n  /**\n   * Cubic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_IN: Easing.Cubic.In,\n  /**\n   * Cubic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_OUT: Easing.Cubic.Out,\n  /**\n   * Cubic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_IN_OUT: Easing.Cubic.InOut,\n\n  /**\n   * Quartic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_IN: Easing.Quartic.In,\n  /**\n   * Quartic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_OUT: Easing.Quartic.Out,\n  /**\n   * Quartic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_IN_OUT: Easing.Quartic.InOut,\n\n  /**\n   * Quintic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_IN: Easing.Quintic.In,\n  /**\n   * Quintic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_OUT: Easing.Quintic.Out,\n  /**\n   * Quintic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_IN_OUT: Easing.Quintic.InOut,\n\n  /**\n   * Sinusoidal in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_IN: Easing.Sinusoidal.In,\n  /**\n   * Sinusoidal out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_OUT: Easing.Sinusoidal.Out,\n  /**\n   * Sinusoidal in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_IN_OUT: Easing.Sinusoidal.InOut,\n\n  /**\n   * Exponential in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_IN: Easing.Exponential.In,\n  /**\n   * Exponential out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_OUT: Easing.Exponential.Out,\n  /**\n   * Exponential in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_IN_OUT: Easing.Exponential.InOut,\n\n  /**\n   * Circular in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_IN: Easing.Circular.In,\n  /**\n   * Circular out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_OUT: Easing.Circular.Out,\n  /**\n   * Circular in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_IN_OUT: Easing.Circular.InOut,\n\n  /**\n   * Elastic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_IN: Easing.Elastic.In,\n  /**\n   * Elastic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_OUT: Easing.Elastic.Out,\n  /**\n   * Elastic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_IN_OUT: Easing.Elastic.InOut,\n\n  /**\n   * Back in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_IN: Easing.Back.In,\n  /**\n   * Back out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_OUT: Easing.Back.Out,\n  /**\n   * Back in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_IN_OUT: Easing.Back.InOut,\n\n  /**\n   * Bounce in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_IN: Easing.Bounce.In,\n  /**\n   * Bounce out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_OUT: Easing.Bounce.Out,\n  /**\n   * Bounce in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_IN_OUT: Easing.Bounce.InOut,\n};\n\n/**\n * Function interface for implementing a custom easing function.\n * @callback EasingFunction.Callback\n * @param {Number} time The time in the range <code>[0, 1]</code>.\n * @returns {Number} The value of the function at the given time.\n *\n * @example\n * function quadraticIn(time) {\n *     return time * time;\n * }\n *\n * @example\n * function quadraticOut(time) {\n *     return time * (2.0 - time);\n * }\n */\n\n/* harmony default export */ const Core_EasingFunction = (Object.freeze(EasingFunction));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/QuadraticRealPolynomial.js\n\n\n\n/**\n * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuadraticRealPolynomial\n */\nconst QuadraticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quadratic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 2nd order monomial.\n * @param {Number} b The coefficient of the 1st order monomial.\n * @param {Number} c The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nQuadraticRealPolynomial.computeDiscriminant = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new Core_DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new Core_DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new Core_DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const discriminant = b * b - 4.0 * a * c;\n  return discriminant;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (\n    Core_Math.sign(left) !== Core_Math.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\n/**\n * Provides the real valued roots of the quadratic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 2nd order monomial.\n * @param {Number} b The coefficient of the 1st order monomial.\n * @param {Number} c The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nQuadraticRealPolynomial.computeRealRoots = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new Core_DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new Core_DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new Core_DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  if (a === 0.0) {\n    if (b === 0.0) {\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // Linear function: b * x + c = 0.\n    return [-c / b];\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    }\n\n    const cMagnitude = Math.abs(c);\n    const aMagnitude = Math.abs(a);\n\n    if (\n      cMagnitude < aMagnitude &&\n      cMagnitude / aMagnitude < Core_Math.EPSILON14\n    ) {\n      // c ~= 0.0.\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    } else if (\n      cMagnitude > aMagnitude &&\n      aMagnitude / cMagnitude < Core_Math.EPSILON14\n    ) {\n      // a ~= 0.0.\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // a * x^2 + c = 0\n    ratio = -c / a;\n\n    if (ratio < 0.0) {\n      // Both roots are complex.\n      return [];\n    }\n\n    // Both roots are real.\n    const root = Math.sqrt(ratio);\n    return [-root, root];\n  } else if (c === 0.0) {\n    // a * x^2 + b * x = 0\n    ratio = -b / a;\n    if (ratio < 0.0) {\n      return [ratio, 0.0];\n    }\n\n    return [0.0, ratio];\n  }\n\n  // a * x^2 + b * x + c = 0\n  const b2 = b * b;\n  const four_ac = 4.0 * a * c;\n  const radicand = addWithCancellationCheck(b2, -four_ac, Core_Math.EPSILON14);\n\n  if (radicand < 0.0) {\n    // Both roots are complex.\n    return [];\n  }\n\n  const q =\n    -0.5 *\n    addWithCancellationCheck(\n      b,\n      Core_Math.sign(b) * Math.sqrt(radicand),\n      Core_Math.EPSILON14\n    );\n  if (b > 0.0) {\n    return [q / a, c / q];\n  }\n\n  return [c / q, q / a];\n};\n/* harmony default export */ const Core_QuadraticRealPolynomial = (QuadraticRealPolynomial);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/CubicRealPolynomial.js\n\n\n\n/**\n * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace CubicRealPolynomial\n */\nconst CubicRealPolynomial = {};\n\n/**\n * Provides the discriminant of the cubic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 3rd order monomial.\n * @param {Number} b The coefficient of the 2nd order monomial.\n * @param {Number} c The coefficient of the 1st order monomial.\n * @param {Number} d The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nCubicRealPolynomial.computeDiscriminant = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new Core_DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new Core_DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new Core_DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new Core_DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const a2 = a * a;\n  const b2 = b * b;\n  const c2 = c * c;\n  const d2 = d * d;\n\n  const discriminant =\n    18.0 * a * b * c * d +\n    b2 * c2 -\n    27.0 * a2 * d2 -\n    4.0 * (a * c2 * c + b2 * b * d);\n  return discriminant;\n};\n\nfunction computeRealRoots(a, b, c, d) {\n  const A = a;\n  const B = b / 3.0;\n  const C = c / 3.0;\n  const D = d;\n\n  const AC = A * C;\n  const BD = B * D;\n  const B2 = B * B;\n  const C2 = C * C;\n  const delta1 = A * C - B2;\n  const delta2 = A * D - B * C;\n  const delta3 = B * D - C2;\n\n  const discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;\n  let temp;\n  let temp1;\n\n  if (discriminant < 0.0) {\n    let ABar;\n    let CBar;\n    let DBar;\n\n    if (B2 * BD >= AC * C2) {\n      ABar = A;\n      CBar = delta1;\n      DBar = -2.0 * B * delta1 + A * delta2;\n    } else {\n      ABar = D;\n      CBar = delta3;\n      DBar = -D * delta2 + 2.0 * C * delta3;\n    }\n\n    const s = DBar < 0.0 ? -1.0 : 1.0; // This is not Math.Sign()!\n    const temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);\n    temp1 = -DBar + temp0;\n\n    const x = temp1 / 2.0;\n    const p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);\n    const q = temp1 === temp0 ? -p : -CBar / p;\n\n    temp = CBar <= 0.0 ? p + q : -DBar / (p * p + q * q + CBar);\n\n    if (B2 * BD >= AC * C2) {\n      return [(temp - B) / A];\n    }\n\n    return [-D / (temp + C)];\n  }\n\n  const CBarA = delta1;\n  const DBarA = -2.0 * B * delta1 + A * delta2;\n\n  const CBarD = delta3;\n  const DBarD = -D * delta2 + 2.0 * C * delta3;\n\n  const squareRootOfDiscriminant = Math.sqrt(discriminant);\n  const halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;\n\n  let theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarA);\n  let cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  let temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  const numeratorLarge = temp1 + temp3 > 2.0 * B ? temp1 - B : temp3 - B;\n  const denominatorLarge = A;\n\n  const root1 = numeratorLarge / denominatorLarge;\n\n  theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarD);\n  cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  const numeratorSmall = -D;\n  const denominatorSmall = temp1 + temp3 < 2.0 * C ? temp1 + C : temp3 + C;\n\n  const root3 = numeratorSmall / denominatorSmall;\n\n  const E = denominatorLarge * denominatorSmall;\n  const F =\n    -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;\n  const G = numeratorLarge * numeratorSmall;\n\n  const root2 = (C * F - B * G) / (-B * F + C * E);\n\n  if (root1 <= root2) {\n    if (root1 <= root3) {\n      if (root2 <= root3) {\n        return [root1, root2, root3];\n      }\n      return [root1, root3, root2];\n    }\n    return [root3, root1, root2];\n  }\n  if (root1 <= root3) {\n    return [root2, root1, root3];\n  }\n  if (root2 <= root3) {\n    return [root2, root3, root1];\n  }\n  return [root3, root2, root1];\n}\n\n/**\n * Provides the real valued roots of the cubic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 3rd order monomial.\n * @param {Number} b The coefficient of the 2nd order monomial.\n * @param {Number} c The coefficient of the 1st order monomial.\n * @param {Number} d The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nCubicRealPolynomial.computeRealRoots = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new Core_DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new Core_DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new Core_DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new Core_DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  let roots;\n  let ratio;\n  if (a === 0.0) {\n    // Quadratic function: b * x^2 + c * x + d = 0.\n    return Core_QuadraticRealPolynomial.computeRealRoots(b, c, d);\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      if (d === 0.0) {\n        // 3rd order monomial: a * x^3 = 0.\n        return [0.0, 0.0, 0.0];\n      }\n\n      // a * x^3 + d = 0\n      ratio = -d / a;\n      const root =\n        ratio < 0.0 ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);\n      return [root, root, root];\n    } else if (d === 0.0) {\n      // x * (a * x^2 + c) = 0.\n      roots = Core_QuadraticRealPolynomial.computeRealRoots(a, 0, c);\n\n      // Return the roots in ascending order.\n      if (roots.Length === 0) {\n        return [0.0];\n      }\n      return [roots[0], 0.0, roots[1]];\n    }\n\n    // Deflated cubic polynomial: a * x^3 + c * x + d= 0.\n    return computeRealRoots(a, 0, c, d);\n  } else if (c === 0.0) {\n    if (d === 0.0) {\n      // x^2 * (a * x + b) = 0.\n      ratio = -b / a;\n      if (ratio < 0.0) {\n        return [ratio, 0.0, 0.0];\n      }\n      return [0.0, 0.0, ratio];\n    }\n    // a * x^3 + b * x^2 + d = 0.\n    return computeRealRoots(a, b, 0, d);\n  } else if (d === 0.0) {\n    // x * (a * x^2 + b * x + c) = 0\n    roots = Core_QuadraticRealPolynomial.computeRealRoots(a, b, c);\n\n    // Return the roots in ascending order.\n    if (roots.length === 0) {\n      return [0.0];\n    } else if (roots[1] <= 0.0) {\n      return [roots[0], roots[1], 0.0];\n    } else if (roots[0] >= 0.0) {\n      return [0.0, roots[0], roots[1]];\n    }\n    return [roots[0], 0.0, roots[1]];\n  }\n\n  return computeRealRoots(a, b, c, d);\n};\n/* harmony default export */ const Core_CubicRealPolynomial = (CubicRealPolynomial);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/QuarticRealPolynomial.js\n\n\n\n\n\n/**\n * Defines functions for 4th order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuarticRealPolynomial\n */\nconst QuarticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quartic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 4th order monomial.\n * @param {Number} b The coefficient of the 3rd order monomial.\n * @param {Number} c The coefficient of the 2nd order monomial.\n * @param {Number} d The coefficient of the 1st order monomial.\n * @param {Number} e The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nQuarticRealPolynomial.computeDiscriminant = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new Core_DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new Core_DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new Core_DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new Core_DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new Core_DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const a2 = a * a;\n  const a3 = a2 * a;\n  const b2 = b * b;\n  const b3 = b2 * b;\n  const c2 = c * c;\n  const c3 = c2 * c;\n  const d2 = d * d;\n  const d3 = d2 * d;\n  const e2 = e * e;\n  const e3 = e2 * e;\n\n  const discriminant =\n    b2 * c2 * d2 -\n    4.0 * b3 * d3 -\n    4.0 * a * c3 * d2 +\n    18 * a * b * c * d3 -\n    27.0 * a2 * d2 * d2 +\n    256.0 * a3 * e3 +\n    e *\n      (18.0 * b3 * c * d -\n        4.0 * b2 * c3 +\n        16.0 * a * c2 * c2 -\n        80.0 * a * b * c2 * d -\n        6.0 * a * b2 * d2 +\n        144.0 * a2 * c * d2) +\n    e2 *\n      (144.0 * a * b2 * c -\n        27.0 * b2 * b2 -\n        128.0 * a2 * c2 -\n        192.0 * a2 * b * d);\n  return discriminant;\n};\n\nfunction original(a3, a2, a1, a0) {\n  const a3Squared = a3 * a3;\n\n  const p = a2 - (3.0 * a3Squared) / 8.0;\n  const q = a1 - (a2 * a3) / 2.0 + (a3Squared * a3) / 8.0;\n  const r =\n    a0 -\n    (a1 * a3) / 4.0 +\n    (a2 * a3Squared) / 16.0 -\n    (3.0 * a3Squared * a3Squared) / 256.0;\n\n  // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.\n  const cubicRoots = Core_CubicRealPolynomial.computeRealRoots(\n    1.0,\n    2.0 * p,\n    p * p - 4.0 * r,\n    -q * q\n  );\n\n  if (cubicRoots.length > 0) {\n    const temp = -a3 / 4.0;\n\n    // Use the largest positive root.\n    const hSquared = cubicRoots[cubicRoots.length - 1];\n\n    if (Math.abs(hSquared) < Core_Math.EPSILON14) {\n      // y^4 + p y^2 + r = 0.\n      const roots = Core_QuadraticRealPolynomial.computeRealRoots(1.0, p, r);\n\n      if (roots.length === 2) {\n        const root0 = roots[0];\n        const root1 = roots[1];\n\n        let y;\n        if (root0 >= 0.0 && root1 >= 0.0) {\n          const y0 = Math.sqrt(root0);\n          const y1 = Math.sqrt(root1);\n\n          return [temp - y1, temp - y0, temp + y0, temp + y1];\n        } else if (root0 >= 0.0 && root1 < 0.0) {\n          y = Math.sqrt(root0);\n          return [temp - y, temp + y];\n        } else if (root0 < 0.0 && root1 >= 0.0) {\n          y = Math.sqrt(root1);\n          return [temp - y, temp + y];\n        }\n      }\n      return [];\n    } else if (hSquared > 0.0) {\n      const h = Math.sqrt(hSquared);\n\n      const m = (p + hSquared - q / h) / 2.0;\n      const n = (p + hSquared + q / h) / 2.0;\n\n      // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);\n      const roots1 = Core_QuadraticRealPolynomial.computeRealRoots(1.0, h, m);\n      const roots2 = Core_QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);\n\n      if (roots1.length !== 0) {\n        roots1[0] += temp;\n        roots1[1] += temp;\n\n        if (roots2.length !== 0) {\n          roots2[0] += temp;\n          roots2[1] += temp;\n\n          if (roots1[1] <= roots2[0]) {\n            return [roots1[0], roots1[1], roots2[0], roots2[1]];\n          } else if (roots2[1] <= roots1[0]) {\n            return [roots2[0], roots2[1], roots1[0], roots1[1]];\n          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n            return [roots2[0], roots1[0], roots1[1], roots2[1]];\n          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n            return [roots1[0], roots2[0], roots2[1], roots1[1]];\n          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n            return [roots2[0], roots1[0], roots2[1], roots1[1]];\n          }\n          return [roots1[0], roots2[0], roots1[1], roots2[1]];\n        }\n        return roots1;\n      }\n\n      if (roots2.length !== 0) {\n        roots2[0] += temp;\n        roots2[1] += temp;\n\n        return roots2;\n      }\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction neumark(a3, a2, a1, a0) {\n  const a1Squared = a1 * a1;\n  const a2Squared = a2 * a2;\n  const a3Squared = a3 * a3;\n\n  const p = -2.0 * a2;\n  const q = a1 * a3 + a2Squared - 4.0 * a0;\n  const r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;\n\n  const cubicRoots = Core_CubicRealPolynomial.computeRealRoots(1.0, p, q, r);\n\n  if (cubicRoots.length > 0) {\n    // Use the most positive root\n    const y = cubicRoots[0];\n\n    const temp = a2 - y;\n    const tempSquared = temp * temp;\n\n    const g1 = a3 / 2.0;\n    const h1 = temp / 2.0;\n\n    const m = tempSquared - 4.0 * a0;\n    const mError = tempSquared + 4.0 * Math.abs(a0);\n\n    const n = a3Squared - 4.0 * y;\n    const nError = a3Squared + 4.0 * Math.abs(y);\n\n    let g2;\n    let h2;\n\n    if (y < 0.0 || m * nError < n * mError) {\n      const squareRootOfN = Math.sqrt(n);\n      g2 = squareRootOfN / 2.0;\n      h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;\n    } else {\n      const squareRootOfM = Math.sqrt(m);\n      g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;\n      h2 = squareRootOfM / 2.0;\n    }\n\n    let G;\n    let g;\n    if (g1 === 0.0 && g2 === 0.0) {\n      G = 0.0;\n      g = 0.0;\n    } else if (Core_Math.sign(g1) === Core_Math.sign(g2)) {\n      G = g1 + g2;\n      g = y / G;\n    } else {\n      g = g1 - g2;\n      G = y / g;\n    }\n\n    let H;\n    let h;\n    if (h1 === 0.0 && h2 === 0.0) {\n      H = 0.0;\n      h = 0.0;\n    } else if (Core_Math.sign(h1) === Core_Math.sign(h2)) {\n      H = h1 + h2;\n      h = a0 / H;\n    } else {\n      h = h1 - h2;\n      H = a0 / h;\n    }\n\n    // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);\n    const roots1 = Core_QuadraticRealPolynomial.computeRealRoots(1.0, G, H);\n    const roots2 = Core_QuadraticRealPolynomial.computeRealRoots(1.0, g, h);\n\n    if (roots1.length !== 0) {\n      if (roots2.length !== 0) {\n        if (roots1[1] <= roots2[0]) {\n          return [roots1[0], roots1[1], roots2[0], roots2[1]];\n        } else if (roots2[1] <= roots1[0]) {\n          return [roots2[0], roots2[1], roots1[0], roots1[1]];\n        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n          return [roots2[0], roots1[0], roots1[1], roots2[1]];\n        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n          return [roots1[0], roots2[0], roots2[1], roots1[1]];\n        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n          return [roots2[0], roots1[0], roots2[1], roots1[1]];\n        }\n        return [roots1[0], roots2[0], roots1[1], roots2[1]];\n      }\n      return roots1;\n    }\n    if (roots2.length !== 0) {\n      return roots2;\n    }\n  }\n  return [];\n}\n\n/**\n * Provides the real valued roots of the quartic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 4th order monomial.\n * @param {Number} b The coefficient of the 3rd order monomial.\n * @param {Number} c The coefficient of the 2nd order monomial.\n * @param {Number} d The coefficient of the 1st order monomial.\n * @param {Number} e The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nQuarticRealPolynomial.computeRealRoots = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new Core_DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new Core_DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new Core_DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new Core_DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new Core_DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  if (Math.abs(a) < Core_Math.EPSILON15) {\n    return Core_CubicRealPolynomial.computeRealRoots(b, c, d, e);\n  }\n  const a3 = b / a;\n  const a2 = c / a;\n  const a1 = d / a;\n  const a0 = e / a;\n\n  let k = a3 < 0.0 ? 1 : 0;\n  k += a2 < 0.0 ? k + 1 : k;\n  k += a1 < 0.0 ? k + 1 : k;\n  k += a0 < 0.0 ? k + 1 : k;\n\n  switch (k) {\n    case 0:\n      return original(a3, a2, a1, a0);\n    case 1:\n      return neumark(a3, a2, a1, a0);\n    case 2:\n      return neumark(a3, a2, a1, a0);\n    case 3:\n      return original(a3, a2, a1, a0);\n    case 4:\n      return original(a3, a2, a1, a0);\n    case 5:\n      return neumark(a3, a2, a1, a0);\n    case 6:\n      return original(a3, a2, a1, a0);\n    case 7:\n      return original(a3, a2, a1, a0);\n    case 8:\n      return neumark(a3, a2, a1, a0);\n    case 9:\n      return original(a3, a2, a1, a0);\n    case 10:\n      return original(a3, a2, a1, a0);\n    case 11:\n      return neumark(a3, a2, a1, a0);\n    case 12:\n      return original(a3, a2, a1, a0);\n    case 13:\n      return original(a3, a2, a1, a0);\n    case 14:\n      return original(a3, a2, a1, a0);\n    case 15:\n      return original(a3, a2, a1, a0);\n    default:\n      return undefined;\n  }\n};\n/* harmony default export */ const Core_QuarticRealPolynomial = (QuarticRealPolynomial);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Ray.js\n\n\n\n\n\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\nfunction Ray(origin, direction) {\n  direction = Core_Cartesian3.clone(Core_defaultValue(direction, Core_Cartesian3.ZERO));\n  if (!Core_Cartesian3.equals(direction, Core_Cartesian3.ZERO)) {\n    Core_Cartesian3.normalize(direction, direction);\n  }\n\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.origin = Core_Cartesian3.clone(Core_defaultValue(origin, Core_Cartesian3.ZERO));\n\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n  this.direction = direction;\n}\n\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\nRay.clone = function (ray, result) {\n  if (!Core_defined(ray)) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n  result.origin = Core_Cartesian3.clone(ray.origin);\n  result.direction = Core_Cartesian3.clone(ray.direction);\n  return result;\n};\n\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {Number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);\n */\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"ray\", ray);\n  Core_Check.typeOf.number(\"t\", t);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  result = Core_Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Core_Cartesian3.add(ray.origin, result, result);\n};\n/* harmony default export */ const Core_Ray = (Ray);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/IntersectionTests.js\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @namespace IntersectionTests\n */\nconst IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(ray)) {\n    throw new Core_DeveloperError(\"ray is required.\");\n  }\n  if (!Core_defined(plane)) {\n    throw new Core_DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const normal = plane.normal;\n  const denominator = Core_Cartesian3.dot(normal, direction);\n\n  if (Math.abs(denominator) < Core_Math.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n\n  const t = (-plane.distance - Core_Cartesian3.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = Core_Cartesian3.multiplyByScalar(direction, t, result);\n  return Core_Cartesian3.add(origin, result, result);\n};\n\nconst scratchEdge0 = new Core_Cartesian3();\nconst scratchEdge1 = new Core_Cartesian3();\nconst scratchPVec = new Core_Cartesian3();\nconst scratchTVec = new Core_Cartesian3();\nconst scratchQVec = new Core_Cartesian3();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {Number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(ray)) {\n    throw new Core_DeveloperError(\"ray is required.\");\n  }\n  if (!Core_defined(p0)) {\n    throw new Core_DeveloperError(\"p0 is required.\");\n  }\n  if (!Core_defined(p1)) {\n    throw new Core_DeveloperError(\"p1 is required.\");\n  }\n  if (!Core_defined(p2)) {\n    throw new Core_DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = Core_defaultValue(cullBackFaces, false);\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const edge0 = Core_Cartesian3.subtract(p1, p0, scratchEdge0);\n  const edge1 = Core_Cartesian3.subtract(p2, p0, scratchEdge1);\n\n  const p = Core_Cartesian3.cross(direction, edge1, scratchPVec);\n  const det = Core_Cartesian3.dot(edge0, p);\n\n  let tvec;\n  let q;\n\n  let u;\n  let v;\n  let t;\n\n  if (cullBackFaces) {\n    if (det < Core_Math.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = Core_Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Core_Cartesian3.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = Core_Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Core_Cartesian3.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = Core_Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < Core_Math.EPSILON6) {\n      return undefined;\n    }\n    const invDet = 1.0 / det;\n\n    tvec = Core_Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Core_Cartesian3.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = Core_Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Core_Cartesian3.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = Core_Cartesian3.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!Core_defined(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  Core_Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Core_Cartesian3.add(ray.origin, result, result);\n};\n\nconst scratchLineSegmentTriangleRay = new Core_Ray();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (\n  v0,\n  v1,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(v0)) {\n    throw new Core_DeveloperError(\"v0 is required.\");\n  }\n  if (!Core_defined(v1)) {\n    throw new Core_DeveloperError(\"v1 is required.\");\n  }\n  if (!Core_defined(p0)) {\n    throw new Core_DeveloperError(\"p0 is required.\");\n  }\n  if (!Core_defined(p1)) {\n    throw new Core_DeveloperError(\"p1 is required.\");\n  }\n  if (!Core_defined(p2)) {\n    throw new Core_DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentTriangleRay;\n  Core_Cartesian3.clone(v0, ray.origin);\n  Core_Cartesian3.subtract(v1, v0, ray.direction);\n  Core_Cartesian3.normalize(ray.direction, ray.direction);\n\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!Core_defined(t) || t < 0.0 || t > Core_Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  Core_Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Core_Cartesian3.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  const det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    const denom = 1.0 / (2.0 * a);\n    const disc = Math.sqrt(det);\n    const root0 = (-b + disc) * denom;\n    const root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  const root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nconst raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0,\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!Core_defined(result)) {\n    result = new Core_Interval();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const center = sphere.center;\n  const radiusSquared = sphere.radius * sphere.radius;\n\n  const diff = Core_Cartesian3.subtract(origin, center, scratchPVec);\n\n  const a = Core_Cartesian3.dot(direction, direction);\n  const b = 2.0 * Core_Cartesian3.dot(direction, diff);\n  const c = Core_Cartesian3.magnitudeSquared(diff) - radiusSquared;\n\n  const roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!Core_defined(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(ray)) {\n    throw new Core_DeveloperError(\"ray is required.\");\n  }\n  if (!Core_defined(sphere)) {\n    throw new Core_DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  result = raySphere(ray, sphere, result);\n  if (!Core_defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nconst scratchLineSegmentRay = new Core_Ray();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(p0)) {\n    throw new Core_DeveloperError(\"p0 is required.\");\n  }\n  if (!Core_defined(p1)) {\n    throw new Core_DeveloperError(\"p1 is required.\");\n  }\n  if (!Core_defined(sphere)) {\n    throw new Core_DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentRay;\n  Core_Cartesian3.clone(p0, ray.origin);\n  const direction = Core_Cartesian3.subtract(p1, p0, ray.direction);\n\n  const maxT = Core_Cartesian3.magnitude(direction);\n  Core_Cartesian3.normalize(direction, direction);\n\n  result = raySphere(ray, sphere, result);\n  if (!Core_defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nconst scratchQ = new Core_Cartesian3();\nconst scratchW = new Core_Cartesian3();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(ray)) {\n    throw new Core_DeveloperError(\"ray is required.\");\n  }\n  if (!Core_defined(ellipsoid)) {\n    throw new Core_DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseRadii = ellipsoid.oneOverRadii;\n  const q = Core_Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  const w = Core_Cartesian3.multiplyComponents(\n    inverseRadii,\n    ray.direction,\n    scratchW\n  );\n\n  const q2 = Core_Cartesian3.magnitudeSquared(q);\n  const qw = Core_Cartesian3.dot(q, w);\n\n  let difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    const qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = Core_Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      const root0 = temp / w2;\n      const root1 = difference / temp;\n      if (root0 < root1) {\n        return new Core_Interval(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0,\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    const root = Math.sqrt(difference / w2);\n    return new Core_Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = Core_Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new Core_Interval(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Core_Cartesian3.magnitudeSquared(w);\n    return new Core_Interval(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\n\nfunction IntersectionTests_addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (\n    Core_Math.sign(left) !== Core_Math.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\nfunction quadraticVectorExpression(A, b, c, x, w) {\n  const xSquared = x * x;\n  const wSquared = w * w;\n\n  const l2 = (A[Core_Matrix3.COLUMN1ROW1] - A[Core_Matrix3.COLUMN2ROW2]) * wSquared;\n  const l1 =\n    w *\n    (x *\n      IntersectionTests_addWithCancellationCheck(\n        A[Core_Matrix3.COLUMN1ROW0],\n        A[Core_Matrix3.COLUMN0ROW1],\n        Core_Math.EPSILON15\n      ) +\n      b.y);\n  const l0 =\n    A[Core_Matrix3.COLUMN0ROW0] * xSquared +\n    A[Core_Matrix3.COLUMN2ROW2] * wSquared +\n    x * b.x +\n    c;\n\n  const r1 =\n    wSquared *\n    IntersectionTests_addWithCancellationCheck(\n      A[Core_Matrix3.COLUMN2ROW1],\n      A[Core_Matrix3.COLUMN1ROW2],\n      Core_Math.EPSILON15\n    );\n  const r0 =\n    w *\n    (x *\n      IntersectionTests_addWithCancellationCheck(A[Core_Matrix3.COLUMN2ROW0], A[Core_Matrix3.COLUMN0ROW2]) +\n      b.z);\n\n  let cosines;\n  const solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = Core_QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    const cosine0 = cosines[0];\n    const sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Core_Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Core_Cartesian3(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      const cosine1 = cosines[1];\n      const sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Core_Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Core_Cartesian3(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  const r0Squared = r0 * r0;\n  const r1Squared = r1 * r1;\n  const l2Squared = l2 * l2;\n  const r0r1 = r0 * r1;\n\n  const c4 = l2Squared + r1Squared;\n  const c3 = 2.0 * (l1 * l2 + r0r1);\n  const c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  const c1 = 2.0 * (l0 * l1 - r0r1);\n  const c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = Core_QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  const length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const cosine = cosines[i];\n    const cosineSquared = cosine * cosine;\n    const sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    const sine = Math.sqrt(sineSquared);\n\n    //const left = l2 * cosineSquared + l1 * cosine + l0;\n    let left;\n    if (Core_Math.sign(l2) === Core_Math.sign(l0)) {\n      left = IntersectionTests_addWithCancellationCheck(\n        l2 * cosineSquared + l0,\n        l1 * cosine,\n        Core_Math.EPSILON12\n      );\n    } else if (Core_Math.sign(l0) === Core_Math.sign(l1 * cosine)) {\n      left = IntersectionTests_addWithCancellationCheck(\n        l2 * cosineSquared,\n        l1 * cosine + l0,\n        Core_Math.EPSILON12\n      );\n    } else {\n      left = IntersectionTests_addWithCancellationCheck(\n        l2 * cosineSquared + l1 * cosine,\n        l0,\n        Core_Math.EPSILON12\n      );\n    }\n\n    const right = IntersectionTests_addWithCancellationCheck(\n      r1 * cosine,\n      r0,\n      Core_Math.EPSILON15\n    );\n    const product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new Core_Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Core_Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Core_Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Core_Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Core_Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n}\n\nconst firstAxisScratch = new Core_Cartesian3();\nconst secondAxisScratch = new Core_Cartesian3();\nconst thirdAxisScratch = new Core_Cartesian3();\nconst referenceScratch = new Core_Cartesian3();\nconst bCart = new Core_Cartesian3();\nconst bScratch = new Core_Matrix3();\nconst btScratch = new Core_Matrix3();\nconst diScratch = new Core_Matrix3();\nconst dScratch = new Core_Matrix3();\nconst cScratch = new Core_Matrix3();\nconst tempMatrix = new Core_Matrix3();\nconst aScratch = new Core_Matrix3();\nconst sScratch = new Core_Cartesian3();\nconst closestScratch = new Core_Cartesian3();\nconst surfPointScratch = new Core_Cartographic();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(ray)) {\n    throw new Core_DeveloperError(\"ray is required.\");\n  }\n  if (!Core_defined(ellipsoid)) {\n    throw new Core_DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const position = ray.origin;\n  const direction = ray.direction;\n\n  if (!Core_Cartesian3.equals(position, Core_Cartesian3.ZERO)) {\n    const normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (Core_Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  const intersects = Core_defined(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  const f = ellipsoid.transformPositionToScaledSpace(\n    direction,\n    firstAxisScratch\n  );\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  const firstAxis = Core_Cartesian3.normalize(f, f);\n  const reference = Core_Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  const secondAxis = Core_Cartesian3.normalize(\n    Core_Cartesian3.cross(reference, firstAxis, secondAxisScratch),\n    secondAxisScratch\n  );\n  const thirdAxis = Core_Cartesian3.normalize(\n    Core_Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch),\n    thirdAxisScratch\n  );\n  const B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n\n  const B_T = Core_Matrix3.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  const D_I = Core_Matrix3.fromScale(ellipsoid.radii, diScratch);\n  const D = Core_Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n  const C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n\n  const temp = Core_Matrix3.multiply(\n    Core_Matrix3.multiply(B_T, D, tempMatrix),\n    C,\n    tempMatrix\n  );\n  const A = Core_Matrix3.multiply(\n    Core_Matrix3.multiply(temp, D_I, aScratch),\n    B,\n    aScratch\n  );\n  const b = Core_Matrix3.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  const solutions = quadraticVectorExpression(\n    A,\n    Core_Cartesian3.negate(b, firstAxisScratch),\n    0.0,\n    0.0,\n    1.0\n  );\n\n  let s;\n  let altitude;\n  const length = solutions.length;\n  if (length > 0) {\n    let closest = Core_Cartesian3.clone(Core_Cartesian3.ZERO, closestScratch);\n    let maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (let i = 0; i < length; ++i) {\n      s = Core_Matrix3.multiplyByVector(\n        D_I,\n        Core_Matrix3.multiplyByVector(B, solutions[i], sScratch),\n        sScratch\n      );\n      const v = Core_Cartesian3.normalize(\n        Core_Cartesian3.subtract(s, position, referenceScratch),\n        referenceScratch\n      );\n      const dotProduct = Core_Cartesian3.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Core_Cartesian3.clone(s, closest);\n      }\n    }\n\n    const surfacePoint = ellipsoid.cartesianToCartographic(\n      closest,\n      surfPointScratch\n    );\n    maximumValue = Core_Math.clamp(maximumValue, 0.0, 1.0);\n    altitude =\n      Core_Cartesian3.magnitude(\n        Core_Cartesian3.subtract(closest, position, referenceScratch)\n      ) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Core_Cartesian3());\n  }\n\n  return undefined;\n};\n\nconst lineSegmentPlaneDifference = new Core_Cartesian3();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (\n  endPoint0,\n  endPoint1,\n  plane,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(endPoint0)) {\n    throw new Core_DeveloperError(\"endPoint0 is required.\");\n  }\n  if (!Core_defined(endPoint1)) {\n    throw new Core_DeveloperError(\"endPoint1 is required.\");\n  }\n  if (!Core_defined(plane)) {\n    throw new Core_DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  const difference = Core_Cartesian3.subtract(\n    endPoint1,\n    endPoint0,\n    lineSegmentPlaneDifference\n  );\n  const normal = plane.normal;\n  const nDotDiff = Core_Cartesian3.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < Core_Math.EPSILON6) {\n    return undefined;\n  }\n\n  const nDotP0 = Core_Cartesian3.dot(normal, endPoint0);\n  const t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  Core_Cartesian3.multiplyByScalar(difference, t, result);\n  Core_Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n * const p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(p0) || !Core_defined(p1) || !Core_defined(p2) || !Core_defined(plane)) {\n    throw new Core_DeveloperError(\"p0, p1, p2, and plane are required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planeNormal = plane.normal;\n  const planeD = plane.distance;\n  const p0Behind = Core_Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  const p1Behind = Core_Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  const p2Behind = Core_Cartesian3.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  let u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Core_Cartesian3();\n    u2 = new Core_Cartesian3();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          3,\n          4,\n\n          // In front\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n        ],\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          3,\n          4,\n\n          // In front\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n        ],\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          3,\n          4,\n\n          // In front\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n        ],\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n\n          // In front\n          0,\n          3,\n          4,\n        ],\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n\n          // In front\n          1,\n          3,\n          4,\n        ],\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n\n          // In front\n          2,\n          3,\n          4,\n        ],\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\n/* harmony default export */ const Core_IntersectionTests = (IntersectionTests);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Plane.js\n\n\n\n\n\n\n\n\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"normal\", normal);\n  if (\n    !Core_Math.equalsEpsilon(\n      Core_Cartesian3.magnitude(normal),\n      1.0,\n      Core_Math.EPSILON6\n    )\n  ) {\n    throw new Core_DeveloperError(\"normal must be normalized.\");\n  }\n  Core_Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n  this.normal = Core_Cartesian3.clone(normal);\n\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {Number}\n   */\n  this.distance = distance;\n}\n\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"point\", point);\n  Core_Check.typeOf.object(\"normal\", normal);\n  if (\n    !Core_Math.equalsEpsilon(\n      Core_Cartesian3.magnitude(normal),\n      1.0,\n      Core_Math.EPSILON6\n    )\n  ) {\n    throw new Core_DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = -Core_Cartesian3.dot(normal, point);\n\n  if (!Core_defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Core_Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\nconst scratchNormal = new Core_Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"coefficients\", coefficients);\n  //>>includeEnd('debug');\n\n  const normal = Core_Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  const distance = coefficients.w;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !Core_Math.equalsEpsilon(\n      Core_Cartesian3.magnitude(normal),\n      1.0,\n      Core_Math.EPSILON6\n    )\n  ) {\n    throw new Core_DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Core_Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {Number} The signed shortest distance of the point to the plane.\n */\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"plane\", plane);\n  Core_Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  return Core_Cartesian3.dot(plane.normal, point) + plane.distance;\n};\n\nconst scratchCartesian = new Core_Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"plane\", plane);\n  Core_Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  // projectedPoint = point - (normal.point + scale) * normal\n  const pointDistance = Plane.getPointDistance(plane, point);\n  const scaledNormal = Core_Cartesian3.multiplyByScalar(\n    plane.normal,\n    pointDistance,\n    scratchCartesian\n  );\n\n  return Core_Cartesian3.subtract(point, scaledNormal, result);\n};\n\nconst scratchInverseTranspose = new Core_Matrix4();\nconst scratchPlaneCartesian4 = new Core_Cartesian4();\nconst scratchTransformNormal = new Core_Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"plane\", plane);\n  Core_Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const normal = plane.normal;\n  const distance = plane.distance;\n  const inverseTranspose = Core_Matrix4.inverseTranspose(\n    transform,\n    scratchInverseTranspose\n  );\n  let planeAsCartesian4 = Core_Cartesian4.fromElements(\n    normal.x,\n    normal.y,\n    normal.z,\n    distance,\n    scratchPlaneCartesian4\n  );\n  planeAsCartesian4 = Core_Matrix4.multiplyByVector(\n    inverseTranspose,\n    planeAsCartesian4,\n    planeAsCartesian4\n  );\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Core_Cartesian3.fromCartesian4(\n    planeAsCartesian4,\n    scratchTransformNormal\n  );\n\n  planeAsCartesian4 = Core_Cartesian4.divideByScalar(\n    planeAsCartesian4,\n    Core_Cartesian3.magnitude(transformedNormal),\n    planeAsCartesian4\n  );\n\n  return Plane.fromCartesian4(planeAsCartesian4, result);\n};\n\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n\n  Core_Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n\n  return result;\n};\n\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"left\", left);\n  Core_Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.distance === right.distance &&\n    Core_Cartesian3.equals(left.normal, right.normal)\n  );\n};\n\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Core_Cartesian3.UNIT_Z, 0.0));\n\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Core_Cartesian3.UNIT_X, 0.0));\n\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Core_Cartesian3.UNIT_Y, 0.0));\n/* harmony default export */ const Core_Plane = (Plane);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/CullingVolume.js\n\n\n\n\n\n\n\n\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = Core_defaultValue(planes, []);\n}\n\nconst faces = [new Core_Cartesian3(), new Core_Cartesian3(), new Core_Cartesian3()];\nCore_Cartesian3.clone(Core_Cartesian3.UNIT_X, faces[0]);\nCore_Cartesian3.clone(Core_Cartesian3.UNIT_Y, faces[1]);\nCore_Cartesian3.clone(Core_Cartesian3.UNIT_Z, faces[2]);\n\nconst scratchPlaneCenter = new Core_Cartesian3();\nconst scratchPlaneNormal = new Core_Cartesian3();\nconst scratchPlane = new Core_Plane(new Core_Cartesian3(1.0, 0.0, 0.0), 0.0);\n\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(boundingSphere)) {\n    throw new Core_DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new CullingVolume();\n  }\n\n  const length = faces.length;\n  const planes = result.planes;\n  planes.length = 2 * length;\n\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n\n  let planeIndex = 0;\n\n  for (let i = 0; i < length; ++i) {\n    const faceNormal = faces[i];\n\n    let plane0 = planes[planeIndex];\n    let plane1 = planes[planeIndex + 1];\n\n    if (!Core_defined(plane0)) {\n      plane0 = planes[planeIndex] = new Core_Cartesian4();\n    }\n    if (!Core_defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Core_Cartesian4();\n    }\n\n    Core_Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Core_Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Core_Cartesian3.dot(faceNormal, scratchPlaneCenter);\n\n    Core_Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Core_Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Core_Cartesian3.dot(\n      Core_Cartesian3.negate(faceNormal, scratchPlaneNormal),\n      scratchPlaneCenter\n    );\n\n    planeIndex += 2;\n  }\n\n  return result;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(boundingVolume)) {\n    throw new Core_DeveloperError(\"boundingVolume is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this.planes;\n  let intersecting = false;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    const result = boundingVolume.intersectPlane(\n      Core_Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Core_Intersect.OUTSIDE) {\n      return Core_Intersect.OUTSIDE;\n    } else if (result === Core_Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n\n  return intersecting ? Core_Intersect.INTERSECTING : Core_Intersect.INSIDE;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\n  boundingVolume,\n  parentPlaneMask\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(boundingVolume)) {\n    throw new Core_DeveloperError(\"boundingVolume is required.\");\n  }\n  if (!Core_defined(parentPlaneMask)) {\n    throw new Core_DeveloperError(\"parentPlaneMask is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n\n  const planes = this.planes;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    const result = boundingVolume.intersectPlane(\n      Core_Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Core_Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Core_Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n};\n\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\n/* harmony default export */ const Core_CullingVolume = (CullingVolume);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/OrthographicOffCenterFrustum.js\n\n\n\n\n\n\n\n\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicOffCenterFrustum();\n * frustum.right = maxRadii * Cesium.Math.PI;\n * frustum.left = -c.frustum.right;\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\n * frustum.bottom = -c.frustum.top;\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicOffCenterFrustum(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * The right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * The top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * The bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = Core_defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0;\n   */\n  this.far = Core_defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  this._cullingVolume = new Core_CullingVolume();\n  this._orthographicMatrix = new Core_Matrix4();\n}\n\nfunction OrthographicOffCenterFrustum_update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !Core_defined(frustum.right) ||\n    !Core_defined(frustum.left) ||\n    !Core_defined(frustum.top) ||\n    !Core_defined(frustum.bottom) ||\n    !Core_defined(frustum.near) ||\n    !Core_defined(frustum.far)\n  ) {\n    throw new Core_DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (\n    frustum.top !== frustum._top ||\n    frustum.bottom !== frustum._bottom ||\n    frustum.left !== frustum._left ||\n    frustum.right !== frustum._right ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.left > frustum.right) {\n      throw new Core_DeveloperError(\"right must be greater than left.\");\n    }\n    if (frustum.bottom > frustum.top) {\n      throw new Core_DeveloperError(\"top must be greater than bottom.\");\n    }\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new Core_DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = frustum.left;\n    frustum._right = frustum.right;\n    frustum._top = frustum.top;\n    frustum._bottom = frustum.bottom;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._orthographicMatrix = Core_Matrix4.computeOrthographicOffCenter(\n      frustum.left,\n      frustum.right,\n      frustum.bottom,\n      frustum.top,\n      frustum.near,\n      frustum.far,\n      frustum._orthographicMatrix\n    );\n  }\n}\n\nObject.defineProperties(OrthographicOffCenterFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      OrthographicOffCenterFrustum_update(this);\n      return this._orthographicMatrix;\n    },\n  },\n});\n\nconst getPlanesRight = new Core_Cartesian3();\nconst getPlanesNearCenter = new Core_Cartesian3();\nconst getPlanesPoint = new Core_Cartesian3();\nconst negateScratch = new Core_Cartesian3();\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(position)) {\n    throw new Core_DeveloperError(\"position is required.\");\n  }\n  if (!Core_defined(direction)) {\n    throw new Core_DeveloperError(\"direction is required.\");\n  }\n  if (!Core_defined(up)) {\n    throw new Core_DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n\n  const right = Core_Cartesian3.cross(direction, up, getPlanesRight);\n  Core_Cartesian3.normalize(right, right);\n  const nearCenter = getPlanesNearCenter;\n  Core_Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Core_Cartesian3.add(position, nearCenter, nearCenter);\n\n  const point = getPlanesPoint;\n\n  // Left plane\n  Core_Cartesian3.multiplyByScalar(right, l, point);\n  Core_Cartesian3.add(nearCenter, point, point);\n\n  let plane = planes[0];\n  if (!Core_defined(plane)) {\n    plane = planes[0] = new Core_Cartesian4();\n  }\n  plane.x = right.x;\n  plane.y = right.y;\n  plane.z = right.z;\n  plane.w = -Core_Cartesian3.dot(right, point);\n\n  // Right plane\n  Core_Cartesian3.multiplyByScalar(right, r, point);\n  Core_Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[1];\n  if (!Core_defined(plane)) {\n    plane = planes[1] = new Core_Cartesian4();\n  }\n  plane.x = -right.x;\n  plane.y = -right.y;\n  plane.z = -right.z;\n  plane.w = -Core_Cartesian3.dot(Core_Cartesian3.negate(right, negateScratch), point);\n\n  // Bottom plane\n  Core_Cartesian3.multiplyByScalar(up, b, point);\n  Core_Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[2];\n  if (!Core_defined(plane)) {\n    plane = planes[2] = new Core_Cartesian4();\n  }\n  plane.x = up.x;\n  plane.y = up.y;\n  plane.z = up.z;\n  plane.w = -Core_Cartesian3.dot(up, point);\n\n  // Top plane\n  Core_Cartesian3.multiplyByScalar(up, t, point);\n  Core_Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[3];\n  if (!Core_defined(plane)) {\n    plane = planes[3] = new Core_Cartesian4();\n  }\n  plane.x = -up.x;\n  plane.y = -up.y;\n  plane.z = -up.z;\n  plane.w = -Core_Cartesian3.dot(Core_Cartesian3.negate(up, negateScratch), point);\n\n  // Near plane\n  plane = planes[4];\n  if (!Core_defined(plane)) {\n    plane = planes[4] = new Core_Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Core_Cartesian3.dot(direction, nearCenter);\n\n  // Far plane\n  Core_Cartesian3.multiplyByScalar(direction, f, point);\n  Core_Cartesian3.add(position, point, point);\n\n  plane = planes[5];\n  if (!Core_defined(plane)) {\n    plane = planes[5] = new Core_Cartesian4();\n  }\n  plane.x = -direction.x;\n  plane.y = -direction.y;\n  plane.z = -direction.z;\n  plane.w = -Core_Cartesian3.dot(Core_Cartesian3.negate(direction, negateScratch), point);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  OrthographicOffCenterFrustum_update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(drawingBufferWidth) || !Core_defined(drawingBufferHeight)) {\n    throw new Core_DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new Core_DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new Core_DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!Core_defined(distance)) {\n    throw new Core_DeveloperError(\"distance is required.\");\n  }\n  if (!Core_defined(pixelRatio)) {\n    throw new Core_DeveloperError(\"pixelRatio is required.\");\n  }\n  if (pixelRatio <= 0) {\n    throw new Core_DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const frustumWidth = this.right - this.left;\n  const frustumHeight = this.top - this.bottom;\n  const pixelWidth = (pixelRatio * frustumWidth) / drawingBufferWidth;\n  const pixelHeight = (pixelRatio * frustumHeight) / drawingBufferHeight;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a OrthographicOffCenterFrustum instance.\n *\n * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.\n */\nOrthographicOffCenterFrustum.prototype.clone = function (result) {\n  if (!Core_defined(result)) {\n    result = new OrthographicOffCenterFrustum();\n  }\n\n  result.left = this.left;\n  result.right = this.right;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    Core_defined(other) &&\n    other instanceof OrthographicOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    other === this ||\n    (Core_defined(other) &&\n      other instanceof OrthographicOffCenterFrustum &&\n      Core_Math.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n/* harmony default export */ const Core_OrthographicOffCenterFrustum = (OrthographicOffCenterFrustum);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/OrthographicFrustum.js\n\n\n\n\n\n\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.width] The width of the frustum in meters.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicFrustum(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n\n  this._offCenterFrustum = new Core_OrthographicOffCenterFrustum();\n\n  /**\n   * The horizontal width of the frustum in meters.\n   * @type {Number}\n   * @default undefined\n   */\n  this.width = options.width;\n  this._width = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = Core_defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0;\n   */\n  this.far = Core_defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrthographicFrustum.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrthographicFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrthographicFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.width;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrthographicFrustum} [result] The object into which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.width = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n\n  return result;\n};\n\nfunction OrthographicFrustum_update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !Core_defined(frustum.width) ||\n    !Core_defined(frustum.aspectRatio) ||\n    !Core_defined(frustum.near) ||\n    !Core_defined(frustum.far)\n  ) {\n    throw new Core_DeveloperError(\n      \"width, aspectRatio, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const f = frustum._offCenterFrustum;\n\n  if (\n    frustum.width !== frustum._width ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.aspectRatio < 0) {\n      throw new Core_DeveloperError(\"aspectRatio must be positive.\");\n    }\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new Core_DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._width = frustum.width;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n\n    const ratio = 1.0 / frustum.aspectRatio;\n    f.right = frustum.width * 0.5;\n    f.left = -f.right;\n    f.top = ratio * f.right;\n    f.bottom = -f.top;\n    f.near = frustum.near;\n    f.far = frustum.far;\n  }\n}\n\nObject.defineProperties(OrthographicFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      OrthographicFrustum_update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  OrthographicFrustum_update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  OrthographicFrustum_update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result\n  );\n};\n\n/**\n * Returns a duplicate of a OrthographicFrustum instance.\n *\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.prototype.clone = function (result) {\n  if (!Core_defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.width = this.width;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._width = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equals = function (other) {\n  if (!Core_defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  OrthographicFrustum_update(this);\n  OrthographicFrustum_update(other);\n\n  return (\n    this.width === other.width &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  if (!Core_defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  OrthographicFrustum_update(this);\n  OrthographicFrustum_update(other);\n\n  return (\n    Core_Math.equalsEpsilon(\n      this.width,\n      other.width,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    Core_Math.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon\n    )\n  );\n};\n/* harmony default export */ const Core_OrthographicFrustum = (OrthographicFrustum);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/PerspectiveOffCenterFrustum.js\n\n\n\n\n\n\n\n\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\nfunction PerspectiveOffCenterFrustum(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = Core_defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = Core_defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  this._cullingVolume = new Core_CullingVolume();\n  this._perspectiveMatrix = new Core_Matrix4();\n  this._infinitePerspective = new Core_Matrix4();\n}\n\nfunction PerspectiveOffCenterFrustum_update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !Core_defined(frustum.right) ||\n    !Core_defined(frustum.left) ||\n    !Core_defined(frustum.top) ||\n    !Core_defined(frustum.bottom) ||\n    !Core_defined(frustum.near) ||\n    !Core_defined(frustum.far)\n  ) {\n    throw new Core_DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const t = frustum.top;\n  const b = frustum.bottom;\n  const r = frustum.right;\n  const l = frustum.left;\n  const n = frustum.near;\n  const f = frustum.far;\n\n  if (\n    t !== frustum._top ||\n    b !== frustum._bottom ||\n    l !== frustum._left ||\n    r !== frustum._right ||\n    n !== frustum._near ||\n    f !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new Core_DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = l;\n    frustum._right = r;\n    frustum._top = t;\n    frustum._bottom = b;\n    frustum._near = n;\n    frustum._far = f;\n    frustum._perspectiveMatrix = Core_Matrix4.computePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      f,\n      frustum._perspectiveMatrix\n    );\n    frustum._infinitePerspective = Core_Matrix4.computeInfinitePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      frustum._infinitePerspective\n    );\n  }\n}\n\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      PerspectiveOffCenterFrustum_update(this);\n      return this._perspectiveMatrix;\n    },\n  },\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      PerspectiveOffCenterFrustum_update(this);\n      return this._infinitePerspective;\n    },\n  },\n});\n\nconst PerspectiveOffCenterFrustum_getPlanesRight = new Core_Cartesian3();\nconst PerspectiveOffCenterFrustum_getPlanesNearCenter = new Core_Cartesian3();\nconst getPlanesFarCenter = new Core_Cartesian3();\nconst getPlanesNormal = new Core_Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(position)) {\n    throw new Core_DeveloperError(\"position is required.\");\n  }\n\n  if (!Core_defined(direction)) {\n    throw new Core_DeveloperError(\"direction is required.\");\n  }\n\n  if (!Core_defined(up)) {\n    throw new Core_DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n\n  const right = Core_Cartesian3.cross(direction, up, PerspectiveOffCenterFrustum_getPlanesRight);\n\n  const nearCenter = PerspectiveOffCenterFrustum_getPlanesNearCenter;\n  Core_Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Core_Cartesian3.add(position, nearCenter, nearCenter);\n\n  const farCenter = getPlanesFarCenter;\n  Core_Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Core_Cartesian3.add(position, farCenter, farCenter);\n\n  const normal = getPlanesNormal;\n\n  //Left plane computation\n  Core_Cartesian3.multiplyByScalar(right, l, normal);\n  Core_Cartesian3.add(nearCenter, normal, normal);\n  Core_Cartesian3.subtract(normal, position, normal);\n  Core_Cartesian3.normalize(normal, normal);\n  Core_Cartesian3.cross(normal, up, normal);\n  Core_Cartesian3.normalize(normal, normal);\n\n  let plane = planes[0];\n  if (!Core_defined(plane)) {\n    plane = planes[0] = new Core_Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Core_Cartesian3.dot(normal, position);\n\n  //Right plane computation\n  Core_Cartesian3.multiplyByScalar(right, r, normal);\n  Core_Cartesian3.add(nearCenter, normal, normal);\n  Core_Cartesian3.subtract(normal, position, normal);\n  Core_Cartesian3.cross(up, normal, normal);\n  Core_Cartesian3.normalize(normal, normal);\n\n  plane = planes[1];\n  if (!Core_defined(plane)) {\n    plane = planes[1] = new Core_Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Core_Cartesian3.dot(normal, position);\n\n  //Bottom plane computation\n  Core_Cartesian3.multiplyByScalar(up, b, normal);\n  Core_Cartesian3.add(nearCenter, normal, normal);\n  Core_Cartesian3.subtract(normal, position, normal);\n  Core_Cartesian3.cross(right, normal, normal);\n  Core_Cartesian3.normalize(normal, normal);\n\n  plane = planes[2];\n  if (!Core_defined(plane)) {\n    plane = planes[2] = new Core_Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Core_Cartesian3.dot(normal, position);\n\n  //Top plane computation\n  Core_Cartesian3.multiplyByScalar(up, t, normal);\n  Core_Cartesian3.add(nearCenter, normal, normal);\n  Core_Cartesian3.subtract(normal, position, normal);\n  Core_Cartesian3.cross(normal, right, normal);\n  Core_Cartesian3.normalize(normal, normal);\n\n  plane = planes[3];\n  if (!Core_defined(plane)) {\n    plane = planes[3] = new Core_Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Core_Cartesian3.dot(normal, position);\n\n  //Near plane computation\n  plane = planes[4];\n  if (!Core_defined(plane)) {\n    plane = planes[4] = new Core_Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Core_Cartesian3.dot(direction, nearCenter);\n\n  //Far plane computation\n  Core_Cartesian3.negate(direction, normal);\n\n  plane = planes[5];\n  if (!Core_defined(plane)) {\n    plane = planes[5] = new Core_Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Core_Cartesian3.dot(normal, farCenter);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  PerspectiveOffCenterFrustum_update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(drawingBufferWidth) || !Core_defined(drawingBufferHeight)) {\n    throw new Core_DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new Core_DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new Core_DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!Core_defined(distance)) {\n    throw new Core_DeveloperError(\"distance is required.\");\n  }\n  if (!Core_defined(pixelRatio)) {\n    throw new Core_DeveloperError(\"pixelRatio is required\");\n  }\n  if (pixelRatio <= 0) {\n    throw new Core_DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!Core_defined(result)) {\n    throw new Core_DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseNear = 1.0 / this.near;\n  let tanTheta = this.top * inverseNear;\n  const pixelHeight =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  const pixelWidth =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!Core_defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    Core_defined(other) &&\n    other instanceof PerspectiveOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    other === this ||\n    (Core_defined(other) &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      Core_Math.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      Core_Math.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n/* harmony default export */ const Core_PerspectiveOffCenterFrustum = (PerspectiveOffCenterFrustum);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/PerspectiveFrustum.js\n\n\n\n\n\n\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n * @param {Number} [options.xOffset=0.0] The offset in the x direction.\n * @param {Number} [options.yOffset=0.0] The offset in the y direction.\n *\n * @example\n * const frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\nfunction PerspectiveFrustum(options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n\n  this._offCenterFrustum = new Core_PerspectiveOffCenterFrustum();\n\n  /**\n   * The angle of the field of view (FOV), in radians.  This angle will be used\n   * as the horizontal FOV if the width is greater than the height, otherwise\n   * it will be the vertical FOV.\n   * @type {Number}\n   * @default undefined\n   */\n  this.fov = options.fov;\n  this._fov = undefined;\n  this._fovy = undefined;\n\n  this._sseDenominator = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = Core_defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = Core_defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  /**\n   * Offsets the frustum in the x direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.xOffset = Core_defaultValue(options.xOffset, 0.0);\n  this._xOffset = this.xOffset;\n\n  /**\n   * Offsets the frustum in the y direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.yOffset = Core_defaultValue(options.yOffset, 0.0);\n  this._yOffset = this.yOffset;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nPerspectiveFrustum.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PerspectiveFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.typeOf.object(\"value\", value);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.fov;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.far;\n  array[startingIndex++] = value.xOffset;\n  array[startingIndex] = value.yOffset;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Core_Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = Core_defaultValue(startingIndex, 0);\n\n  if (!Core_defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.fov = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.xOffset = array[startingIndex++];\n  result.yOffset = array[startingIndex];\n\n  return result;\n};\n\nfunction PerspectiveFrustum_update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !Core_defined(frustum.fov) ||\n    !Core_defined(frustum.aspectRatio) ||\n    !Core_defined(frustum.near) ||\n    !Core_defined(frustum.far)\n  ) {\n    throw new Core_DeveloperError(\n      \"fov, aspectRatio, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const f = frustum._offCenterFrustum;\n\n  if (\n    frustum.fov !== frustum._fov ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far ||\n    frustum.xOffset !== frustum._xOffset ||\n    frustum.yOffset !== frustum._yOffset\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.fov < 0 || frustum.fov >= Math.PI) {\n      throw new Core_DeveloperError(\"fov must be in the range [0, PI).\");\n    }\n\n    if (frustum.aspectRatio < 0) {\n      throw new Core_DeveloperError(\"aspectRatio must be positive.\");\n    }\n\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new Core_DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._fov = frustum.fov;\n    frustum._fovy =\n      frustum.aspectRatio <= 1\n        ? frustum.fov\n        : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\n    frustum._xOffset = frustum.xOffset;\n    frustum._yOffset = frustum.yOffset;\n\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\n    f.bottom = -f.top;\n    f.right = frustum.aspectRatio * f.top;\n    f.left = -f.right;\n    f.near = frustum.near;\n    f.far = frustum.far;\n\n    f.right += frustum.xOffset;\n    f.left += frustum.xOffset;\n    f.top += frustum.yOffset;\n    f.bottom += frustum.yOffset;\n  }\n}\n\nObject.defineProperties(PerspectiveFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      PerspectiveFrustum_update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n\n  /**\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      PerspectiveFrustum_update(this);\n      return this._offCenterFrustum.infiniteProjectionMatrix;\n    },\n  },\n\n  /**\n   * Gets the angle of the vertical field of view, in radians.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Number}\n   * @readonly\n   * @default undefined\n   */\n  fovy: {\n    get: function () {\n      PerspectiveFrustum_update(this);\n      return this._fovy;\n    },\n  },\n\n  /**\n   * @readonly\n   * @private\n   */\n  sseDenominator: {\n    get: function () {\n      PerspectiveFrustum_update(this);\n      return this._sseDenominator;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  PerspectiveFrustum_update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  PerspectiveFrustum_update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result\n  );\n};\n\n/**\n * Returns a duplicate of a PerspectiveFrustum instance.\n *\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.prototype.clone = function (result) {\n  if (!Core_defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.fov = this.fov;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._fov = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equals = function (other) {\n  if (!Core_defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  PerspectiveFrustum_update(this);\n  PerspectiveFrustum_update(other);\n\n  return (\n    this.fov === other.fov &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  if (!Core_defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  PerspectiveFrustum_update(this);\n  PerspectiveFrustum_update(other);\n\n  return (\n    Core_Math.equalsEpsilon(\n      this.fov,\n      other.fov,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    Core_Math.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon\n    )\n  );\n};\n/* harmony default export */ const Core_PerspectiveFrustum = (PerspectiveFrustum);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Scene/CameraFlightPath.js\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates tweens for camera flights.\n * <br /><br />\n * Mouse interaction is disabled during flights.\n *\n * @private\n */\nconst CameraFlightPath = {};\n\nfunction getAltitude(frustum, dx, dy) {\n  let near;\n  let top;\n  let right;\n  if (frustum instanceof Core_PerspectiveFrustum) {\n    const tanTheta = Math.tan(0.5 * frustum.fovy);\n    near = frustum.near;\n    top = frustum.near * tanTheta;\n    right = frustum.aspectRatio * top;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  } else if (frustum instanceof Core_PerspectiveOffCenterFrustum) {\n    near = frustum.near;\n    top = frustum.top;\n    right = frustum.right;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  }\n\n  return Math.max(dx, dy);\n}\n\nconst scratchCart = new Core_Cartesian3();\nconst CameraFlightPath_scratchCart2 = new Core_Cartesian3();\n\nfunction createPitchFunction(\n  startPitch,\n  endPitch,\n  heightFunction,\n  pitchAdjustHeight\n) {\n  if (Core_defined(pitchAdjustHeight) && heightFunction(0.5) > pitchAdjustHeight) {\n    const startHeight = heightFunction(0.0);\n    const endHeight = heightFunction(1.0);\n    const middleHeight = heightFunction(0.5);\n\n    const d1 = middleHeight - startHeight;\n    const d2 = middleHeight - endHeight;\n\n    return function (time) {\n      const altitude = heightFunction(time);\n      if (time <= 0.5) {\n        const t1 = (altitude - startHeight) / d1;\n        return Core_Math.lerp(startPitch, -Core_Math.PI_OVER_TWO, t1);\n      }\n\n      const t2 = (altitude - endHeight) / d2;\n      return Core_Math.lerp(-Core_Math.PI_OVER_TWO, endPitch, 1 - t2);\n    };\n  }\n  return function (time) {\n    return Core_Math.lerp(startPitch, endPitch, time);\n  };\n}\n\nfunction createHeightFunction(\n  camera,\n  destination,\n  startHeight,\n  endHeight,\n  optionAltitude\n) {\n  let altitude = optionAltitude;\n  const maxHeight = Math.max(startHeight, endHeight);\n\n  if (!Core_defined(altitude)) {\n    const start = camera.position;\n    const end = destination;\n    const up = camera.up;\n    const right = camera.right;\n    const frustum = camera.frustum;\n\n    const diff = Core_Cartesian3.subtract(start, end, scratchCart);\n    const verticalDistance = Core_Cartesian3.magnitude(\n      Core_Cartesian3.multiplyByScalar(up, Core_Cartesian3.dot(diff, up), CameraFlightPath_scratchCart2)\n    );\n    const horizontalDistance = Core_Cartesian3.magnitude(\n      Core_Cartesian3.multiplyByScalar(\n        right,\n        Core_Cartesian3.dot(diff, right),\n        CameraFlightPath_scratchCart2\n      )\n    );\n\n    altitude = Math.min(\n      getAltitude(frustum, verticalDistance, horizontalDistance) * 0.2,\n      1000000000.0\n    );\n  }\n\n  if (maxHeight < altitude) {\n    const power = 8.0;\n    const factor = 1000000.0;\n\n    const s = -Math.pow((altitude - startHeight) * factor, 1.0 / power);\n    const e = Math.pow((altitude - endHeight) * factor, 1.0 / power);\n\n    return function (t) {\n      const x = t * (e - s) + s;\n      return -Math.pow(x, power) / factor + altitude;\n    };\n  }\n\n  return function (t) {\n    return Core_Math.lerp(startHeight, endHeight, t);\n  };\n}\n\nfunction adjustAngleForLERP(startAngle, endAngle) {\n  if (\n    Core_Math.equalsEpsilon(\n      startAngle,\n      Core_Math.TWO_PI,\n      Core_Math.EPSILON11\n    )\n  ) {\n    startAngle = 0.0;\n  }\n\n  if (endAngle > startAngle + Math.PI) {\n    startAngle += Core_Math.TWO_PI;\n  } else if (endAngle < startAngle - Math.PI) {\n    startAngle -= Core_Math.TWO_PI;\n  }\n\n  return startAngle;\n}\n\nconst scratchStart = new Core_Cartesian3();\n\nfunction createUpdateCV(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n  optionPitchAdjustHeight\n) {\n  const camera = scene.camera;\n\n  const start = Core_Cartesian3.clone(camera.position, scratchStart);\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    start.z,\n    destination.z,\n    optionAltitude\n  );\n\n  const pitchFunction = createPitchFunction(\n    startPitch,\n    pitch,\n    heightFunction,\n    optionPitchAdjustHeight\n  );\n\n  function update(value) {\n    const time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: Core_Math.lerp(startHeading, heading, time),\n        pitch: pitchFunction(time),\n        roll: Core_Math.lerp(startRoll, roll, time),\n      },\n    });\n\n    Core_Cartesian2.lerp(start, destination, time, camera.position);\n    camera.position.z = heightFunction(time);\n  }\n  return update;\n}\n\nfunction useLongestFlight(startCart, destCart) {\n  if (startCart.longitude < destCart.longitude) {\n    startCart.longitude += Core_Math.TWO_PI;\n  } else {\n    destCart.longitude += Core_Math.TWO_PI;\n  }\n}\n\nfunction useShortestFlight(startCart, destCart) {\n  const diff = startCart.longitude - destCart.longitude;\n  if (diff < -Core_Math.PI) {\n    startCart.longitude += Core_Math.TWO_PI;\n  } else if (diff > Core_Math.PI) {\n    destCart.longitude += Core_Math.TWO_PI;\n  }\n}\n\nconst scratchStartCart = new Core_Cartographic();\nconst scratchEndCart = new Core_Cartographic();\n\nfunction createUpdate3D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n  optionFlyOverLongitude,\n  optionFlyOverLongitudeWeight,\n  optionPitchAdjustHeight\n) {\n  const camera = scene.camera;\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const startCart = Core_Cartographic.clone(\n    camera.positionCartographic,\n    scratchStartCart\n  );\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  const destCart = ellipsoid.cartesianToCartographic(\n    destination,\n    scratchEndCart\n  );\n  startCart.longitude = Core_Math.zeroToTwoPi(startCart.longitude);\n  destCart.longitude = Core_Math.zeroToTwoPi(destCart.longitude);\n\n  let useLongFlight = false;\n\n  if (Core_defined(optionFlyOverLongitude)) {\n    const hitLon = Core_Math.zeroToTwoPi(optionFlyOverLongitude);\n\n    const lonMin = Math.min(startCart.longitude, destCart.longitude);\n    const lonMax = Math.max(startCart.longitude, destCart.longitude);\n\n    const hitInside = hitLon >= lonMin && hitLon <= lonMax;\n\n    if (Core_defined(optionFlyOverLongitudeWeight)) {\n      // Distance inside  (0...2Pi)\n      const din = Math.abs(startCart.longitude - destCart.longitude);\n      // Distance outside (0...2Pi)\n      const dot = Core_Math.TWO_PI - din;\n\n      const hitDistance = hitInside ? din : dot;\n      const offDistance = hitInside ? dot : din;\n\n      if (\n        hitDistance < offDistance * optionFlyOverLongitudeWeight &&\n        !hitInside\n      ) {\n        useLongFlight = true;\n      }\n    } else if (!hitInside) {\n      useLongFlight = true;\n    }\n  }\n\n  if (useLongFlight) {\n    useLongestFlight(startCart, destCart);\n  } else {\n    useShortestFlight(startCart, destCart);\n  }\n\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startCart.height,\n    destCart.height,\n    optionAltitude\n  );\n  const pitchFunction = createPitchFunction(\n    startPitch,\n    pitch,\n    heightFunction,\n    optionPitchAdjustHeight\n  );\n\n  // Isolate scope for update function.\n  // to have local copies of vars used in lerp\n  // Othervise, if you call nex\n  // createUpdate3D (createAnimationTween)\n  // before you played animation, variables will be overwriten.\n  function isolateUpdateFunction() {\n    const startLongitude = startCart.longitude;\n    const destLongitude = destCart.longitude;\n    const startLatitude = startCart.latitude;\n    const destLatitude = destCart.latitude;\n\n    return function update(value) {\n      const time = value.time / duration;\n\n      const position = Core_Cartesian3.fromRadians(\n        Core_Math.lerp(startLongitude, destLongitude, time),\n        Core_Math.lerp(startLatitude, destLatitude, time),\n        heightFunction(time),\n        ellipsoid\n      );\n\n      camera.setView({\n        destination: position,\n        orientation: {\n          heading: Core_Math.lerp(startHeading, heading, time),\n          pitch: pitchFunction(time),\n          roll: Core_Math.lerp(startRoll, roll, time),\n        },\n      });\n    };\n  }\n  return isolateUpdateFunction();\n}\n\nfunction createUpdate2D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude\n) {\n  const camera = scene.camera;\n\n  const start = Core_Cartesian3.clone(camera.position, scratchStart);\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n\n  const startHeight = camera.frustum.right - camera.frustum.left;\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startHeight,\n    destination.z,\n    optionAltitude\n  );\n\n  function update(value) {\n    const time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: Core_Math.lerp(startHeading, heading, time),\n      },\n    });\n\n    Core_Cartesian2.lerp(start, destination, time, camera.position);\n\n    const zoom = heightFunction(time);\n\n    const frustum = camera.frustum;\n    const ratio = frustum.top / frustum.right;\n\n    const incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;\n    frustum.right += incrementAmount;\n    frustum.left -= incrementAmount;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n  return update;\n}\n\nconst CameraFlightPath_scratchCartographic = new Core_Cartographic();\nconst scratchDestination = new Core_Cartesian3();\n\nfunction emptyFlight(complete, cancel) {\n  return {\n    startObject: {},\n    stopObject: {},\n    duration: 0.0,\n    complete: complete,\n    cancel: cancel,\n  };\n}\n\nfunction wrapCallback(controller, cb) {\n  function wrapped() {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n\n    controller.enableInputs = true;\n  }\n  return wrapped;\n}\n\nCameraFlightPath.createTween = function (scene, options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(scene)) {\n    throw new Core_DeveloperError(\"scene is required.\");\n  }\n  if (!Core_defined(destination)) {\n    throw new Core_DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n  const mode = scene.mode;\n\n  if (mode === Scene_SceneMode.MORPHING) {\n    return emptyFlight();\n  }\n\n  const convert = Core_defaultValue(options.convert, true);\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const maximumHeight = options.maximumHeight;\n  const flyOverLongitude = options.flyOverLongitude;\n  const flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  const pitchAdjustHeight = options.pitchAdjustHeight;\n  let easingFunction = options.easingFunction;\n\n  if (convert && mode !== Scene_SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(destination, CameraFlightPath_scratchCartographic);\n    destination = projection.project(CameraFlightPath_scratchCartographic, scratchDestination);\n  }\n\n  const camera = scene.camera;\n  const transform = options.endTransform;\n  if (Core_defined(transform)) {\n    camera._setTransform(transform);\n  }\n\n  let duration = options.duration;\n  if (!Core_defined(duration)) {\n    duration =\n      Math.ceil(Core_Cartesian3.distance(camera.position, destination) / 1000000.0) +\n      2.0;\n    duration = Math.min(duration, 3.0);\n  }\n\n  const heading = Core_defaultValue(options.heading, 0.0);\n  const pitch = Core_defaultValue(options.pitch, -Core_Math.PI_OVER_TWO);\n  const roll = Core_defaultValue(options.roll, 0.0);\n\n  const controller = scene.screenSpaceCameraController;\n  controller.enableInputs = false;\n\n  const complete = wrapCallback(controller, options.complete);\n  const cancel = wrapCallback(controller, options.cancel);\n\n  const frustum = camera.frustum;\n\n  let empty = scene.mode === Scene_SceneMode.SCENE2D;\n  empty =\n    empty &&\n    Core_Cartesian2.equalsEpsilon(camera.position, destination, Core_Math.EPSILON6);\n  empty =\n    empty &&\n    Core_Math.equalsEpsilon(\n      Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom),\n      destination.z,\n      Core_Math.EPSILON6\n    );\n\n  empty =\n    empty ||\n    (scene.mode !== Scene_SceneMode.SCENE2D &&\n      Core_Cartesian3.equalsEpsilon(\n        destination,\n        camera.position,\n        Core_Math.EPSILON10\n      ));\n\n  empty =\n    empty &&\n    Core_Math.equalsEpsilon(\n      Core_Math.negativePiToPi(heading),\n      Core_Math.negativePiToPi(camera.heading),\n      Core_Math.EPSILON10\n    ) &&\n    Core_Math.equalsEpsilon(\n      Core_Math.negativePiToPi(pitch),\n      Core_Math.negativePiToPi(camera.pitch),\n      Core_Math.EPSILON10\n    ) &&\n    Core_Math.equalsEpsilon(\n      Core_Math.negativePiToPi(roll),\n      Core_Math.negativePiToPi(camera.roll),\n      Core_Math.EPSILON10\n    );\n\n  if (empty) {\n    return emptyFlight(complete, cancel);\n  }\n\n  const updateFunctions = new Array(4);\n  updateFunctions[Scene_SceneMode.SCENE2D] = createUpdate2D;\n  updateFunctions[Scene_SceneMode.SCENE3D] = createUpdate3D;\n  updateFunctions[Scene_SceneMode.COLUMBUS_VIEW] = createUpdateCV;\n\n  if (duration <= 0.0) {\n    const newOnComplete = function () {\n      const update = updateFunctions[mode](\n        scene,\n        1.0,\n        destination,\n        heading,\n        pitch,\n        roll,\n        maximumHeight,\n        flyOverLongitude,\n        flyOverLongitudeWeight,\n        pitchAdjustHeight\n      );\n      update({ time: 1.0 });\n\n      if (typeof complete === \"function\") {\n        complete();\n      }\n    };\n    return emptyFlight(newOnComplete, cancel);\n  }\n\n  const update = updateFunctions[mode](\n    scene,\n    duration,\n    destination,\n    heading,\n    pitch,\n    roll,\n    maximumHeight,\n    flyOverLongitude,\n    flyOverLongitudeWeight,\n    pitchAdjustHeight\n  );\n\n  if (!Core_defined(easingFunction)) {\n    const startHeight = camera.positionCartographic.height;\n    const endHeight =\n      mode === Scene_SceneMode.SCENE3D\n        ? ellipsoid.cartesianToCartographic(destination).height\n        : destination.z;\n\n    if (startHeight > endHeight && startHeight > 11500.0) {\n      easingFunction = Core_EasingFunction.CUBIC_OUT;\n    } else {\n      easingFunction = Core_EasingFunction.QUINTIC_IN_OUT;\n    }\n  }\n\n  return {\n    duration: duration,\n    easingFunction: easingFunction,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: duration,\n    },\n    update: update,\n    complete: complete,\n    cancel: cancel,\n  };\n};\n/* harmony default export */ const Scene_CameraFlightPath = (CameraFlightPath);\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Scene/MapMode2D.js\n/**\n * Describes how the map will operate in 2D.\n *\n * @enum {Number}\n */\nconst MapMode2D = {\n  /**\n   * The 2D map can be rotated about the z axis.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ROTATE: 0,\n\n  /**\n   * The 2D map can be scrolled infinitely in the horizontal direction.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INFINITE_SCROLL: 1,\n};\n/* harmony default export */ const Scene_MapMode2D = (Object.freeze(MapMode2D));\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Scene/Camera.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} DirectionUp\n *\n * An orientation given by a pair of unit vectors\n *\n * @property {Cartesian3} direction The unit \"direction\" vector\n * @property {Cartesian3} up The unit \"up\" vector\n **/\n/**\n * @typedef {Object} HeadingPitchRollValues\n *\n * An orientation given by numeric heading, pitch, and roll\n *\n * @property {number} [heading=0.0] The heading in radians\n * @property {number} [pitch=-CesiumMath.PI_OVER_TWO] The pitch in radians\n * @property {number} [roll=0.0] The roll in meters\n **/\n\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}\n * @demo {@link https://cesium.com/learn/cesiumjs-learn/cesiumjs-camera|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * const camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(scene)) {\n    throw new Core_DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n  this._scene = scene;\n\n  this._transform = Core_Matrix4.clone(Core_Matrix4.IDENTITY);\n  this._invTransform = Core_Matrix4.clone(Core_Matrix4.IDENTITY);\n  this._actualTransform = Core_Matrix4.clone(Core_Matrix4.IDENTITY);\n  this._actualInvTransform = Core_Matrix4.clone(Core_Matrix4.IDENTITY);\n  this._transformChanged = false;\n\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.position = new Core_Cartesian3();\n  this._position = new Core_Cartesian3();\n  this._positionWC = new Core_Cartesian3();\n  this._positionCartographic = new Core_Cartographic();\n  this._oldPositionWC = undefined;\n\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitude = 0.0;\n\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.direction = new Core_Cartesian3();\n  this._direction = new Core_Cartesian3();\n  this._directionWC = new Core_Cartesian3();\n\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.up = new Core_Cartesian3();\n  this._up = new Core_Cartesian3();\n  this._upWC = new Core_Cartesian3();\n\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.right = new Core_Cartesian3();\n  this._right = new Core_Cartesian3();\n  this._rightWC = new Core_Cartesian3();\n\n  /**\n   * The region of space in view.\n   *\n   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n  this.frustum = new Core_PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = Core_Math.toRadians(60.0);\n\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {Number}\n   * @default Math.PI / 60.0\n   */\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {Number}\n   * @default Math.PI / 3600.0\n   */\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {Number}\n   * @default 1.5\n   */\n  this.maximumZoomFactor = 1.5;\n\n  this._moveStart = new Core_Event();\n  this._moveEnd = new Core_Event();\n\n  this._changed = new Core_Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n  this._changedHeading = undefined;\n\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n  this.percentageChanged = 0.5;\n\n  this._viewMatrix = new Core_Matrix4();\n  this._invViewMatrix = new Core_Matrix4();\n  updateViewMatrix(this);\n\n  this._mode = Scene_SceneMode.SCENE3D;\n  this._modeChanged = true;\n  const projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(\n    new Core_Cartographic(Math.PI, Core_Math.PI_OVER_TWO)\n  );\n  this._max2Dfrustum = undefined;\n\n  // set default view\n  rectangleCameraPosition3D(\n    this,\n    Camera.DEFAULT_VIEW_RECTANGLE,\n    this.position,\n    true\n  );\n\n  let mag = Core_Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Core_Cartesian3.normalize(this.position, this.position);\n  Core_Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D = new Core_Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D_INVERSE = Core_Matrix4.inverseTransformation(\n  Camera.TRANSFORM_2D,\n  new Core_Matrix4()\n);\n\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\nCamera.DEFAULT_VIEW_RECTANGLE = Core_Rectangle.fromDegrees(\n  -95.0,\n  -20.0,\n  -70.0,\n  90.0\n);\n\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type Number\n */\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\nCamera.DEFAULT_OFFSET = new Core_HeadingPitchRange(\n  0.0,\n  -Core_Math.PI_OVER_FOUR,\n  0.0\n);\n\nfunction updateViewMatrix(camera) {\n  Core_Matrix4.computeView(\n    camera._position,\n    camera._direction,\n    camera._up,\n    camera._right,\n    camera._viewMatrix\n  );\n  Core_Matrix4.multiply(\n    camera._viewMatrix,\n    camera._actualInvTransform,\n    camera._viewMatrix\n  );\n  Core_Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!Core_defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Core_Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    const delta = Core_Cartesian3.subtract(\n      camera.positionWC,\n      camera._oldPositionWC,\n      camera._oldPositionWC\n    );\n    camera.positionWCDeltaMagnitude = Core_Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Core_Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n\n    // Update move timers\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = Core_getTimestamp();\n    } else {\n      camera.timeSinceMoved =\n        Math.max(Core_getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {Boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\nCamera.prototype.canPreloadFlight = function () {\n  return Core_defined(this._currentFlight) && this._mode !== Scene_SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  const camera = this;\n\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  const percentageChanged = camera.percentageChanged;\n\n  const currentHeading = camera.heading;\n\n  if (!Core_defined(camera._changedHeading)) {\n    camera._changedHeading = currentHeading;\n  }\n\n  let delta =\n    Math.abs(camera._changedHeading - currentHeading) % Core_Math.TWO_PI;\n  delta = delta > Core_Math.PI ? Core_Math.TWO_PI - delta : delta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const headingChangedPercentage = delta / Math.PI;\n\n  if (headingChangedPercentage > percentageChanged) {\n    camera._changed.raiseEvent(headingChangedPercentage);\n    camera._changedHeading = currentHeading;\n  }\n\n  if (camera._mode === Scene_SceneMode.SCENE2D) {\n    if (!Core_defined(camera._changedFrustum)) {\n      camera._changedPosition = Core_Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    const position = camera.position;\n    const lastPosition = camera._changedPosition;\n\n    const frustum = camera.frustum;\n    const lastFrustum = camera._changedFrustum;\n\n    const x0 = position.x + frustum.left;\n    const x1 = position.x + frustum.right;\n    const x2 = lastPosition.x + lastFrustum.left;\n    const x3 = lastPosition.x + lastFrustum.right;\n\n    const y0 = position.y + frustum.bottom;\n    const y1 = position.y + frustum.top;\n    const y2 = lastPosition.y + lastFrustum.bottom;\n    const y3 = lastPosition.y + lastFrustum.top;\n\n    const leftX = Math.max(x0, x2);\n    const rightX = Math.min(x1, x3);\n    const bottomY = Math.max(y0, y2);\n    const topY = Math.min(y1, y3);\n\n    let areaPercentage;\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      let areaRef = lastFrustum;\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n      areaPercentage =\n        1.0 -\n        ((rightX - leftX) * (topY - bottomY)) /\n          ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n      camera._changedPosition = Core_Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n    return;\n  }\n\n  if (!Core_defined(camera._changedDirection)) {\n    camera._changedPosition = Core_Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Core_Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n    return;\n  }\n\n  const dirAngle = Core_Math.acosClamped(\n    Core_Cartesian3.dot(camera.directionWC, camera._changedDirection)\n  );\n\n  let dirPercentage;\n  if (Core_defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  const distance = Core_Cartesian3.distance(\n    camera.positionWC,\n    camera._changedPosition\n  );\n  const heightPercentage = distance / camera.positionCartographic.height;\n\n  if (\n    dirPercentage > percentageChanged ||\n    heightPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n    camera._changedPosition = Core_Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Core_Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Core_Transforms.basisTo2D(\n    camera._projection,\n    camera._transform,\n    camera._actualTransform\n  );\n}\n\nconst Camera_scratchCartographic = new Core_Cartographic();\nconst Camera_scratchCartesian3Projection = new Core_Cartesian3();\nconst Camera_scratchCartesian3 = new Core_Cartesian3();\nconst scratchCartesian4Origin = new Core_Cartesian4();\nconst scratchCartesian4NewOrigin = new Core_Cartesian4();\nconst scratchCartesian4NewXAxis = new Core_Cartesian4();\nconst scratchCartesian4NewYAxis = new Core_Cartesian4();\nconst scratchCartesian4NewZAxis = new Core_Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  const origin = Core_Matrix4.getColumn(\n    camera._transform,\n    3,\n    scratchCartesian4Origin\n  );\n  const cartographic = ellipsoid.cartesianToCartographic(\n    origin,\n    Camera_scratchCartographic\n  );\n\n  const projectedPosition = projection.project(\n    cartographic,\n    Camera_scratchCartesian3Projection\n  );\n  const newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n\n  const newZAxis = Core_Cartesian4.clone(\n    Core_Cartesian4.UNIT_X,\n    scratchCartesian4NewZAxis\n  );\n\n  const xAxis = Core_Cartesian4.add(\n    Core_Matrix4.getColumn(camera._transform, 0, Camera_scratchCartesian3),\n    origin,\n    Camera_scratchCartesian3\n  );\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n\n  projection.project(cartographic, projectedPosition);\n  const newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n\n  Core_Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n\n  const newYAxis = scratchCartesian4NewYAxis;\n  if (Core_Cartesian3.magnitudeSquared(newXAxis) > Core_Math.EPSILON10) {\n    Core_Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    const yAxis = Core_Cartesian4.add(\n      Core_Matrix4.getColumn(camera._transform, 1, Camera_scratchCartesian3),\n      origin,\n      Camera_scratchCartesian3\n    );\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n\n    Core_Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Core_Cartesian3.magnitudeSquared(newYAxis) < Core_Math.EPSILON10) {\n      Core_Cartesian4.clone(Core_Cartesian4.UNIT_Y, newXAxis);\n      Core_Cartesian4.clone(Core_Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Core_Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Core_Cartesian3.normalize(newXAxis, newXAxis);\n  Core_Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Core_Cartesian3.normalize(newYAxis, newYAxis);\n\n  Core_Matrix4.setColumn(\n    camera._actualTransform,\n    0,\n    newXAxis,\n    camera._actualTransform\n  );\n  Core_Matrix4.setColumn(\n    camera._actualTransform,\n    1,\n    newYAxis,\n    camera._actualTransform\n  );\n  Core_Matrix4.setColumn(\n    camera._actualTransform,\n    2,\n    newZAxis,\n    camera._actualTransform\n  );\n  Core_Matrix4.setColumn(\n    camera._actualTransform,\n    3,\n    newOrigin,\n    camera._actualTransform\n  );\n}\n\nconst Camera_scratchCartesian = new Core_Cartesian3();\n\nfunction updateMembers(camera) {\n  const mode = camera._mode;\n\n  let heightChanged = false;\n  let height = 0.0;\n  if (mode === Scene_SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  let position = camera._position;\n  const positionChanged =\n    !Core_Cartesian3.equals(position, camera.position) || heightChanged;\n  if (positionChanged) {\n    position = Core_Cartesian3.clone(camera.position, camera._position);\n  }\n\n  let direction = camera._direction;\n  const directionChanged = !Core_Cartesian3.equals(direction, camera.direction);\n  if (directionChanged) {\n    Core_Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Core_Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  let up = camera._up;\n  const upChanged = !Core_Cartesian3.equals(up, camera.up);\n  if (upChanged) {\n    Core_Cartesian3.normalize(camera.up, camera.up);\n    up = Core_Cartesian3.clone(camera.up, camera._up);\n  }\n\n  let right = camera._right;\n  const rightChanged = !Core_Cartesian3.equals(right, camera.right);\n  if (rightChanged) {\n    Core_Cartesian3.normalize(camera.right, camera.right);\n    right = Core_Cartesian3.clone(camera.right, camera._right);\n  }\n\n  const transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Core_Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (\n      camera._mode === Scene_SceneMode.COLUMBUS_VIEW ||\n      camera._mode === Scene_SceneMode.SCENE2D\n    ) {\n      if (Core_Matrix4.equals(Core_Matrix4.IDENTITY, camera._transform)) {\n        Core_Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === Scene_SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Core_Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Core_Matrix4.inverseTransformation(\n      camera._actualTransform,\n      camera._actualInvTransform\n    );\n\n    camera._modeChanged = false;\n  }\n\n  const transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Core_Matrix4.multiplyByPoint(\n      transform,\n      position,\n      camera._positionWC\n    );\n\n    // Compute the Cartographic position of the camera.\n    if (mode === Scene_SceneMode.SCENE3D || mode === Scene_SceneMode.MORPHING) {\n      camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(\n        camera._positionWC,\n        camera._positionCartographic\n      );\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      const positionENU = Camera_scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x;\n\n      // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n      if (mode === Scene_SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    const det = Core_Cartesian3.dot(\n      direction,\n      Core_Cartesian3.cross(up, right, Camera_scratchCartesian)\n    );\n    if (Math.abs(1.0 - det) > Core_Math.EPSILON2) {\n      //orthonormalize axes\n      const invUpMag = 1.0 / Core_Cartesian3.magnitudeSquared(up);\n      const scalar = Core_Cartesian3.dot(up, direction) * invUpMag;\n      const w0 = Core_Cartesian3.multiplyByScalar(\n        direction,\n        scalar,\n        Camera_scratchCartesian\n      );\n      up = Core_Cartesian3.normalize(\n        Core_Cartesian3.subtract(up, w0, camera._up),\n        camera._up\n      );\n      Core_Cartesian3.clone(up, camera.up);\n\n      right = Core_Cartesian3.cross(direction, up, camera._right);\n      Core_Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Core_Matrix4.multiplyByPointAsVector(\n      transform,\n      direction,\n      camera._directionWC\n    );\n    Core_Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Core_Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Core_Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Core_Matrix4.multiplyByPointAsVector(\n      transform,\n      right,\n      camera._rightWC\n    );\n    Core_Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (\n    positionChanged ||\n    directionChanged ||\n    upChanged ||\n    rightChanged ||\n    transformChanged\n  ) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  let heading;\n  if (\n    !Core_Math.equalsEpsilon(Math.abs(direction.z), 1.0, Core_Math.EPSILON3)\n  ) {\n    heading = Math.atan2(direction.y, direction.x) - Core_Math.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - Core_Math.PI_OVER_TWO;\n  }\n\n  return Core_Math.TWO_PI - Core_Math.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return Core_Math.PI_OVER_TWO - Core_Math.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  let roll = 0.0;\n  if (\n    !Core_Math.equalsEpsilon(Math.abs(direction.z), 1.0, Core_Math.EPSILON3)\n  ) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = Core_Math.zeroToTwoPi(roll + Core_Math.TWO_PI);\n  }\n\n  return roll;\n}\n\nconst scratchHPRMatrix1 = new Core_Matrix4();\nconst scratchHPRMatrix2 = new Core_Matrix4();\n\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    },\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    },\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    },\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    },\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    },\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    },\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    },\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    },\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== Scene_SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Core_Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Core_Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        const heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== Scene_SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Core_Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Core_Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        const pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== Scene_SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Core_Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Core_Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        const roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    },\n  },\n});\n\n/**\n * @private\n */\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(mode)) {\n    throw new Core_DeveloperError(\"mode is required.\");\n  }\n  if (\n    mode === Scene_SceneMode.SCENE2D &&\n    !(this.frustum instanceof Core_OrthographicOffCenterFrustum)\n  ) {\n    throw new Core_DeveloperError(\n      \"An OrthographicOffCenterFrustum is required in 2D.\"\n    );\n  }\n  if (\n    (mode === Scene_SceneMode.SCENE3D || mode === Scene_SceneMode.COLUMBUS_VIEW) &&\n    !(this.frustum instanceof Core_PerspectiveFrustum) &&\n    !(this.frustum instanceof Core_OrthographicFrustum)\n  ) {\n    throw new Core_DeveloperError(\n      \"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let updateFrustum = false;\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== Scene_SceneMode.MORPHING;\n    updateFrustum = this._mode === Scene_SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    const frustum = (this._max2Dfrustum = this.frustum.clone());\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!(frustum instanceof Core_OrthographicOffCenterFrustum)) {\n      throw new Core_DeveloperError(\n        \"The camera frustum is expected to be orthographic for 2D camera control.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    const maxZoomOut = 2.0;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === Scene_SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nconst setTransformPosition = new Core_Cartesian3();\nconst setTransformUp = new Core_Cartesian3();\nconst setTransformDirection = new Core_Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  const position = Core_Cartesian3.clone(this.positionWC, setTransformPosition);\n  const up = Core_Cartesian3.clone(this.upWC, setTransformUp);\n  const direction = Core_Cartesian3.clone(this.directionWC, setTransformDirection);\n\n  Core_Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  const inverse = this._actualInvTransform;\n\n  Core_Matrix4.multiplyByPoint(inverse, position, this.position);\n  Core_Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Core_Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Core_Cartesian3.cross(this.direction, this.up, this.right);\n\n  updateMembers(this);\n};\n\nconst scratchAdjustOrthographicFrustumMousePosition = new Core_Cartesian2();\nconst scratchPickRay = new Core_Ray();\nconst scratchRayIntersection = new Core_Cartesian3();\nconst scratchDepthIntersection = new Core_Cartesian3();\n\nfunction calculateOrthographicFrustumWidth(camera) {\n  // Camera is fixed to an object, so keep frustum width constant.\n  if (!Core_Matrix4.equals(Core_Matrix4.IDENTITY, camera.transform)) {\n    return Core_Cartesian3.magnitude(camera.position);\n  }\n\n  const scene = camera._scene;\n  const globe = scene.globe;\n\n  const mousePosition = scratchAdjustOrthographicFrustumMousePosition;\n  mousePosition.x = scene.drawingBufferWidth / 2.0;\n  mousePosition.y = scene.drawingBufferHeight / 2.0;\n\n  let rayIntersection;\n  if (Core_defined(globe)) {\n    const ray = camera.getPickRay(mousePosition, scratchPickRay);\n    rayIntersection = globe.pickWorldCoordinates(\n      ray,\n      scene,\n      true,\n      scratchRayIntersection\n    );\n  }\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection\n    );\n  }\n\n  let distance;\n  if (Core_defined(rayIntersection) || Core_defined(depthIntersection)) {\n    const depthDistance = Core_defined(depthIntersection)\n      ? Core_Cartesian3.distance(depthIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    const rayDistance = Core_defined(rayIntersection)\n      ? Core_Cartesian3.distance(rayIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    distance = Math.min(depthDistance, rayDistance);\n  } else {\n    distance = Math.max(camera.positionCartographic.height, 0.0);\n  }\n  return distance;\n}\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof Core_OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  this.frustum.width = calculateOrthographicFrustumWidth(this);\n};\n\nconst scratchSetViewCartesian = new Core_Cartesian3();\nconst scratchSetViewTransform1 = new Core_Matrix4();\nconst scratchSetViewTransform2 = new Core_Matrix4();\nconst scratchSetViewQuaternion = new Core_Quaternion();\nconst scratchSetViewMatrix3 = new Core_Matrix3();\nconst scratchSetViewCartographic = new Core_Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  const currentTransform = Core_Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  const localTransform = Core_Transforms.eastNorthUpToFixedFrame(\n    position,\n    camera._projection.ellipsoid,\n    scratchSetViewTransform2\n  );\n  camera._setTransform(localTransform);\n\n  Core_Cartesian3.clone(Core_Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - Core_Math.PI_OVER_TWO;\n\n  const rotQuat = Core_Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion\n  );\n  const rotMat = Core_Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Core_Matrix3.getColumn(rotMat, 0, camera.direction);\n  Core_Matrix3.getColumn(rotMat, 2, camera.up);\n  Core_Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  const currentTransform = Core_Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Core_Matrix4.IDENTITY);\n\n  if (!Core_Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Core_Cartesian3.clone(position, camera.position);\n  }\n  hpr.heading = hpr.heading - Core_Math.PI_OVER_TWO;\n\n  const rotQuat = Core_Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion\n  );\n  const rotMat = Core_Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Core_Matrix3.getColumn(rotMat, 0, camera.direction);\n  Core_Matrix3.getColumn(rotMat, 2, camera.up);\n  Core_Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  const currentTransform = Core_Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Core_Matrix4.IDENTITY);\n\n  if (!Core_Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Core_Cartesian2.clone(position, camera.position);\n\n    const newLeft = -position.z * 0.5;\n    const newRight = -newLeft;\n\n    const frustum = camera.frustum;\n    if (newRight > newLeft) {\n      const ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === Scene_MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - Core_Math.PI_OVER_TWO;\n    hpr.pitch = -Core_Math.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    const rotQuat = Core_Quaternion.fromHeadingPitchRoll(\n      hpr,\n      scratchSetViewQuaternion\n    );\n    const rotMat = Core_Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n    Core_Matrix3.getColumn(rotMat, 2, camera.up);\n    Core_Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nconst scratchToHPRDirection = new Core_Cartesian3();\nconst scratchToHPRUp = new Core_Cartesian3();\nconst scratchToHPRRight = new Core_Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  const direction = Core_Cartesian3.clone(\n    orientation.direction,\n    scratchToHPRDirection\n  );\n  const up = Core_Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === Scene_SceneMode.SCENE3D) {\n    const ellipsoid = camera._projection.ellipsoid;\n    const transform = Core_Transforms.eastNorthUpToFixedFrame(\n      position,\n      ellipsoid,\n      scratchHPRMatrix1\n    );\n    const invTransform = Core_Matrix4.inverseTransformation(\n      transform,\n      scratchHPRMatrix2\n    );\n\n    Core_Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Core_Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  const right = Core_Cartesian3.cross(direction, up, scratchToHPRRight);\n\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n\n  return result;\n}\n\nconst scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined,\n  },\n  convert: undefined,\n  endTransform: undefined,\n};\n\nconst scratchHpr = new Core_HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {HeadingPitchRollValues|DirectionUp} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\nCamera.prototype.setView = function (options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n  let orientation = Core_defaultValue(\n    options.orientation,\n    Core_defaultValue.EMPTY_OBJECT\n  );\n\n  const mode = this._mode;\n  if (mode === Scene_SceneMode.MORPHING) {\n    return;\n  }\n\n  if (Core_defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  let convert = Core_defaultValue(options.convert, true);\n  let destination = Core_defaultValue(\n    options.destination,\n    Core_Cartesian3.clone(this.positionWC, scratchSetViewCartesian)\n  );\n  if (Core_defined(destination) && Core_defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchSetViewCartesian\n    );\n    convert = false;\n  }\n\n  if (Core_defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  scratchHpr.heading = Core_defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = Core_defaultValue(orientation.pitch, -Core_Math.PI_OVER_TWO);\n  scratchHpr.roll = Core_defaultValue(orientation.roll, 0.0);\n\n  if (mode === Scene_SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === Scene_SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nconst pitchScratch = new Core_Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {Number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\nCamera.prototype.flyHome = function (duration) {\n  const mode = this._mode;\n\n  if (mode === Scene_SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === Scene_SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Core_Matrix4.IDENTITY,\n    });\n  } else if (mode === Scene_SceneMode.SCENE3D) {\n    const destination = this.getRectangleCameraCoordinates(\n      Camera.DEFAULT_VIEW_RECTANGLE\n    );\n\n    let mag = Core_Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Core_Cartesian3.normalize(destination, destination);\n    Core_Cartesian3.multiplyByScalar(destination, mag, destination);\n\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Core_Matrix4.IDENTITY,\n    });\n  } else if (mode === Scene_SceneMode.COLUMBUS_VIEW) {\n    const maxRadii = this._projection.ellipsoid.maximumRadius;\n    let position = new Core_Cartesian3(0.0, -1.0, 1.0);\n    position = Core_Cartesian3.multiplyByScalar(\n      Core_Cartesian3.normalize(position, position),\n      5.0 * maxRadii,\n      position\n    );\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Core_Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0,\n      },\n      endTransform: Core_Matrix4.IDENTITY,\n      convert: false,\n    });\n  }\n};\n\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian4();\n  }\n  updateMembers(this);\n  return Core_Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n  updateMembers(this);\n  return Core_Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n  updateMembers(this);\n  return Core_Matrix4.multiplyByPointAsVector(\n    this._actualInvTransform,\n    cartesian,\n    result\n  );\n};\n\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian4();\n  }\n  updateMembers(this);\n  return Core_Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n  updateMembers(this);\n  return Core_Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(cartesian)) {\n    throw new Core_DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n  updateMembers(this);\n  return Core_Matrix4.multiplyByPointAsVector(\n    this._actualTransform,\n    cartesian,\n    result\n  );\n};\n\nfunction clampMove2D(camera, position) {\n  const rotatable2D = camera._scene.mapMode2D === Scene_MapMode2D.ROTATE;\n  const maxProjectedX = camera._maxCoord.x;\n  const maxProjectedY = camera._maxCoord.y;\n\n  let minX;\n  let maxX;\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nconst moveScratch = new Core_Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(direction)) {\n    throw new Core_DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const cameraPosition = this.position;\n  Core_Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Core_Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === Scene_SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n  this._adjustOrthographicFrustum(true);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\nCamera.prototype.moveForward = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === Scene_SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\nCamera.prototype.moveBackward = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === Scene_SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\nCamera.prototype.moveUp = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\nCamera.prototype.moveDown = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\nCamera.prototype.moveRight = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\nCamera.prototype.moveLeft = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\nCamera.prototype.lookLeft = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== Scene_SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\nCamera.prototype.lookRight = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== Scene_SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\nCamera.prototype.lookUp = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== Scene_SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\nCamera.prototype.lookDown = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== Scene_SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nconst lookScratchQuaternion = new Core_Quaternion();\nconst lookScratchMatrix = new Core_Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(axis)) {\n    throw new Core_DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = Core_defaultValue(angle, this.defaultLookAmount);\n  const quaternion = Core_Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    lookScratchQuaternion\n  );\n  const rotation = Core_Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n\n  const direction = this.direction;\n  const up = this.up;\n  const right = this.right;\n\n  Core_Matrix3.multiplyByVector(rotation, direction, direction);\n  Core_Matrix3.multiplyByVector(rotation, up, up);\n  Core_Matrix3.multiplyByVector(rotation, right, right);\n};\n\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\nCamera.prototype.twistLeft = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\nCamera.prototype.twistRight = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\n\nconst rotateScratchQuaternion = new Core_Quaternion();\nconst rotateScratchMatrix = new Core_Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(axis)) {\n    throw new Core_DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = Core_defaultValue(angle, this.defaultRotateAmount);\n  const quaternion = Core_Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    rotateScratchQuaternion\n  );\n  const rotation = Core_Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Core_Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Core_Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Core_Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Core_Cartesian3.cross(this.direction, this.up, this.right);\n  Core_Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\nCamera.prototype.rotateDown = function (angle) {\n  angle = Core_defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\nCamera.prototype.rotateUp = function (angle) {\n  angle = Core_defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\n\nconst rotateVertScratchP = new Core_Cartesian3();\nconst rotateVertScratchA = new Core_Cartesian3();\nconst rotateVertScratchTan = new Core_Cartesian3();\nconst rotateVertScratchNegate = new Core_Cartesian3();\nfunction rotateVertical(camera, angle) {\n  const position = camera.position;\n  if (\n    Core_defined(camera.constrainedAxis) &&\n    !Core_Cartesian3.equalsEpsilon(\n      camera.position,\n      Core_Cartesian3.ZERO,\n      Core_Math.EPSILON2\n    )\n  ) {\n    const p = Core_Cartesian3.normalize(position, rotateVertScratchP);\n    const northParallel = Core_Cartesian3.equalsEpsilon(\n      p,\n      camera.constrainedAxis,\n      Core_Math.EPSILON2\n    );\n    const southParallel = Core_Cartesian3.equalsEpsilon(\n      p,\n      Core_Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate),\n      Core_Math.EPSILON2\n    );\n    if (!northParallel && !southParallel) {\n      const constrainedAxis = Core_Cartesian3.normalize(\n        camera.constrainedAxis,\n        rotateVertScratchA\n      );\n\n      let dot = Core_Cartesian3.dot(p, constrainedAxis);\n      let angleToAxis = Core_Math.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - Core_Math.EPSILON4;\n      }\n\n      dot = Core_Cartesian3.dot(\n        p,\n        Core_Cartesian3.negate(constrainedAxis, rotateVertScratchNegate)\n      );\n      angleToAxis = Core_Math.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + Core_Math.EPSILON4;\n      }\n\n      const tangent = Core_Cartesian3.cross(\n        constrainedAxis,\n        p,\n        rotateVertScratchTan\n      );\n      camera.rotate(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\nCamera.prototype.rotateRight = function (angle) {\n  angle = Core_defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\nCamera.prototype.rotateLeft = function (angle) {\n  angle = Core_defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (Core_defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  const frustum = camera.frustum;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !(frustum instanceof Core_OrthographicOffCenterFrustum) ||\n    !Core_defined(frustum.left) ||\n    !Core_defined(frustum.right) ||\n    !Core_defined(frustum.bottom) ||\n    !Core_defined(frustum.top)\n  ) {\n    throw new Core_DeveloperError(\n      \"The camera frustum is expected to be orthographic for 2D camera control.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  amount = amount * 0.5;\n\n  if (\n    Math.abs(frustum.top) + Math.abs(frustum.bottom) >\n    Math.abs(frustum.left) + Math.abs(frustum.right)\n  ) {\n    let newTop = frustum.top - amount;\n    let newBottom = frustum.bottom + amount;\n\n    let maxBottom = camera._maxCoord.y;\n    if (camera._scene.mapMode2D === Scene_MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    let newRight = frustum.right - amount;\n    let newLeft = frustum.left + amount;\n\n    let maxRight = camera._maxCoord.x;\n    if (camera._scene.mapMode2D === Scene_MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\nCamera.prototype.zoomIn = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === Scene_SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\nCamera.prototype.zoomOut = function (amount) {\n  amount = Core_defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === Scene_SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {Number} The magnitude of the position.\n */\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === Scene_SceneMode.SCENE3D) {\n    return Core_Cartesian3.magnitude(this.position);\n  } else if (this._mode === Scene_SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === Scene_SceneMode.SCENE2D) {\n    return Math.max(\n      this.frustum.right - this.frustum.left,\n      this.frustum.top - this.frustum.bottom\n    );\n  }\n};\n\nconst scratchLookAtMatrix4 = new Core_Matrix4();\n\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(target)) {\n    throw new Core_DeveloperError(\"target is required\");\n  }\n  if (!Core_defined(offset)) {\n    throw new Core_DeveloperError(\"offset is required\");\n  }\n  if (this._mode === Scene_SceneMode.MORPHING) {\n    throw new Core_DeveloperError(\"lookAt is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  const transform = Core_Transforms.eastNorthUpToFixedFrame(\n    target,\n    Core_Ellipsoid.WGS84,\n    scratchLookAtMatrix4\n  );\n  this.lookAtTransform(transform, offset);\n};\n\nconst scratchLookAtHeadingPitchRangeOffset = new Core_Cartesian3();\nconst scratchLookAtHeadingPitchRangeQuaternion1 = new Core_Quaternion();\nconst scratchLookAtHeadingPitchRangeQuaternion2 = new Core_Quaternion();\nconst scratchHeadingPitchRangeMatrix3 = new Core_Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = Core_Math.clamp(\n    pitch,\n    -Core_Math.PI_OVER_TWO,\n    Core_Math.PI_OVER_TWO\n  );\n  heading = Core_Math.zeroToTwoPi(heading) - Core_Math.PI_OVER_TWO;\n\n  const pitchQuat = Core_Quaternion.fromAxisAngle(\n    Core_Cartesian3.UNIT_Y,\n    -pitch,\n    scratchLookAtHeadingPitchRangeQuaternion1\n  );\n  const headingQuat = Core_Quaternion.fromAxisAngle(\n    Core_Cartesian3.UNIT_Z,\n    -heading,\n    scratchLookAtHeadingPitchRangeQuaternion2\n  );\n  const rotQuat = Core_Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  const rotMatrix = Core_Matrix3.fromQuaternion(\n    rotQuat,\n    scratchHeadingPitchRangeMatrix3\n  );\n\n  const offset = Core_Cartesian3.clone(\n    Core_Cartesian3.UNIT_X,\n    scratchLookAtHeadingPitchRangeOffset\n  );\n  Core_Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Core_Cartesian3.negate(offset, offset);\n  Core_Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(transform)) {\n    throw new Core_DeveloperError(\"transform is required\");\n  }\n  if (this._mode === Scene_SceneMode.MORPHING) {\n    throw new Core_DeveloperError(\n      \"lookAtTransform is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._setTransform(transform);\n  if (!Core_defined(offset)) {\n    return;\n  }\n\n  let cartesianOffset;\n  if (Core_defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === Scene_SceneMode.SCENE2D) {\n    Core_Cartesian2.clone(Core_Cartesian2.ZERO, this.position);\n\n    Core_Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Core_Cartesian3.magnitudeSquared(this.up) < Core_Math.EPSILON10) {\n      Core_Cartesian3.clone(Core_Cartesian3.UNIT_Y, this.up);\n    }\n\n    Core_Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Core_Matrix4.IDENTITY);\n\n    Core_Cartesian3.negate(Core_Cartesian3.UNIT_Z, this.direction);\n    Core_Cartesian3.cross(this.direction, this.up, this.right);\n    Core_Cartesian3.normalize(this.right, this.right);\n\n    const frustum = this.frustum;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = Core_Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Core_Cartesian3.clone(cartesianOffset, this.position);\n  Core_Cartesian3.negate(this.position, this.direction);\n  Core_Cartesian3.normalize(this.direction, this.direction);\n  Core_Cartesian3.cross(this.direction, Core_Cartesian3.UNIT_Z, this.right);\n\n  if (Core_Cartesian3.magnitudeSquared(this.right) < Core_Math.EPSILON10) {\n    Core_Cartesian3.clone(Core_Cartesian3.UNIT_X, this.right);\n  }\n\n  Core_Cartesian3.normalize(this.right, this.right);\n  Core_Cartesian3.cross(this.right, this.direction, this.up);\n  Core_Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nconst viewRectangle3DCartographic1 = new Core_Cartographic();\nconst viewRectangle3DCartographic2 = new Core_Cartographic();\nconst viewRectangle3DNorthEast = new Core_Cartesian3();\nconst viewRectangle3DSouthWest = new Core_Cartesian3();\nconst viewRectangle3DNorthWest = new Core_Cartesian3();\nconst viewRectangle3DSouthEast = new Core_Cartesian3();\nconst viewRectangle3DNorthCenter = new Core_Cartesian3();\nconst viewRectangle3DSouthCenter = new Core_Cartesian3();\nconst viewRectangle3DCenter = new Core_Cartesian3();\nconst viewRectangle3DEquator = new Core_Cartesian3();\nconst defaultRF = {\n  direction: new Core_Cartesian3(),\n  right: new Core_Cartesian3(),\n  up: new Core_Cartesian3(),\n};\nlet viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  const opposite = Math.abs(Core_Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Core_Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  const ellipsoid = camera._projection.ellipsoid;\n  const cameraRF = updateCamera ? camera : defaultRF;\n\n  const north = rectangle.north;\n  const south = rectangle.south;\n  let east = rectangle.east;\n  const west = rectangle.west;\n\n  // If we go across the International Date Line\n  if (west > east) {\n    east += Core_Math.TWO_PI;\n  }\n\n  // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n  const longitude = (west + east) * 0.5;\n  let latitude;\n  if (\n    south < -Core_Math.PI_OVER_TWO + Core_Math.RADIANS_PER_DEGREE &&\n    north > Core_Math.PI_OVER_TWO - Core_Math.RADIANS_PER_DEGREE\n  ) {\n    latitude = 0.0;\n  } else {\n    const northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n\n    const southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n\n    let ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n    if (\n      !Core_defined(ellipsoidGeodesic) ||\n      ellipsoidGeodesic.ellipsoid !== ellipsoid\n    ) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new Core_EllipsoidGeodesic(\n        undefined,\n        undefined,\n        ellipsoid\n      );\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(\n      0.5,\n      viewRectangle3DCartographic1\n    ).latitude;\n  }\n\n  const centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n\n  const center = ellipsoid.cartographicToCartesian(\n    centerCartographic,\n    viewRectangle3DCenter\n  );\n\n  const cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  const northEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthEast\n  );\n  cart.longitude = west;\n  const northWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthWest\n  );\n  cart.longitude = longitude;\n  const northCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthCenter\n  );\n  cart.latitude = south;\n  const southCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthCenter\n  );\n  cart.longitude = east;\n  const southEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthEast\n  );\n  cart.longitude = west;\n  const southWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthWest\n  );\n\n  Core_Cartesian3.subtract(northWest, center, northWest);\n  Core_Cartesian3.subtract(southEast, center, southEast);\n  Core_Cartesian3.subtract(northEast, center, northEast);\n  Core_Cartesian3.subtract(southWest, center, southWest);\n  Core_Cartesian3.subtract(northCenter, center, northCenter);\n  Core_Cartesian3.subtract(southCenter, center, southCenter);\n\n  const direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Core_Cartesian3.negate(direction, direction);\n  const right = Core_Cartesian3.cross(direction, Core_Cartesian3.UNIT_Z, cameraRF.right);\n  Core_Cartesian3.normalize(right, right);\n  const up = Core_Cartesian3.cross(right, direction, cameraRF.up);\n\n  let d;\n  if (camera.frustum instanceof Core_OrthographicFrustum) {\n    const width = Math.max(\n      Core_Cartesian3.distance(northEast, northWest),\n      Core_Cartesian3.distance(southEast, southWest)\n    );\n    const height = Math.max(\n      Core_Cartesian3.distance(northEast, southEast),\n      Core_Cartesian3.distance(northWest, southWest)\n    );\n\n    let rightScalar;\n    let topScalar;\n    const ratio =\n      camera.frustum._offCenterFrustum.right /\n      camera.frustum._offCenterFrustum.top;\n    const heightRatio = height * ratio;\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n\n    d = Math.max(\n      computeD(direction, up, northWest, tanPhi),\n      computeD(direction, up, southEast, tanPhi),\n      computeD(direction, up, northEast, tanPhi),\n      computeD(direction, up, southWest, tanPhi),\n      computeD(direction, up, northCenter, tanPhi),\n      computeD(direction, up, southCenter, tanPhi),\n      computeD(direction, right, northWest, tanTheta),\n      computeD(direction, right, southEast, tanTheta),\n      computeD(direction, right, northEast, tanTheta),\n      computeD(direction, right, southWest, tanTheta),\n      computeD(direction, right, northCenter, tanTheta),\n      computeD(direction, right, southCenter, tanTheta)\n    );\n\n    // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n    if (south < 0 && north > 0) {\n      const equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      let equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Core_Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Core_Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n    }\n  }\n\n  return Core_Cartesian3.add(\n    center,\n    Core_Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator),\n    result\n  );\n}\n\nconst viewRectangleCVCartographic = new Core_Cartographic();\nconst viewRectangleCVNorthEast = new Core_Cartesian3();\nconst viewRectangleCVSouthWest = new Core_Cartesian3();\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  const projection = camera._projection;\n  if (rectangle.west > rectangle.east) {\n    rectangle = Core_Rectangle.MAX_VALUE;\n  }\n  const transform = camera._actualTransform;\n  const invTransform = camera._actualInvTransform;\n\n  const cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Core_Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Core_Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Core_Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Core_Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (Core_defined(camera.frustum.fovy)) {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z =\n      Math.max(\n        (northEast.x - southWest.x) / tanTheta,\n        (northEast.y - southWest.y) / tanPhi\n      ) * 0.5;\n  } else {\n    const width = northEast.x - southWest.x;\n    const height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nconst viewRectangle2DCartographic = new Core_Cartographic();\nconst viewRectangle2DNorthEast = new Core_Cartesian3();\nconst viewRectangle2DSouthWest = new Core_Cartesian3();\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  const projection = camera._projection;\n\n  // Account for the rectangle crossing the International Date Line in 2D mode\n  let east = rectangle.east;\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === Scene_MapMode2D.INFINITE_SCROLL) {\n      east += Core_Math.TWO_PI;\n    } else {\n      rectangle = Core_Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  let cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangle2DSouthWest);\n\n  const width = Math.abs(northEast.x - southWest.x) * 0.5;\n  let height = Math.abs(northEast.y - southWest.y) * 0.5;\n\n  let right, top;\n  const ratio = camera.frustum.right / camera.frustum.top;\n  const heightRatio = height * ratio;\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n\n  return result;\n}\n\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(rectangle)) {\n    throw new Core_DeveloperError(\"rectangle is required\");\n  }\n  //>>includeEnd('debug');\n  const mode = this._mode;\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  if (mode === Scene_SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === Scene_SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === Scene_SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nconst pickEllipsoid3DRay = new Core_Ray();\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  const intersection = Core_IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (!intersection) {\n    return undefined;\n  }\n\n  const t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Core_Ray.getPoint(ray, t, result);\n}\n\nconst pickEllipsoid2DRay = new Core_Ray();\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  let position = ray.origin;\n  position = Core_Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  const cart = projection.unproject(position);\n\n  if (\n    cart.latitude < -Core_Math.PI_OVER_TWO ||\n    cart.latitude > Core_Math.PI_OVER_TWO\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nconst pickEllipsoidCVRay = new Core_Ray();\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  const scalar = -ray.origin.x / ray.direction.x;\n  Core_Ray.getPoint(ray, scalar, result);\n\n  const cart = projection.unproject(new Core_Cartesian3(result.y, result.z, 0.0));\n\n  if (\n    cart.latitude < -Core_Math.PI_OVER_TWO ||\n    cart.latitude > Core_Math.PI_OVER_TWO ||\n    cart.longitude < -Math.PI ||\n    cart.longitude > Math.PI\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,\n * returns the point on the surface of the ellipsoid or map in world\n * coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * const canvas = viewer.scene.canvas;\n * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * const ellipsoid = viewer.scene.globe.ellipsoid;\n * const result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(windowPosition)) {\n    throw new Core_DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n\n  if (this._mode === Scene_SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === Scene_SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === Scene_SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(\n      this,\n      windowPosition,\n      this._projection,\n      result\n    );\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst pickPerspCenter = new Core_Cartesian3();\nconst pickPerspXDir = new Core_Cartesian3();\nconst pickPerspYDir = new Core_Cartesian3();\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const near = camera.frustum.near;\n\n  const x = (2.0 / width) * windowPosition.x - 1.0;\n  const y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n\n  const position = camera.positionWC;\n  Core_Cartesian3.clone(position, result.origin);\n\n  const nearCenter = Core_Cartesian3.multiplyByScalar(\n    camera.directionWC,\n    near,\n    pickPerspCenter\n  );\n  Core_Cartesian3.add(position, nearCenter, nearCenter);\n  const xDir = Core_Cartesian3.multiplyByScalar(\n    camera.rightWC,\n    x * near * tanTheta,\n    pickPerspXDir\n  );\n  const yDir = Core_Cartesian3.multiplyByScalar(\n    camera.upWC,\n    y * near * tanPhi,\n    pickPerspYDir\n  );\n  const direction = Core_Cartesian3.add(nearCenter, xDir, result.direction);\n  Core_Cartesian3.add(direction, yDir, direction);\n  Core_Cartesian3.subtract(direction, position, direction);\n  Core_Cartesian3.normalize(direction, direction);\n\n  return result;\n}\n\nconst scratchDirection = new Core_Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let frustum = camera.frustum;\n  if (Core_defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n  let x = (2.0 / width) * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  const origin = result.origin;\n  Core_Cartesian3.clone(camera.position, origin);\n\n  Core_Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Core_Cartesian3.add(scratchDirection, origin, origin);\n  Core_Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Core_Cartesian3.add(scratchDirection, origin, origin);\n\n  Core_Cartesian3.clone(camera.directionWC, result.direction);\n\n  if (\n    camera._mode === Scene_SceneMode.COLUMBUS_VIEW ||\n    camera._mode === Scene_SceneMode.SCENE2D\n  ) {\n    Core_Cartesian3.fromElements(\n      result.origin.z,\n      result.origin.x,\n      result.origin.y,\n      result.origin\n    );\n  }\n\n  return result;\n}\n\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray|undefined} Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.\n */\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(windowPosition)) {\n    throw new Core_DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!Core_defined(result)) {\n    result = new Core_Ray();\n  }\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth <= 0 || canvas.clientHeight <= 0) {\n    return undefined;\n  }\n\n  const frustum = this.frustum;\n  if (\n    Core_defined(frustum.aspectRatio) &&\n    Core_defined(frustum.fov) &&\n    Core_defined(frustum.near)\n  ) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nconst scratchToCenter = new Core_Cartesian3();\nconst scratchProj = new Core_Cartesian3();\n\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {Number} The distance to the bounding sphere.\n */\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(boundingSphere)) {\n    throw new Core_DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const toCenter = Core_Cartesian3.subtract(\n    this.positionWC,\n    boundingSphere.center,\n    scratchToCenter\n  );\n  const proj = Core_Cartesian3.multiplyByScalar(\n    this.directionWC,\n    Core_Cartesian3.dot(toCenter, this.directionWC),\n    scratchProj\n  );\n  return Math.max(0.0, Core_Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nconst scratchPixelSize = new Core_Cartesian2();\n\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {Number} drawingBufferWidth The drawing buffer width.\n * @param {Number} drawingBufferHeight The drawing buffer height.\n * @returns {Number} The pixel size in meters.\n */\nCamera.prototype.getPixelSize = function (\n  boundingSphere,\n  drawingBufferWidth,\n  drawingBufferHeight\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(boundingSphere)) {\n    throw new Core_DeveloperError(\"boundingSphere is required.\");\n  }\n  if (!Core_defined(drawingBufferWidth)) {\n    throw new Core_DeveloperError(\"drawingBufferWidth is required.\");\n  }\n  if (!Core_defined(drawingBufferHeight)) {\n    throw new Core_DeveloperError(\"drawingBufferHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = this.distanceToBoundingSphere(boundingSphere);\n  const pixelSize = this.frustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    this._scene.pixelRatio,\n    scratchPixelSize\n  );\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(\n  camera,\n  position,\n  center,\n  maxX,\n  maxY,\n  duration\n) {\n  const newPosition = Core_Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    const interp = Core_Cartesian3.lerp(\n      position,\n      newPosition,\n      value.time,\n      new Core_Cartesian3()\n    );\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n  return {\n    easingFunction: Core_EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    duration: duration,\n    update: updateCV,\n  };\n}\n\nconst Camera_normalScratch = new Core_Cartesian3();\nconst centerScratch = new Core_Cartesian3();\nconst posScratch = new Core_Cartesian3();\nconst scratchCartesian3Subtract = new Core_Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  let position = camera.position;\n  const direction = camera.direction;\n\n  const normal = camera.worldToCameraCoordinatesVector(\n    Core_Cartesian3.UNIT_X,\n    Camera_normalScratch\n  );\n  const scalar =\n    -Core_Cartesian3.dot(normal, position) / Core_Cartesian3.dot(normal, direction);\n  const center = Core_Cartesian3.add(\n    position,\n    Core_Cartesian3.multiplyByScalar(direction, scalar, centerScratch),\n    centerScratch\n  );\n  camera.cameraToWorldCoordinatesPoint(center, center);\n\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const distToC = Core_Cartesian3.magnitude(\n    Core_Cartesian3.subtract(position, center, scratchCartesian3Subtract)\n  );\n  const dWidth = tanTheta * distToC;\n  const dHeight = tanPhi * distToC;\n\n  const mapWidth = camera._maxCoord.x;\n  const mapHeight = camera._maxCoord.y;\n\n  const maxX = Math.max(dWidth - mapWidth, mapWidth);\n  const maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (\n    position.z < -maxX ||\n    position.z > maxX ||\n    position.y < -maxY ||\n    position.y > maxY\n  ) {\n    const translateX = center.y < -maxX || center.y > maxX;\n    const translateY = center.z < -maxY || center.z > maxY;\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(\n        camera,\n        position,\n        center,\n        maxX,\n        maxY,\n        duration\n      );\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {Number} duration The duration, in seconds, of the animation.\n * @returns {Object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(duration)) {\n    throw new Core_DeveloperError(\"duration is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._mode === Scene_SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nconst scratchFlyToDestination = new Core_Cartesian3();\nconst newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined,\n};\n\n/**\n * Cancels the current camera flight and leaves the camera at its current location.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.cancelFlight = function () {\n  if (Core_defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Completes the current camera flight and moves the camera immediately to its final destination.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.completeFlight = function () {\n  if (Core_defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    const options = {\n      destination: undefined,\n      orientation: {\n        heading: undefined,\n        pitch: undefined,\n        roll: undefined,\n      },\n    };\n\n    options.destination = newOptions.destination;\n    options.orientation.heading = newOptions.heading;\n    options.orientation.pitch = newOptions.pitch;\n    options.orientation.roll = newOptions.roll;\n\n    this.setView(options);\n\n    if (Core_defined(this._currentFlight.complete)) {\n      this._currentFlight.complete();\n    }\n\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\nCamera.prototype.flyTo = function (options) {\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(destination)) {\n    throw new Core_DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const mode = this._mode;\n  if (mode === Scene_SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n\n  const isRectangle = destination instanceof Core_Rectangle;\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchFlyToDestination\n    );\n  }\n\n  let orientation = Core_defaultValue(\n    options.orientation,\n    Core_defaultValue.EMPTY_OBJECT\n  );\n  if (Core_defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  if (Core_defined(options.duration) && options.duration <= 0.0) {\n    const setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n    return;\n  }\n\n  const that = this;\n  /* eslint-disable-next-line prefer-const */\n  let flightTween;\n\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n    if (Core_defined(options.complete)) {\n      options.complete();\n    }\n  };\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n\n  const scene = this._scene;\n  const tweenOptions = Scene_CameraFlightPath.createTween(scene, newOptions);\n  // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n    return;\n  }\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween;\n\n  // Save the final destination view information for the PRELOAD_FLIGHT pass.\n  let preloadFlightCamera = this._scene.preloadFlightCamera;\n  if (this._mode !== Scene_SceneMode.SCENE2D) {\n    if (!Core_defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation,\n    });\n\n    this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(\n      preloadFlightCamera.positionWC,\n      preloadFlightCamera.directionWC,\n      preloadFlightCamera.upWC\n    );\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  const frustum = camera.frustum;\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  let frustum = camera.frustum;\n  if (Core_defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  let right, top;\n  const ratio = frustum.right / frustum.top;\n  const heightRatio = radius * ratio;\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nconst MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = Core_HeadingPitchRange.clone(\n    Core_defined(offset) ? offset : Camera.DEFAULT_OFFSET\n  );\n\n  const minimumZoom =\n    camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  const maximumZoom =\n    camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  const range = offset.range;\n  if (!Core_defined(range) || range === 0.0) {\n    const radius = boundingSphere.radius;\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (\n      camera.frustum instanceof Core_OrthographicFrustum ||\n      camera._mode === Scene_SceneMode.SCENE2D\n    ) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n    offset.range = Core_Math.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(boundingSphere)) {\n    throw new Core_DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === Scene_SceneMode.MORPHING) {\n    throw new Core_DeveloperError(\n      \"viewBoundingSphere is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nconst scratchflyToBoundingSphereTransform = new Core_Matrix4();\nconst scratchflyToBoundingSphereDestination = new Core_Cartesian3();\nconst scratchflyToBoundingSphereDirection = new Core_Cartesian3();\nconst scratchflyToBoundingSphereUp = new Core_Cartesian3();\nconst scratchflyToBoundingSphereRight = new Core_Cartesian3();\nconst scratchFlyToBoundingSphereCart4 = new Core_Cartesian4();\nconst scratchFlyToBoundingSphereQuaternion = new Core_Quaternion();\nconst scratchFlyToBoundingSphereMatrix3 = new Core_Matrix3();\n\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Core_defined(boundingSphere)) {\n    throw new Core_DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = Core_defaultValue(options, Core_defaultValue.EMPTY_OBJECT);\n  const scene2D =\n    this._mode === Scene_SceneMode.SCENE2D || this._mode === Scene_SceneMode.COLUMBUS_VIEW;\n  this._setTransform(Core_Matrix4.IDENTITY);\n  const offset = adjustBoundingSphereOffset(\n    this,\n    boundingSphere,\n    options.offset\n  );\n\n  let position;\n  if (scene2D) {\n    position = Core_Cartesian3.multiplyByScalar(\n      Core_Cartesian3.UNIT_Z,\n      offset.range,\n      scratchflyToBoundingSphereDestination\n    );\n  } else {\n    position = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  }\n\n  const transform = Core_Transforms.eastNorthUpToFixedFrame(\n    boundingSphere.center,\n    Core_Ellipsoid.WGS84,\n    scratchflyToBoundingSphereTransform\n  );\n  Core_Matrix4.multiplyByPoint(transform, position, position);\n\n  let direction;\n  let up;\n\n  if (!scene2D) {\n    direction = Core_Cartesian3.subtract(\n      boundingSphere.center,\n      position,\n      scratchflyToBoundingSphereDirection\n    );\n    Core_Cartesian3.normalize(direction, direction);\n\n    up = Core_Matrix4.multiplyByPointAsVector(\n      transform,\n      Core_Cartesian3.UNIT_Z,\n      scratchflyToBoundingSphereUp\n    );\n    if (1.0 - Math.abs(Core_Cartesian3.dot(direction, up)) < Core_Math.EPSILON6) {\n      const rotateQuat = Core_Quaternion.fromAxisAngle(\n        direction,\n        offset.heading,\n        scratchFlyToBoundingSphereQuaternion\n      );\n      const rotation = Core_Matrix3.fromQuaternion(\n        rotateQuat,\n        scratchFlyToBoundingSphereMatrix3\n      );\n\n      Core_Cartesian3.fromCartesian4(\n        Core_Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4),\n        up\n      );\n      Core_Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    const right = Core_Cartesian3.cross(\n      direction,\n      up,\n      scratchflyToBoundingSphereRight\n    );\n    Core_Cartesian3.cross(right, direction, up);\n    Core_Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up,\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight,\n  });\n};\n\nconst scratchCartesian3_1 = new Core_Cartesian3();\nconst scratchCartesian3_2 = new Core_Cartesian3();\nconst scratchCartesian3_3 = new Core_Cartesian3();\nconst scratchCartesian3_4 = new Core_Cartesian3();\nconst horizonPoints = [\n  new Core_Cartesian3(),\n  new Core_Cartesian3(),\n  new Core_Cartesian3(),\n  new Core_Cartesian3(),\n];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  const radii = ellipsoid.radii;\n  const p = camera.positionWC;\n\n  // Find the corresponding position in the scaled space of the ellipsoid.\n  const q = Core_Cartesian3.multiplyComponents(\n    ellipsoid.oneOverRadii,\n    p,\n    scratchCartesian3_1\n  );\n\n  const qMagnitude = Core_Cartesian3.magnitude(q);\n  const qUnit = Core_Cartesian3.normalize(q, scratchCartesian3_2);\n\n  // Determine the east and north directions at q.\n  let eUnit;\n  let nUnit;\n  if (\n    Core_Cartesian3.equalsEpsilon(qUnit, Core_Cartesian3.UNIT_Z, Core_Math.EPSILON10)\n  ) {\n    eUnit = new Core_Cartesian3(0, 1, 0);\n    nUnit = new Core_Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Core_Cartesian3.normalize(\n      Core_Cartesian3.cross(Core_Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3),\n      scratchCartesian3_3\n    );\n    nUnit = Core_Cartesian3.normalize(\n      Core_Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4),\n      scratchCartesian3_4\n    );\n  }\n\n  // Determine the radius of the 'limb' of the ellipsoid.\n  const wMagnitude = Math.sqrt(Core_Cartesian3.magnitudeSquared(q) - 1.0);\n\n  // Compute the center and offsets.\n  const center = Core_Cartesian3.multiplyByScalar(\n    qUnit,\n    1.0 / qMagnitude,\n    scratchCartesian3_1\n  );\n  const scalar = wMagnitude / qMagnitude;\n  const eastOffset = Core_Cartesian3.multiplyByScalar(\n    eUnit,\n    scalar,\n    scratchCartesian3_2\n  );\n  const northOffset = Core_Cartesian3.multiplyByScalar(\n    nUnit,\n    scalar,\n    scratchCartesian3_3\n  );\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  const upperLeft = Core_Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Core_Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Core_Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n\n  const lowerLeft = Core_Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Core_Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Core_Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n\n  const lowerRight = Core_Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Core_Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Core_Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n\n  const upperRight = Core_Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Core_Cartesian3.add(upperRight, eastOffset, upperRight);\n  Core_Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n\n  return horizonPoints;\n}\n\nconst scratchPickCartesian2 = new Core_Cartesian2();\nconst scratchRectCartesian = new Core_Cartesian3();\nconst cartoArray = [\n  new Core_Cartographic(),\n  new Core_Cartographic(),\n  new Core_Cartographic(),\n  new Core_Cartographic(),\n];\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  const r = camera.pickEllipsoid(\n    scratchPickCartesian2,\n    ellipsoid,\n    scratchRectCartesian\n  );\n  if (Core_defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n  cartoArray[index] = ellipsoid.cartesianToCartographic(\n    computedHorizonQuad[index],\n    cartoArray[index]\n  );\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = Core_defaultValue(ellipsoid, Core_Ellipsoid.WGS84);\n  const cullingVolume = this.frustum.computeCullingVolume(\n    this.positionWC,\n    this.directionWC,\n    this.upWC\n  );\n  const boundingSphere = new Core_BoundingSphere(\n    Core_Cartesian3.ZERO,\n    ellipsoid.maximumRadius\n  );\n  const visibility = cullingVolume.computeVisibility(boundingSphere);\n  if (visibility === Core_Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  const canvas = this._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let successfulPickCount = 0;\n\n  const computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n\n  successfulPickCount += addToResult(\n    0,\n    0,\n    0,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    0,\n    height,\n    1,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    height,\n    2,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    0,\n    3,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Core_Rectangle.MAX_VALUE;\n  }\n\n  result = Core_Rectangle.fromCartographicArray(cartoArray, result);\n\n  // Detect if we go over the poles\n  let distance = 0;\n  let lastLon = cartoArray[3].longitude;\n  for (let i = 0; i < 4; ++i) {\n    const lon = cartoArray[i].longitude;\n    const diff = Math.abs(lon - lastLon);\n    if (diff > Core_Math.PI) {\n      // Crossed the dateline\n      distance += Core_Math.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  }\n\n  // We are over one of the poles so adjust the rectangle accordingly\n  if (\n    Core_Math.equalsEpsilon(\n      Math.abs(distance),\n      Core_Math.TWO_PI,\n      Core_Math.EPSILON9\n    )\n  ) {\n    result.west = -Core_Math.PI;\n    result.east = Core_Math.PI;\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = Core_Math.PI_OVER_TWO;\n    } else {\n      result.south = -Core_Math.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (\n    this._mode === Scene_SceneMode.SCENE2D ||\n    this.frustum instanceof Core_PerspectiveFrustum\n  ) {\n    return;\n  }\n\n  const scene = this._scene;\n  this.frustum = new Core_PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = Core_Math.toRadians(60.0);\n};\n\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (\n    this._mode === Scene_SceneMode.SCENE2D ||\n    this.frustum instanceof Core_OrthographicFrustum\n  ) {\n    return;\n  }\n\n  // This must be called before changing the frustum because it uses the previous\n  // frustum to reconstruct the world space position from the depth buffer.\n  const frustumWidth = calculateOrthographicFrustumWidth(this);\n\n  const scene = this._scene;\n  this.frustum = new Core_OrthographicFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.width = frustumWidth;\n};\n\n/**\n * @private\n */\nCamera.clone = function (camera, result) {\n  if (!Core_defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Core_Cartesian3.clone(camera.position, result.position);\n  Core_Cartesian3.clone(camera.direction, result.direction);\n  Core_Cartesian3.clone(camera.up, result.up);\n  Core_Cartesian3.clone(camera.right, result.right);\n  Core_Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n\n  return result;\n};\n\n/**\n * A function that will execute when a flight completes.\n * @callback Camera.FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera.FlightCancelledCallback\n */\n/* harmony default export */ const Scene_Camera = (Camera);\n\n;// CONCATENATED MODULE: ./svgPaths/svgReset.js\nvar svgReset = 'M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z';\n/* harmony default export */ const svgPaths_svgReset = (svgReset);\n;// CONCATENATED MODULE: ./viewModels/UserInterfaceControl.js\n\nvar UserInterfaceControl_Knockout = ThirdParty_knockout;\n/**\n * The view-model for a control in the user interface\n *\n * @alias UserInterfaceControl\n * @constructor\n * @abstract\n *\n * @param {Terria} terria The Terria instance.\n */\nvar UserInterfaceControl = function UserInterfaceControl(terria) {\n  if (!Core_defined(terria)) {\n    throw new Core_DeveloperError('terria is required');\n  }\n  this._terria = terria;\n\n  /**\n   * Gets or sets the name of the control which is set as the controls title.\n   * This property is observable.\n   * @type {String}\n   */\n  this.name = 'Unnamed Control';\n\n  /**\n   * Gets or sets the text to be displayed in the UI control.\n   * This property is observable.\n   * @type {String}\n   */\n  this.text = undefined;\n\n  /**\n   * Gets or sets the svg icon of the control.  This property is observable.\n   * @type {Object}\n   */\n  this.svgIcon = undefined;\n\n  /**\n   * Gets or sets the height of the svg icon.  This property is observable.\n   * @type {Integer}\n   */\n  this.svgHeight = undefined;\n\n  /**\n   * Gets or sets the width of the svg icon.  This property is observable.\n   * @type {Integer}\n   */\n  this.svgWidth = undefined;\n\n  /**\n   * Gets or sets the CSS class of the control. This property is observable.\n   * @type {String}\n   */\n  this.cssClass = undefined;\n\n  /**\n   * Gets or sets the property describing whether or not the control is in the active state.\n   * This property is observable.\n   * @type {Boolean}\n   */\n  this.isActive = false;\n  UserInterfaceControl_Knockout.track(this, ['name', 'svgIcon', 'svgHeight', 'svgWidth', 'cssClass', 'isActive']);\n};\nObject.defineProperties(UserInterfaceControl.prototype, {\n  /**\n   * Gets the Terria instance.\n   * @memberOf UserInterfaceControl.prototype\n   * @type {Terria}\n   */\n  terria: {\n    get: function get() {\n      return this._terria;\n    }\n  },\n  /**\n   * Gets a value indicating whether this button has text associated with it.\n   * @type {Object}\n   */\n  hasText: {\n    get: function get() {\n      return Core_defined(this.text) && typeof this.text === 'string';\n    }\n  }\n});\n\n/**\n * When implemented in a derived class, performs an action when the user clicks\n * on this control.\n * @abstract\n * @protected\n */\nUserInterfaceControl.prototype.activate = function () {\n  throw new Core_DeveloperError('activate must be implemented in the derived class.');\n};\n/* harmony default export */ const viewModels_UserInterfaceControl = (UserInterfaceControl);\n;// CONCATENATED MODULE: ./viewModels/NavigationControl.js\n\n/**\n * The view-model for a control in the navigation control tool bar\n *\n * @alias NavigationControl\n * @constructor\n * @abstract\n *\n * @param {Terria} terria The Terria instance.\n */\nvar NavigationControl = function NavigationControl(terria) {\n  viewModels_UserInterfaceControl.apply(this, arguments);\n};\nNavigationControl.prototype = Object.create(viewModels_UserInterfaceControl.prototype);\n/* harmony default export */ const viewModels_NavigationControl = (NavigationControl);\n;// CONCATENATED MODULE: ./viewModels/ResetViewNavigationControl.js\n\n\n\n\n/**\n * The model for a zoom in control in the navigation control tool bar\n *\n * @alias ResetViewNavigationControl\n * @constructor\n * @abstract\n *\n * @param {Terria} terria The Terria instance.\n */\nvar ResetViewNavigationControl = function ResetViewNavigationControl(terria) {\n  viewModels_NavigationControl.apply(this, arguments);\n\n  /**\n   * Gets or sets the name of the control which is set as the control's title.\n   * This property is observable.\n   * @type {String}\n   */\n  this.name = '重置视图';\n  this.navigationLocked = false;\n\n  /**\n   * Gets or sets the svg icon of the control.  This property is observable.\n   * @type {Object}\n   */\n  this.svgIcon = svgPaths_svgReset;\n\n  /**\n   * Gets or sets the height of the svg icon.  This property is observable.\n   * @type {Integer}\n   */\n  this.svgHeight = 15;\n\n  /**\n   * Gets or sets the width of the svg icon.  This property is observable.\n   * @type {Integer}\n   */\n  this.svgWidth = 15;\n\n  /**\n   * Gets or sets the CSS class of the control. This property is observable.\n   * @type {String}\n   */\n  this.cssClass = 'navigation-control-icon-reset';\n};\nResetViewNavigationControl.prototype = Object.create(viewModels_NavigationControl.prototype);\nResetViewNavigationControl.prototype.setNavigationLocked = function (locked) {\n  this.navigationLocked = locked;\n};\nResetViewNavigationControl.prototype.resetView = function () {\n  // this.terria.analytics.logEvent('navigation', 'click', 'reset');\n  if (this.navigationLocked) {\n    return;\n  }\n  var scene = this.terria.scene;\n  var sscc = scene.screenSpaceCameraController;\n  if (!sscc.enableInputs) {\n    return;\n  }\n  this.isActive = true;\n  var camera = scene.camera;\n  if (Core_defined(this.terria.trackedEntity)) {\n    // when tracking do not reset to default view but to default view of tracked entity\n    var trackedEntity = this.terria.trackedEntity;\n    this.terria.trackedEntity = undefined;\n    this.terria.trackedEntity = trackedEntity;\n  } else {\n    // reset to a default position or view defined in the options\n    if (this.terria.options.defaultResetView) {\n      if (this.terria.options.defaultResetView && this.terria.options.defaultResetView instanceof Cesium.Cartographic) {\n        camera.flyTo({\n          destination: scene.globe.ellipsoid.cartographicToCartesian(this.terria.options.defaultResetView)\n        });\n      } else if (this.terria.options.defaultResetView && this.terria.options.defaultResetView instanceof Cesium.Rectangle) {\n        try {\n          Core_Rectangle.validate(this.terria.options.defaultResetView);\n          camera.flyTo({\n            destination: this.terria.options.defaultResetView,\n            orientation: {\n              heading: Core_Math.toRadians(5.729578)\n            }\n          });\n        } catch (e) {\n          console.log('Cesium-navigation/ResetViewNavigationControl:   options.defaultResetView Cesium rectangle is  invalid!');\n        }\n      }\n    } else if (typeof camera.flyHome === 'function') {\n      camera.flyHome(1);\n    } else {\n      camera.flyTo({\n        'destination': Scene_Camera.DEFAULT_VIEW_RECTANGLE,\n        'duration': 1\n      });\n    }\n  }\n  this.isActive = false;\n};\n\n/**\n * When implemented in a derived class, performs an action when the user clicks\n * on this control\n * @abstract\n * @protected\n */\nResetViewNavigationControl.prototype.activate = function () {\n  this.resetView();\n};\n/* harmony default export */ const viewModels_ResetViewNavigationControl = (ResetViewNavigationControl);\n;// CONCATENATED MODULE: ./core/Utils.js\n/* eslint-disable no-unused-vars */\n\nvar Utils = {};\nvar unprojectedScratch = new Core_Cartographic();\nvar rayScratch = new Core_Ray();\n\n/**\n * gets the focus point of the camera\n * @param {Viewer|Widget} terria The terria\n * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, otherwise get it in projection-specific map coordinates, in meters.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @return {Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.\n */\nUtils.getCameraFocus = function (terria, inWorldCoordinates, result) {\n  var scene = terria.scene;\n  var camera = scene.camera;\n  if (scene.mode === Scene_SceneMode.MORPHING) {\n    return undefined;\n  }\n  if (!Core_defined(result)) {\n    result = new Core_Cartesian3();\n  }\n\n  // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating\n  // TODO bug when tracking: reset should reset to default view of tracked entity\n\n  if (Core_defined(terria.trackedEntity)) {\n    result = terria.trackedEntity.position.getValue(terria.clock.currentTime, result);\n  } else {\n    rayScratch.origin = camera.positionWC;\n    rayScratch.direction = camera.directionWC;\n    result = scene.globe.pick(rayScratch, scene, result);\n  }\n  if (!Core_defined(result)) {\n    return undefined;\n  }\n  if (scene.mode === Scene_SceneMode.SCENE2D || scene.mode === Scene_SceneMode.COLUMBUS_VIEW) {\n    result = camera.worldToCameraCoordinatesPoint(result, result);\n    if (inWorldCoordinates) {\n      result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result);\n    }\n  } else {\n    if (!inWorldCoordinates) {\n      result = camera.worldToCameraCoordinatesPoint(result, result);\n    }\n  }\n  return result;\n};\n/* harmony default export */ const core_Utils = (Utils);\n;// CONCATENATED MODULE: ./viewModels/ZoomNavigationControl.js\n\n\n\n\n/**\n * The model for a zoom in control in the navigation control tool bar\n *\n * @alias ZoomOutNavigationControl\n * @constructor\n * @abstract\n *\n * @param {Terria} terria The Terria instance.\n * @param {boolean} zoomIn is used for zooming in (true) or out (false)\n */\nvar ZoomNavigationControl = function ZoomNavigationControl(terria, zoomIn) {\n  viewModels_NavigationControl.apply(this, arguments);\n\n  /**\n   * Gets or sets the name of the control which is set as the control's title.\n   * This property is observable.\n   * @type {String}\n   */\n  this.name = 'Zoom ' + (zoomIn ? 'In' : 'Out');\n\n  /**\n   * Gets or sets the text to be displayed in the nav control. Controls that\n   * have text do not display the svgIcon.\n   * This property is observable.\n   * @type {String}\n   */\n  this.text = zoomIn ? '+' : '-';\n\n  /**\n   * Gets or sets the CSS class of the control. This property is observable.\n   * @type {String}\n   */\n  this.cssClass = 'navigation-control-icon-zoom-' + (zoomIn ? 'in' : 'out');\n  this.relativeAmount = 2;\n  if (zoomIn) {\n    // this ensures that zooming in is the inverse of zooming out and vice versa\n    // e.g. the camera position remains when zooming in and out\n    this.relativeAmount = 1 / this.relativeAmount;\n  }\n};\nZoomNavigationControl.prototype.relativeAmount = 1;\nZoomNavigationControl.prototype = Object.create(viewModels_NavigationControl.prototype);\n\n/**\n * When implemented in a derived class, performs an action when the user clicks\n * on this control\n * @abstract\n * @protected\n */\nZoomNavigationControl.prototype.activate = function () {\n  this.zoom(this.relativeAmount);\n};\nvar cartesian3Scratch = new Core_Cartesian3();\nZoomNavigationControl.prototype.zoom = function (relativeAmount) {\n  // this.terria.analytics.logEvent('navigation', 'click', 'zoomIn');\n\n  this.isActive = true;\n  if (Core_defined(this.terria)) {\n    var scene = this.terria.scene;\n    var sscc = scene.screenSpaceCameraController;\n    // do not zoom if it is disabled\n    if (!sscc.enableInputs || !sscc.enableZoom) {\n      return;\n    }\n    // TODO\n    //            if(scene.mode == SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {\n    //                return;\n    //            }\n\n    var camera = scene.camera;\n    var orientation;\n    switch (scene.mode) {\n      case Scene_SceneMode.MORPHING:\n        break;\n      case Scene_SceneMode.SCENE2D:\n        camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));\n        break;\n      default:\n        var focus;\n        if (Core_defined(this.terria.trackedEntity)) {\n          focus = new Core_Cartesian3();\n        } else {\n          focus = core_Utils.getCameraFocus(this.terria, false);\n        }\n        if (!Core_defined(focus)) {\n          // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as\n          // the focal point.\n          var ray = new Core_Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);\n          focus = Core_IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);\n          orientation = {\n            heading: camera.heading,\n            pitch: camera.pitch,\n            roll: camera.roll\n          };\n        } else {\n          orientation = {\n            direction: camera.direction,\n            up: camera.up\n          };\n        }\n        var direction = Core_Cartesian3.subtract(camera.position, focus, cartesian3Scratch);\n        var movementVector = Core_Cartesian3.multiplyByScalar(direction, relativeAmount, direction);\n        var endPosition = Core_Cartesian3.add(focus, movementVector, focus);\n        if (Core_defined(this.terria.trackedEntity) || scene.mode === Scene_SceneMode.COLUMBUS_VIEW) {\n          // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation\n          // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change\n          camera.position = endPosition;\n        } else {\n          camera.flyTo({\n            destination: endPosition,\n            orientation: orientation,\n            duration: 0.5,\n            convert: false\n          });\n        }\n    }\n  }\n\n  // this.terria.notifyRepaintRequired();\n  this.isActive = false;\n};\n/* harmony default export */ const viewModels_ZoomNavigationControl = (ZoomNavigationControl);\n;// CONCATENATED MODULE: ./svgPaths/svgCompassOuterRing.js\nvar svgCompassOuterRing = 'm 66.5625,0 0,15.15625 3.71875,0 0,-10.40625 5.5,10.40625 4.375,0 0,-15.15625 -3.71875,0 0,10.40625 L 70.9375,0 66.5625,0 z M 72.5,20.21875 c -28.867432,0 -52.28125,23.407738 -52.28125,52.28125 0,28.87351 23.413818,52.3125 52.28125,52.3125 28.86743,0 52.28125,-23.43899 52.28125,-52.3125 0,-28.873512 -23.41382,-52.28125 -52.28125,-52.28125 z m 0,1.75 c 13.842515,0 26.368948,5.558092 35.5,14.5625 l -11.03125,11 0.625,0.625 11.03125,-11 c 8.9199,9.108762 14.4375,21.579143 14.4375,35.34375 0,13.764606 -5.5176,26.22729 -14.4375,35.34375 l -11.03125,-11 -0.625,0.625 11.03125,11 c -9.130866,9.01087 -21.658601,14.59375 -35.5,14.59375 -13.801622,0 -26.321058,-5.53481 -35.4375,-14.5 l 11.125,-11.09375 c 6.277989,6.12179 14.857796,9.90625 24.3125,9.90625 19.241896,0 34.875,-15.629154 34.875,-34.875 0,-19.245847 -15.633104,-34.84375 -34.875,-34.84375 -9.454704,0 -18.034511,3.760884 -24.3125,9.875 L 37.0625,36.4375 C 46.179178,27.478444 58.696991,21.96875 72.5,21.96875 z m -0.875,0.84375 0,13.9375 1.75,0 0,-13.9375 -1.75,0 z M 36.46875,37.0625 47.5625,48.15625 C 41.429794,54.436565 37.65625,63.027539 37.65625,72.5 c 0,9.472461 3.773544,18.055746 9.90625,24.34375 L 36.46875,107.9375 c -8.96721,-9.1247 -14.5,-21.624886 -14.5,-35.4375 0,-13.812615 5.53279,-26.320526 14.5,-35.4375 z M 72.5,39.40625 c 18.297686,0 33.125,14.791695 33.125,33.09375 0,18.302054 -14.827314,33.125 -33.125,33.125 -18.297687,0 -33.09375,-14.822946 -33.09375,-33.125 0,-18.302056 14.796063,-33.09375 33.09375,-33.09375 z M 22.84375,71.625 l 0,1.75 13.96875,0 0,-1.75 -13.96875,0 z m 85.5625,0 0,1.75 14,0 0,-1.75 -14,0 z M 71.75,108.25 l 0,13.9375 1.71875,0 0,-13.9375 -1.71875,0 z';\n/* harmony default export */ const svgPaths_svgCompassOuterRing = (svgCompassOuterRing);\n;// CONCATENATED MODULE: ./svgPaths/svgCompassGyro.js\nvar svgCompassGyro = 'm 72.71875,54.375 c -0.476702,0 -0.908208,0.245402 -1.21875,0.5625 -0.310542,0.317098 -0.551189,0.701933 -0.78125,1.1875 -0.172018,0.363062 -0.319101,0.791709 -0.46875,1.25 -6.91615,1.075544 -12.313231,6.656514 -13,13.625 -0.327516,0.117495 -0.661877,0.244642 -0.9375,0.375 -0.485434,0.22959 -0.901634,0.471239 -1.21875,0.78125 -0.317116,0.310011 -0.5625,0.742111 -0.5625,1.21875 l 0.03125,0 c 0,0.476639 0.245384,0.877489 0.5625,1.1875 0.317116,0.310011 0.702066,0.58291 1.1875,0.8125 0.35554,0.168155 0.771616,0.32165 1.21875,0.46875 1.370803,6.10004 6.420817,10.834127 12.71875,11.8125 0.146999,0.447079 0.30025,0.863113 0.46875,1.21875 0.230061,0.485567 0.470708,0.870402 0.78125,1.1875 0.310542,0.317098 0.742048,0.5625 1.21875,0.5625 0.476702,0 0.876958,-0.245402 1.1875,-0.5625 0.310542,-0.317098 0.582439,-0.701933 0.8125,-1.1875 0.172018,-0.363062 0.319101,-0.791709 0.46875,-1.25 6.249045,-1.017063 11.256351,-5.7184 12.625,-11.78125 0.447134,-0.1471 0.86321,-0.300595 1.21875,-0.46875 0.485434,-0.22959 0.901633,-0.502489 1.21875,-0.8125 0.317117,-0.310011 0.5625,-0.710861 0.5625,-1.1875 l -0.03125,0 c 0,-0.476639 -0.245383,-0.908739 -0.5625,-1.21875 C 89.901633,71.846239 89.516684,71.60459 89.03125,71.375 88.755626,71.244642 88.456123,71.117495 88.125,71 87.439949,64.078341 82.072807,58.503735 75.21875,57.375 c -0.15044,-0.461669 -0.326927,-0.884711 -0.5,-1.25 -0.230061,-0.485567 -0.501958,-0.870402 -0.8125,-1.1875 -0.310542,-0.317098 -0.710798,-0.5625 -1.1875,-0.5625 z m -0.0625,1.40625 c 0.03595,-0.01283 0.05968,0 0.0625,0 0.0056,0 0.04321,-0.02233 0.1875,0.125 0.144288,0.147334 0.34336,0.447188 0.53125,0.84375 0.06385,0.134761 0.123901,0.309578 0.1875,0.46875 -0.320353,-0.01957 -0.643524,-0.0625 -0.96875,-0.0625 -0.289073,0 -0.558569,0.04702 -0.84375,0.0625 C 71.8761,57.059578 71.936151,56.884761 72,56.75 c 0.18789,-0.396562 0.355712,-0.696416 0.5,-0.84375 0.07214,-0.07367 0.120304,-0.112167 0.15625,-0.125 z m 0,2.40625 c 0.448007,0 0.906196,0.05436 1.34375,0.09375 0.177011,0.592256 0.347655,1.271044 0.5,2.03125 0.475097,2.370753 0.807525,5.463852 0.9375,8.9375 -0.906869,-0.02852 -1.834463,-0.0625 -2.78125,-0.0625 -0.92298,0 -1.802327,0.03537 -2.6875,0.0625 0.138529,-3.473648 0.493653,-6.566747 0.96875,-8.9375 0.154684,-0.771878 0.320019,-1.463985 0.5,-2.0625 0.405568,-0.03377 0.804291,-0.0625 1.21875,-0.0625 z m -2.71875,0.28125 c -0.129732,0.498888 -0.259782,0.987558 -0.375,1.5625 -0.498513,2.487595 -0.838088,5.693299 -0.96875,9.25 -3.21363,0.15162 -6.119596,0.480068 -8.40625,0.9375 -0.682394,0.136509 -1.275579,0.279657 -1.84375,0.4375 0.799068,-6.135482 5.504716,-11.036454 11.59375,-12.1875 z M 75.5,58.5 c 6.043169,1.18408 10.705093,6.052712 11.5,12.15625 -0.569435,-0.155806 -1.200273,-0.302525 -1.875,-0.4375 -2.262525,-0.452605 -5.108535,-0.783809 -8.28125,-0.9375 -0.130662,-3.556701 -0.470237,-6.762405 -0.96875,-9.25 C 75.761959,59.467174 75.626981,58.990925 75.5,58.5 z m -2.84375,12.09375 c 0.959338,0 1.895843,0.03282 2.8125,0.0625 C 75.48165,71.267751 75.5,71.871028 75.5,72.5 c 0,1.228616 -0.01449,2.438313 -0.0625,3.59375 -0.897358,0.0284 -1.811972,0.0625 -2.75,0.0625 -0.927373,0 -1.831062,-0.03473 -2.71875,-0.0625 -0.05109,-1.155437 -0.0625,-2.365134 -0.0625,-3.59375 0,-0.628972 0.01741,-1.232249 0.03125,-1.84375 0.895269,-0.02827 1.783025,-0.0625 2.71875,-0.0625 z M 68.5625,70.6875 c -0.01243,0.60601 -0.03125,1.189946 -0.03125,1.8125 0,1.22431 0.01541,2.407837 0.0625,3.5625 -3.125243,-0.150329 -5.92077,-0.471558 -8.09375,-0.90625 -0.784983,-0.157031 -1.511491,-0.316471 -2.125,-0.5 -0.107878,-0.704096 -0.1875,-1.422089 -0.1875,-2.15625 0,-0.115714 0.02849,-0.228688 0.03125,-0.34375 0.643106,-0.20284 1.389577,-0.390377 2.25,-0.5625 2.166953,-0.433487 4.97905,-0.75541 8.09375,-0.90625 z m 8.3125,0.03125 c 3.075121,0.15271 5.824455,0.446046 7.96875,0.875 0.857478,0.171534 1.630962,0.360416 2.28125,0.5625 0.0027,0.114659 0,0.228443 0,0.34375 0,0.735827 -0.07914,1.450633 -0.1875,2.15625 -0.598568,0.180148 -1.29077,0.34562 -2.0625,0.5 -2.158064,0.431708 -4.932088,0.754666 -8.03125,0.90625 0.04709,-1.154663 0.0625,-2.33819 0.0625,-3.5625 0,-0.611824 -0.01924,-1.185379 -0.03125,-1.78125 z M 57.15625,72.5625 c 0.0023,0.572772 0.06082,1.131112 0.125,1.6875 -0.125327,-0.05123 -0.266577,-0.10497 -0.375,-0.15625 -0.396499,-0.187528 -0.665288,-0.387337 -0.8125,-0.53125 -0.147212,-0.143913 -0.15625,-0.182756 -0.15625,-0.1875 0,-0.0047 -0.02221,-0.07484 0.125,-0.21875 0.147212,-0.143913 0.447251,-0.312472 0.84375,-0.5 0.07123,-0.03369 0.171867,-0.06006 0.25,-0.09375 z m 31.03125,0 c 0.08201,0.03503 0.175941,0.05872 0.25,0.09375 0.396499,0.187528 0.665288,0.356087 0.8125,0.5 0.14725,0.14391 0.15625,0.21405 0.15625,0.21875 0,0.0047 -0.009,0.04359 -0.15625,0.1875 -0.147212,0.143913 -0.416001,0.343722 -0.8125,0.53125 -0.09755,0.04613 -0.233314,0.07889 -0.34375,0.125 0.06214,-0.546289 0.09144,-1.094215 0.09375,-1.65625 z m -29.5,3.625 c 0.479308,0.123125 0.983064,0.234089 1.53125,0.34375 2.301781,0.460458 5.229421,0.787224 8.46875,0.9375 0.167006,2.84339 0.46081,5.433176 0.875,7.5 0.115218,0.574942 0.245268,1.063612 0.375,1.5625 -5.463677,-1.028179 -9.833074,-5.091831 -11.25,-10.34375 z m 27.96875,0 C 85.247546,81.408945 80.919274,85.442932 75.5,86.5 c 0.126981,-0.490925 0.261959,-0.967174 0.375,-1.53125 0.41419,-2.066824 0.707994,-4.65661 0.875,-7.5 3.204493,-0.15162 6.088346,-0.480068 8.375,-0.9375 0.548186,-0.109661 1.051942,-0.220625 1.53125,-0.34375 z M 70.0625,77.53125 c 0.865391,0.02589 1.723666,0.03125 2.625,0.03125 0.912062,0 1.782843,-0.0048 2.65625,-0.03125 -0.165173,2.736408 -0.453252,5.207651 -0.84375,7.15625 -0.152345,0.760206 -0.322989,1.438994 -0.5,2.03125 -0.437447,0.03919 -0.895856,0.0625 -1.34375,0.0625 -0.414943,0 -0.812719,-0.02881 -1.21875,-0.0625 -0.177011,-0.592256 -0.347655,-1.271044 -0.5,-2.03125 -0.390498,-1.948599 -0.700644,-4.419842 -0.875,-7.15625 z m 1.75,10.28125 c 0.284911,0.01545 0.554954,0.03125 0.84375,0.03125 0.325029,0 0.648588,-0.01171 0.96875,-0.03125 -0.05999,0.148763 -0.127309,0.31046 -0.1875,0.4375 -0.18789,0.396562 -0.386962,0.696416 -0.53125,0.84375 -0.144288,0.147334 -0.181857,0.125 -0.1875,0.125 -0.0056,0 -0.07446,0.02233 -0.21875,-0.125 C 72.355712,88.946416 72.18789,88.646562 72,88.25 71.939809,88.12296 71.872486,87.961263 71.8125,87.8125 z';\n/* harmony default export */ const svgPaths_svgCompassGyro = (svgCompassGyro);\n;// CONCATENATED MODULE: ./svgPaths/svgCompassRotationMarker.js\nvar svgCompassRotationMarker = 'M 72.46875,22.03125 C 59.505873,22.050338 46.521615,27.004287 36.6875,36.875 L 47.84375,47.96875 C 61.521556,34.240041 83.442603,34.227389 97.125,47.90625 l 11.125,-11.125 C 98.401629,26.935424 85.431627,22.012162 72.46875,22.03125 z';\n/* harmony default export */ const svgPaths_svgCompassRotationMarker = (svgCompassRotationMarker);\n;// CONCATENATED MODULE: ./viewModels/NavigationViewModel.js\n\n\n\n\n\n\n\n\n// var CesiumMath = Math;\nvar NavigationViewModel_Knockout = ThirdParty_knockout;\nvar NavigationViewModel = function NavigationViewModel(options) {\n  this.terria = options.terria;\n  this.eventHelper = new Core_EventHelper();\n  this.enableZoomControls = Core_defined(options.enableZoomControls) ? options.enableZoomControls : true;\n  this.enableCompass = Core_defined(options.enableCompass) ? options.enableCompass : true;\n  this.navigationLocked = false;\n\n  // if (this.showZoomControls)\n  //   {\n  this.controls = options.controls;\n  if (!Core_defined(this.controls)) {\n    this.controls = [new viewModels_ZoomNavigationControl(this.terria, true), new viewModels_ResetViewNavigationControl(this.terria), new viewModels_ZoomNavigationControl(this.terria, false)];\n  }\n  // }\n\n  this.svgCompassOuterRing = svgPaths_svgCompassOuterRing;\n  this.svgCompassGyro = svgPaths_svgCompassGyro;\n  this.svgCompassRotationMarker = svgPaths_svgCompassRotationMarker;\n  this.showCompass = Core_defined(this.terria) && this.enableCompass;\n  this.heading = this.showCompass ? this.terria.scene.camera.heading : 0.0;\n  this.isOrbiting = false;\n  this.orbitCursorAngle = 0;\n  this.orbitCursorOpacity = 0.0;\n  this.orbitLastTimestamp = 0;\n  this.orbitFrame = undefined;\n  this.orbitIsLook = false;\n  this.orbitMouseMoveFunction = undefined;\n  this.orbitMouseUpFunction = undefined;\n  this.isRotating = false;\n  this.rotateInitialCursorAngle = undefined;\n  this.rotateFrame = undefined;\n  this.rotateIsLook = false;\n  this.rotateMouseMoveFunction = undefined;\n  this.rotateMouseUpFunction = undefined;\n  this._unsubcribeFromPostRender = undefined;\n  NavigationViewModel_Knockout.track(this, ['controls', 'showCompass', 'heading', 'isOrbiting', 'orbitCursorAngle', 'isRotating']);\n  var that = this;\n  NavigationViewModel.prototype.setNavigationLocked = function (locked) {\n    this.navigationLocked = locked;\n    if (this.controls && this.controls.length > 1) {\n      this.controls[1].setNavigationLocked(this.navigationLocked);\n    }\n  };\n  function widgetChange() {\n    if (Core_defined(that.terria)) {\n      if (that._unsubcribeFromPostRender) {\n        that._unsubcribeFromPostRender();\n        that._unsubcribeFromPostRender = undefined;\n      }\n      that.showCompass =  true && that.enableCompass;\n      that._unsubcribeFromPostRender = that.terria.scene.postRender.addEventListener(function () {\n        that.heading = that.terria.scene.camera.heading;\n      });\n    } else {\n      if (that._unsubcribeFromPostRender) {\n        that._unsubcribeFromPostRender();\n        that._unsubcribeFromPostRender = undefined;\n      }\n      that.showCompass = false;\n    }\n  }\n  this.eventHelper.add(this.terria.afterWidgetChanged, widgetChange, this);\n  // this.terria.afterWidgetChanged.addEventListener(widgetChange);\n\n  widgetChange();\n};\nNavigationViewModel.prototype.destroy = function () {\n  this.eventHelper.removeAll();\n\n  // loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);\n};\n\nNavigationViewModel.prototype.show = function (container) {\n  var testing;\n  if (this.enableZoomControls && this.enableCompass) {\n    testing = '<div class=\"compass\" title=\"\" data-bind=\"visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }\">' + '<div class=\"compass-outer-ring-background\"></div>' + ' <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: \\'rotate(-\\' + heading + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + heading + \\'rad)\\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-gyro-background\"></div>' + ' <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \\'compass-gyro-active\\': isOrbiting }\"></div>' + '</div>' + '<div class=\"navigation-controls\">' + '<!-- ko foreach: controls -->' + '<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \\'navigation-control-last\\' : \\'navigation-control\\' \">' + '   <!-- ko if: $data.hasText -->' + '   <div data-bind=\"text: $data.text, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '   <!-- /ko -->' + '  <!-- ko ifnot: $data.hasText -->' + '  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '  <!-- /ko -->' + ' </div>' + ' <!-- /ko -->' + '</div>';\n  } else if (!this.enableZoomControls && this.enableCompass) {\n    testing = '<div class=\"compass\" title=\"\" data-bind=\"visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }\">' + '<div class=\"compass-outer-ring-background\"></div>' + ' <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: \\'rotate(-\\' + heading + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + heading + \\'rad)\\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-gyro-background\"></div>' + ' <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \\'compass-gyro-active\\': isOrbiting }\"></div>' + '</div>' + '<div class=\"navigation-controls\"  style=\"display: none;\" >' + '<!-- ko foreach: controls -->' + '<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \\'navigation-control-last\\' : \\'navigation-control\\' \">' + '   <!-- ko if: $data.hasText -->' + '   <div data-bind=\"text: $data.text, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '   <!-- /ko -->' + '  <!-- ko ifnot: $data.hasText -->' + '  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '  <!-- /ko -->' + ' </div>' + ' <!-- /ko -->' + '</div>';\n  } else if (this.enableZoomControls && !this.enableCompass) {\n    testing = '<div class=\"compass\"  style=\"display: none;\" title=\"\" data-bind=\"visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }\">' + '<div class=\"compass-outer-ring-background\"></div>' + ' <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: \\'rotate(-\\' + heading + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + heading + \\'rad)\\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-gyro-background\"></div>' + ' <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \\'compass-gyro-active\\': isOrbiting }\"></div>' + '</div>' + '<div class=\"navigation-controls\"    >' + '<!-- ko foreach: controls -->' + '<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \\'navigation-control-last\\' : \\'navigation-control\\' \">' + '   <!-- ko if: $data.hasText -->' + '   <div data-bind=\"text: $data.text, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '   <!-- /ko -->' + '  <!-- ko ifnot: $data.hasText -->' + '  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '  <!-- /ko -->' + ' </div>' + ' <!-- /ko -->' + '</div>';\n  } else if (!this.enableZoomControls && !this.enableCompass) {\n    testing = '<div class=\"compass\"  style=\"display: none;\" title=\"\" data-bind=\"visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }\">' + '<div class=\"compass-outer-ring-background\"></div>' + ' <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + orbitCursorAngle + \\'rad)\\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: \\'rotate(-\\' + heading + \\'rad)\\', \\'-webkit-transform\\': \\'rotate(-\\' + heading + \\'rad)\\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>' + ' <div class=\"compass-gyro-background\"></div>' + ' <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \\'compass-gyro-active\\': isOrbiting }\"></div>' + '</div>' + '<div class=\"navigation-controls\"   style=\"display: none;\" >' + '<!-- ko foreach: controls -->' + '<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \\'navigation-control-last\\' : \\'navigation-control\\' \">' + '   <!-- ko if: $data.hasText -->' + '   <div data-bind=\"text: $data.text, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '   <!-- /ko -->' + '  <!-- ko ifnot: $data.hasText -->' + '  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \\'navigation-control-icon-active \\' + $data.cssClass : $data.cssClass\"></div>' + '  <!-- /ko -->' + ' </div>' + ' <!-- /ko -->' + '</div>';\n  }\n  core_loadView(testing, container, this);\n  // loadView(navigatorTemplate, container, this);\n  // loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);\n};\n\n/**\n * Adds a control to this toolbar.\n * @param {NavControl} control The control to add.\n */\nNavigationViewModel.prototype.add = function (control) {\n  this.controls.push(control);\n};\n\n/**\n * Removes a control from this toolbar.\n * @param {NavControl} control The control to remove.\n */\nNavigationViewModel.prototype.remove = function (control) {\n  this.controls.remove(control);\n};\n\n/**\n * Checks if the control given is the last control in the control array.\n * @param {NavControl} control The control to remove.\n */\nNavigationViewModel.prototype.isLastControl = function (control) {\n  return control === this.controls[this.controls.length - 1];\n};\nvar vectorScratch = new Core_Cartesian2();\nNavigationViewModel.prototype.handleMouseDown = function (viewModel, e) {\n  var scene = this.terria.scene;\n  if (scene.mode === Scene_SceneMode.MORPHING) {\n    return true;\n  }\n  if (viewModel.navigationLocked) {\n    return true;\n  }\n  var compassElement = e.currentTarget;\n  var compassRectangle = e.currentTarget.getBoundingClientRect();\n  var maxDistance = compassRectangle.width / 2.0;\n  var center = new Core_Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);\n  var clickLocation = new Core_Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);\n  var vector = Core_Cartesian2.subtract(clickLocation, center, vectorScratch);\n  var distanceFromCenter = Core_Cartesian2.magnitude(vector);\n  var distanceFraction = distanceFromCenter / maxDistance;\n  var nominalTotalRadius = 145;\n  var norminalGyroRadius = 50;\n  if (distanceFraction < norminalGyroRadius / nominalTotalRadius) {\n    orbit(this, compassElement, vector);\n    //            return false;\n  } else if (distanceFraction < 1.0) {\n    rotate(this, compassElement, vector);\n    //            return false;\n  } else {\n    return true;\n  }\n};\nvar oldTransformScratch = new Core_Matrix4();\nvar newTransformScratch = new Core_Matrix4();\nvar NavigationViewModel_centerScratch = new Core_Cartesian3();\nNavigationViewModel.prototype.handleDoubleClick = function (viewModel, e) {\n  var scene = viewModel.terria.scene;\n  var camera = scene.camera;\n  var sscc = scene.screenSpaceCameraController;\n  if (scene.mode === Scene_SceneMode.MORPHING || !sscc.enableInputs) {\n    return true;\n  }\n  if (viewModel.navigationLocked) {\n    return true;\n  }\n  if (scene.mode === Scene_SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {\n    return;\n  }\n  if (scene.mode === Scene_SceneMode.SCENE3D || scene.mode === Scene_SceneMode.COLUMBUS_VIEW) {\n    if (!sscc.enableLook) {\n      return;\n    }\n    if (scene.mode === Scene_SceneMode.SCENE3D) {\n      if (!sscc.enableRotate) {\n        return;\n      }\n    }\n  }\n  var center = core_Utils.getCameraFocus(viewModel.terria, true, NavigationViewModel_centerScratch);\n  if (!Core_defined(center)) {\n    // Globe is barely visible, so reset to home view.\n\n    this.controls[1].resetView();\n    return;\n  }\n  var cameraPosition = scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic, new Core_Cartesian3());\n  var surfaceNormal = scene.globe.ellipsoid.geodeticSurfaceNormal(center);\n  var focusBoundingSphere = new Core_BoundingSphere(center, 0);\n  camera.flyToBoundingSphere(focusBoundingSphere, {\n    offset: new Core_HeadingPitchRange(0,\n    // do not use camera.pitch since the pitch at the center/target is required\n    Core_Math.PI_OVER_TWO - Core_Cartesian3.angleBetween(surfaceNormal, camera.directionWC),\n    // distanceToBoundingSphere returns wrong values when in 2D or Columbus view so do not use\n    // camera.distanceToBoundingSphere(focusBoundingSphere)\n    // instead calculate distance manually\n    Core_Cartesian3.distance(cameraPosition, center)),\n    duration: 1.5\n  });\n};\nNavigationViewModel.create = function (options) {\n  // options.enableZoomControls = this.enableZoomControls;\n  // options.enableCompass = this.enableCompass;\n  var result = new NavigationViewModel(options);\n  result.show(options.container);\n  return result;\n};\nfunction orbit(viewModel, compassElement, cursorVector) {\n  var scene = viewModel.terria.scene;\n  var sscc = scene.screenSpaceCameraController;\n\n  // do not orbit if it is disabled\n  if (scene.mode === Scene_SceneMode.MORPHING || !sscc.enableInputs) {\n    return;\n  }\n  if (viewModel.navigationLocked) {\n    return true;\n  }\n  switch (scene.mode) {\n    case Scene_SceneMode.COLUMBUS_VIEW:\n      if (sscc.enableLook) {\n        break;\n      }\n      if (!sscc.enableTranslate || !sscc.enableTilt) {\n        return;\n      }\n      break;\n    case Scene_SceneMode.SCENE3D:\n      if (sscc.enableLook) {\n        break;\n      }\n      if (!sscc.enableTilt || !sscc.enableRotate) {\n        return;\n      }\n      break;\n    case Scene_SceneMode.SCENE2D:\n      if (!sscc.enableTranslate) {\n        return;\n      }\n      break;\n  }\n\n  // Remove existing event handlers, if any.\n  document.removeEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);\n  document.removeEventListener('mouseup', viewModel.orbitMouseUpFunction, false);\n  if (Core_defined(viewModel.orbitTickFunction)) {\n    viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);\n  }\n  viewModel.orbitMouseMoveFunction = undefined;\n  viewModel.orbitMouseUpFunction = undefined;\n  viewModel.orbitTickFunction = undefined;\n  viewModel.isOrbiting = true;\n  viewModel.orbitLastTimestamp = Core_getTimestamp();\n  var camera = scene.camera;\n  if (Core_defined(viewModel.terria.trackedEntity)) {\n    // when tracking an entity simply use that reference frame\n    viewModel.orbitFrame = undefined;\n    viewModel.orbitIsLook = false;\n  } else {\n    var center = core_Utils.getCameraFocus(viewModel.terria, true, NavigationViewModel_centerScratch);\n    if (!Core_defined(center)) {\n      viewModel.orbitFrame = Core_Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);\n      viewModel.orbitIsLook = true;\n    } else {\n      viewModel.orbitFrame = Core_Transforms.eastNorthUpToFixedFrame(center, scene.globe.ellipsoid, newTransformScratch);\n      viewModel.orbitIsLook = false;\n    }\n  }\n  viewModel.orbitTickFunction = function (e) {\n    var timestamp = Core_getTimestamp();\n    var deltaT = timestamp - viewModel.orbitLastTimestamp;\n    var rate = (viewModel.orbitCursorOpacity - 0.5) * 2.5 / 1000;\n    var distance = deltaT * rate;\n    var angle = viewModel.orbitCursorAngle + Core_Math.PI_OVER_TWO;\n    var x = Math.cos(angle) * distance;\n    var y = Math.sin(angle) * distance;\n    var oldTransform;\n    if (viewModel.navigationLocked) {\n      return true;\n    }\n    if (Core_defined(viewModel.orbitFrame)) {\n      oldTransform = Core_Matrix4.clone(camera.transform, oldTransformScratch);\n      camera.lookAtTransform(viewModel.orbitFrame);\n    }\n\n    // do not look up/down or rotate in 2D mode\n    if (scene.mode === Scene_SceneMode.SCENE2D) {\n      camera.move(new Core_Cartesian3(x, y, 0), Math.max(scene.canvas.clientWidth, scene.canvas.clientHeight) / 100 * camera.positionCartographic.height * distance);\n    } else {\n      if (viewModel.orbitIsLook) {\n        camera.look(Core_Cartesian3.UNIT_Z, -x);\n        camera.look(camera.right, -y);\n      } else {\n        camera.rotateLeft(x);\n        camera.rotateUp(y);\n      }\n    }\n    if (Core_defined(viewModel.orbitFrame)) {\n      camera.lookAtTransform(oldTransform);\n    }\n\n    // viewModel.terria.cesium.notifyRepaintRequired();\n\n    viewModel.orbitLastTimestamp = timestamp;\n  };\n  function updateAngleAndOpacity(vector, compassWidth) {\n    var angle = Math.atan2(-vector.y, vector.x);\n    viewModel.orbitCursorAngle = Core_Math.zeroToTwoPi(angle - Core_Math.PI_OVER_TWO);\n    var distance = Core_Cartesian2.magnitude(vector);\n    var maxDistance = compassWidth / 2.0;\n    var distanceFraction = Math.min(distance / maxDistance, 1.0);\n    var easedOpacity = 0.5 * distanceFraction * distanceFraction + 0.5;\n    viewModel.orbitCursorOpacity = easedOpacity;\n\n    // viewModel.terria.cesium.notifyRepaintRequired();\n  }\n\n  viewModel.orbitMouseMoveFunction = function (e) {\n    var compassRectangle = compassElement.getBoundingClientRect();\n    var center = new Core_Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);\n    var clickLocation = new Core_Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);\n    var vector = Core_Cartesian2.subtract(clickLocation, center, vectorScratch);\n    updateAngleAndOpacity(vector, compassRectangle.width);\n  };\n  viewModel.orbitMouseUpFunction = function (e) {\n    // TODO: if mouse didn't move, reset view to looking down, north is up?\n\n    viewModel.isOrbiting = false;\n    document.removeEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);\n    document.removeEventListener('mouseup', viewModel.orbitMouseUpFunction, false);\n    if (Core_defined(viewModel.orbitTickFunction)) {\n      viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);\n    }\n    viewModel.orbitMouseMoveFunction = undefined;\n    viewModel.orbitMouseUpFunction = undefined;\n    viewModel.orbitTickFunction = undefined;\n  };\n  document.addEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);\n  document.addEventListener('mouseup', viewModel.orbitMouseUpFunction, false);\n  viewModel.terria.clock.onTick.addEventListener(viewModel.orbitTickFunction);\n  updateAngleAndOpacity(cursorVector, compassElement.getBoundingClientRect().width);\n}\nfunction rotate(viewModel, compassElement, cursorVector) {\n  var scene = viewModel.terria.scene;\n  var camera = scene.camera;\n  var sscc = scene.screenSpaceCameraController;\n  // do not rotate in 2D mode or if rotating is disabled\n  if (scene.mode === Scene_SceneMode.MORPHING || scene.mode === Scene_SceneMode.SCENE2D || !sscc.enableInputs) {\n    return;\n  }\n  if (viewModel.navigationLocked) {\n    return true;\n  }\n  if (!sscc.enableLook && (scene.mode === Scene_SceneMode.COLUMBUS_VIEW || scene.mode === Scene_SceneMode.SCENE3D && !sscc.enableRotate)) {\n    return;\n  }\n\n  // Remove existing event handlers, if any.\n  document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);\n  document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);\n  viewModel.rotateMouseMoveFunction = undefined;\n  viewModel.rotateMouseUpFunction = undefined;\n  viewModel.isRotating = true;\n  viewModel.rotateInitialCursorAngle = Math.atan2(-cursorVector.y, cursorVector.x);\n  if (Core_defined(viewModel.terria.trackedEntity)) {\n    // when tracking an entity simply use that reference frame\n    viewModel.rotateFrame = undefined;\n    viewModel.rotateIsLook = false;\n  } else {\n    var viewCenter = core_Utils.getCameraFocus(viewModel.terria, true, NavigationViewModel_centerScratch);\n    if (!Core_defined(viewCenter) || scene.mode === Scene_SceneMode.COLUMBUS_VIEW && !sscc.enableLook && !sscc.enableTranslate) {\n      viewModel.rotateFrame = Core_Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);\n      viewModel.rotateIsLook = true;\n    } else {\n      viewModel.rotateFrame = Core_Transforms.eastNorthUpToFixedFrame(viewCenter, scene.globe.ellipsoid, newTransformScratch);\n      viewModel.rotateIsLook = false;\n    }\n  }\n  var oldTransform;\n  if (Core_defined(viewModel.rotateFrame)) {\n    oldTransform = Core_Matrix4.clone(camera.transform, oldTransformScratch);\n    camera.lookAtTransform(viewModel.rotateFrame);\n  }\n  viewModel.rotateInitialCameraAngle = -camera.heading;\n  if (Core_defined(viewModel.rotateFrame)) {\n    camera.lookAtTransform(oldTransform);\n  }\n  viewModel.rotateMouseMoveFunction = function (e) {\n    var compassRectangle = compassElement.getBoundingClientRect();\n    var center = new Core_Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);\n    var clickLocation = new Core_Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);\n    var vector = Core_Cartesian2.subtract(clickLocation, center, vectorScratch);\n    var angle = Math.atan2(-vector.y, vector.x);\n    var angleDifference = angle - viewModel.rotateInitialCursorAngle;\n    var newCameraAngle = Core_Math.zeroToTwoPi(viewModel.rotateInitialCameraAngle - angleDifference);\n    var camera = viewModel.terria.scene.camera;\n    var oldTransform;\n    if (Core_defined(viewModel.rotateFrame)) {\n      oldTransform = Core_Matrix4.clone(camera.transform, oldTransformScratch);\n      camera.lookAtTransform(viewModel.rotateFrame);\n    }\n    var currentCameraAngle = -camera.heading;\n    camera.rotateRight(newCameraAngle - currentCameraAngle);\n    if (Core_defined(viewModel.rotateFrame)) {\n      camera.lookAtTransform(oldTransform);\n    }\n\n    // viewModel.terria.cesium.notifyRepaintRequired();\n  };\n\n  viewModel.rotateMouseUpFunction = function (e) {\n    viewModel.isRotating = false;\n    document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);\n    document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);\n    viewModel.rotateMouseMoveFunction = undefined;\n    viewModel.rotateMouseUpFunction = undefined;\n  };\n  document.addEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);\n  document.addEventListener('mouseup', viewModel.rotateMouseUpFunction, false);\n}\n/* harmony default export */ const viewModels_NavigationViewModel = (NavigationViewModel);\n;// CONCATENATED MODULE: ./CesiumNavigation.js\n/* eslint-disable no-unused-vars */\n\n\n\n\nvar CesiumEvent = Core_Event;\nvar CesiumNavigation_Knockout = ThirdParty_knockout;\n\n/**\r\n * @alias CesiumNavigation\r\n * @constructor\r\n *\r\n * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance\r\n */\nvar CesiumNavigation = function CesiumNavigation(viewerCesiumWidget) {\n  CesiumNavigation_initialize.apply(this, arguments);\n  this._onDestroyListeners = [];\n};\nCesiumNavigation.prototype.distanceLegendViewModel = undefined;\nCesiumNavigation.prototype.navigationViewModel = undefined;\nCesiumNavigation.prototype.navigationDiv = undefined;\nCesiumNavigation.prototype.distanceLegendDiv = undefined;\nCesiumNavigation.prototype.terria = undefined;\nCesiumNavigation.prototype.container = undefined;\nCesiumNavigation.prototype._onDestroyListeners = undefined;\nCesiumNavigation.prototype._navigationLocked = false;\nCesiumNavigation.prototype.setNavigationLocked = function (locked) {\n  this._navigationLocked = locked;\n  this.navigationViewModel.setNavigationLocked(this._navigationLocked);\n};\nCesiumNavigation.prototype.getNavigationLocked = function () {\n  return this._navigationLocked;\n};\nCesiumNavigation.prototype.destroy = function () {\n  if (Core_defined(this.navigationViewModel)) {\n    this.navigationViewModel.destroy();\n  }\n  if (Core_defined(this.distanceLegendViewModel)) {\n    this.distanceLegendViewModel.destroy();\n  }\n  if (Core_defined(this.navigationDiv)) {\n    this.navigationDiv.parentNode.removeChild(this.navigationDiv);\n  }\n  delete this.navigationDiv;\n  if (Core_defined(this.distanceLegendDiv)) {\n    this.distanceLegendDiv.parentNode.removeChild(this.distanceLegendDiv);\n  }\n  delete this.distanceLegendDiv;\n  if (Core_defined(this.container)) {\n    this.container.parentNode.removeChild(this.container);\n  }\n  delete this.container;\n  for (var i = 0; i < this._onDestroyListeners.length; i++) {\n    this._onDestroyListeners[i]();\n  }\n};\nCesiumNavigation.prototype.addOnDestroyListener = function (callback) {\n  if (typeof callback === 'function') {\n    this._onDestroyListeners.push(callback);\n  }\n};\n\n/**\r\n * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance\r\n * @param options\r\n */\nfunction CesiumNavigation_initialize(viewerCesiumWidget, options) {\n  if (!Core_defined(viewerCesiumWidget)) {\n    throw new Core_DeveloperError('CesiumWidget or Viewer is required.');\n  }\n\n  //        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var cesiumWidget = Core_defined(viewerCesiumWidget.cesiumWidget) ? viewerCesiumWidget.cesiumWidget : viewerCesiumWidget;\n  var container = document.createElement('div');\n  container.className = 'cesium-widget-cesiumNavigationContainer';\n  cesiumWidget.container.appendChild(container);\n  this.terria = viewerCesiumWidget;\n  this.terria.options = Core_defined(options) ? options : {};\n  this.terria.afterWidgetChanged = new CesiumEvent();\n  this.terria.beforeWidgetChanged = new CesiumEvent();\n  this.container = container;\n\n  // this.navigationDiv.setAttribute(\"id\", \"navigationDiv\");\n\n  // Register custom Knockout.js bindings.  If you're not using the TerriaJS user interface, you can remove this.\n  core_registerKnockoutBindings();\n  if (!Core_defined(this.terria.options.enableDistanceLegend) || this.terria.options.enableDistanceLegend) {\n    this.distanceLegendDiv = document.createElement('div');\n    container.appendChild(this.distanceLegendDiv);\n    this.distanceLegendDiv.setAttribute('id', 'distanceLegendDiv');\n    this.distanceLegendViewModel = viewModels_DistanceLegendViewModel.create({\n      container: this.distanceLegendDiv,\n      terria: this.terria,\n      mapElement: container,\n      enableDistanceLegend: true\n    });\n  }\n  if ((!Core_defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) && (!Core_defined(this.terria.options.enableCompass) || this.terria.options.enableCompass)) {\n    this.navigationDiv = document.createElement('div');\n    this.navigationDiv.setAttribute('id', 'navigationDiv');\n    container.appendChild(this.navigationDiv);\n    // Create the navigation controls.\n    this.navigationViewModel = viewModels_NavigationViewModel.create({\n      container: this.navigationDiv,\n      terria: this.terria,\n      enableZoomControls: true,\n      enableCompass: true\n    });\n  } else if (Core_defined(this.terria.options.enableZoomControls) && !this.terria.options.enableZoomControls && (!Core_defined(this.terria.options.enableCompass) || this.terria.options.enableCompass)) {\n    this.navigationDiv = document.createElement('div');\n    this.navigationDiv.setAttribute('id', 'navigationDiv');\n    container.appendChild(this.navigationDiv);\n    // Create the navigation controls.\n    this.navigationViewModel = viewModels_NavigationViewModel.create({\n      container: this.navigationDiv,\n      terria: this.terria,\n      enableZoomControls: false,\n      enableCompass: true\n    });\n  } else if ((!Core_defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) && Core_defined(this.terria.options.enableCompass) && !this.terria.options.enableCompass) {\n    this.navigationDiv = document.createElement('div');\n    this.navigationDiv.setAttribute('id', 'navigationDiv');\n    container.appendChild(this.navigationDiv);\n    // Create the navigation controls.\n    this.navigationViewModel = viewModels_NavigationViewModel.create({\n      container: this.navigationDiv,\n      terria: this.terria,\n      enableZoomControls: true,\n      enableCompass: false\n    });\n  } else if (Core_defined(this.terria.options.enableZoomControls) && !this.terria.options.enableZoomControls && Core_defined(this.terria.options.enableCompass) && !this.terria.options.enableCompass) {\n    // this.navigationDiv.setAttribute(\"id\", \"navigationDiv\");\n    // container.appendChild(this.navigationDiv);\n    // Create the navigation controls.\n    //            this.navigationViewModel = NavigationViewModel.create({\n    //                container: this.navigationDiv,\n    //                terria: this.terria,\n    //                enableZoomControls: false,\n    //                enableCompass: false\n    //            });\n  }\n}\n/* harmony default export */ const CesiumNavigation_0 = (CesiumNavigation);\n;// CONCATENATED MODULE: ./styles/cesium-navigation.css\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./viewerCesiumNavigationMixin.js\n\n\n\n\n/**\r\n * A mixin which adds the Compass/Navigation widget to the Viewer widget.\r\n * Rather than being called directly, this function is normally passed as\r\n * a parameter to {@link Viewer#extend}, as shown in the example below.\r\n * @exports viewerCesiumNavigationMixin\r\n *\r\n * @param {Viewer} viewer The viewer instance.\r\n * @param {{}} options The options.\r\n *\r\n * @exception {DeveloperError} viewer is required.\r\n *\r\n * @demo {@link http://localhost:8080/index.html|run local server with examples}\r\n *\r\n * @example\r\n * var viewer = new Cesium.Viewer('cesiumContainer');\r\n * viewer.extend(viewerCesiumNavigationMixin);\r\n */\nfunction viewerCesiumNavigationMixin(viewer, options) {\n  if (!Core_defined(viewer)) {\n    throw new Core_DeveloperError('viewer is required.');\n  }\n  var cesiumNavigation = init(viewer, options);\n  cesiumNavigation.addOnDestroyListener(function (viewer) {\n    return function () {\n      delete viewer.cesiumNavigation;\n    };\n  }(viewer));\n  Object.defineProperties(viewer, {\n    cesiumNavigation: {\n      configurable: true,\n      get: function get() {\n        return viewer.cesiumWidget.cesiumNavigation;\n      }\n    }\n  });\n}\n\n/**\r\n *\r\n * @param {CesiumWidget} cesiumWidget The cesium widget instance.\r\n * @param {{}} options The options.\r\n */\nviewerCesiumNavigationMixin.mixinWidget = function (cesiumWidget, options) {\n  return init.apply(undefined, arguments);\n};\n\n/**\r\n * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance\r\n * @param {{}} options the options\r\n */\nvar init = function init(viewerCesiumWidget, options) {\n  var cesiumNavigation = new CesiumNavigation_0(viewerCesiumWidget, options);\n  var cesiumWidget = Core_defined(viewerCesiumWidget.cesiumWidget) ? viewerCesiumWidget.cesiumWidget : viewerCesiumWidget;\n  Object.defineProperties(cesiumWidget, {\n    cesiumNavigation: {\n      configurable: true,\n      get: function get() {\n        return cesiumNavigation;\n      }\n    }\n  });\n  cesiumNavigation.addOnDestroyListener(function (cesiumWidget) {\n    return function () {\n      delete cesiumWidget.cesiumNavigation;\n    };\n  }(cesiumWidget));\n  return cesiumNavigation;\n};\n/* harmony default export */ const viewerCesiumNavigationMixin_0 = (viewerCesiumNavigationMixin);\n\n//# sourceURL=webpack://cesium-navigation-es6/./viewerCesiumNavigationMixin.js_+_104_modules?");

/***/ }),

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n})(window, document, 'Hammer');\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/hammerjs/hammer.js?");

/***/ }),

/***/ "./node_modules/linkify-it/index.js":
/*!******************************************!*\
  !*** ./node_modules/linkify-it/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Helpers\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\nfunction isString(obj) { return _class(obj) === '[object String]'; }\nfunction isObject(obj) { return _class(obj) === '[object Object]'; }\nfunction isRegExp(obj) { return _class(obj) === '[object RegExp]'; }\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\n\n\nfunction escapeRE(str) { return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&'); }\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar defaultOptions = {\n  fuzzyLink: true,\n  fuzzyEmail: true,\n  fuzzyIP: false\n};\n\n\nfunction isOptionsObj(obj) {\n  return Object.keys(obj || {}).reduce(function (acc, k) {\n    return acc || defaultOptions.hasOwnProperty(k);\n  }, false);\n}\n\n\nvar defaultSchemas = {\n  'http:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.http) {\n        // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.http =  new RegExp(\n          '^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\n        );\n      }\n      if (self.re.http.test(tail)) {\n        return tail.match(self.re.http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'https:':  'http:',\n  'ftp:':    'http:',\n  '//':      {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.no_http) {\n      // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.no_http =  new RegExp(\n          '^' +\n          self.re.src_auth +\n          // Don't allow single-level domains, because of false positives like '//test'\n          // with code comments\n          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\\\.)+' + self.re.src_domain_root + ')' +\n          self.re.src_port +\n          self.re.src_host_terminator +\n          self.re.src_path,\n\n          'i'\n        );\n      }\n\n      if (self.re.no_http.test(tail)) {\n        // should not be `://` & `///`, that protects from errors in protocol name\n        if (pos >= 3 && text[pos - 3] === ':') { return 0; }\n        if (pos >= 3 && text[pos - 3] === '/') { return 0; }\n        return tail.match(self.re.no_http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'mailto:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.mailto) {\n        self.re.mailto =  new RegExp(\n          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'\n        );\n      }\n      if (self.re.mailto.test(tail)) {\n        return tail.match(self.re.mailto)[0].length;\n      }\n      return 0;\n    }\n  }\n};\n\n/*eslint-disable max-len*/\n\n// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\nvar tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';\n\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\nvar tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');\n\n/*eslint-enable max-len*/\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction resetScanCache(self) {\n  self.__index__ = -1;\n  self.__text_cache__   = '';\n}\n\nfunction createValidator(re) {\n  return function (text, pos) {\n    var tail = text.slice(pos);\n\n    if (re.test(tail)) {\n      return tail.match(re)[0].length;\n    }\n    return 0;\n  };\n}\n\nfunction createNormalizer() {\n  return function (match, self) {\n    self.normalize(match);\n  };\n}\n\n// Schemas compiler. Build regexps.\n//\nfunction compile(self) {\n\n  // Load & clone RE patterns.\n  var re = self.re = __webpack_require__(/*! ./lib/re */ \"./node_modules/linkify-it/lib/re.js\")(self.__opts__);\n\n  // Define dynamic patterns\n  var tlds = self.__tlds__.slice();\n\n  self.onCompile();\n\n  if (!self.__tlds_replaced__) {\n    tlds.push(tlds_2ch_src_re);\n  }\n  tlds.push(re.src_xn);\n\n  re.src_tlds = tlds.join('|');\n\n  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }\n\n  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');\n  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');\n  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');\n  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');\n\n  //\n  // Compile each schema\n  //\n\n  var aliases = [];\n\n  self.__compiled__ = {}; // Reset compiled data\n\n  function schemaError(name, val) {\n    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n  }\n\n  Object.keys(self.__schemas__).forEach(function (name) {\n    var val = self.__schemas__[name];\n\n    // skip disabled methods\n    if (val === null) { return; }\n\n    var compiled = { validate: null, link: null };\n\n    self.__compiled__[name] = compiled;\n\n    if (isObject(val)) {\n      if (isRegExp(val.validate)) {\n        compiled.validate = createValidator(val.validate);\n      } else if (isFunction(val.validate)) {\n        compiled.validate = val.validate;\n      } else {\n        schemaError(name, val);\n      }\n\n      if (isFunction(val.normalize)) {\n        compiled.normalize = val.normalize;\n      } else if (!val.normalize) {\n        compiled.normalize = createNormalizer();\n      } else {\n        schemaError(name, val);\n      }\n\n      return;\n    }\n\n    if (isString(val)) {\n      aliases.push(name);\n      return;\n    }\n\n    schemaError(name, val);\n  });\n\n  //\n  // Compile postponed aliases\n  //\n\n  aliases.forEach(function (alias) {\n    if (!self.__compiled__[self.__schemas__[alias]]) {\n      // Silently fail on missed schemas to avoid errons on disable.\n      // schemaError(alias, self.__schemas__[alias]);\n      return;\n    }\n\n    self.__compiled__[alias].validate =\n      self.__compiled__[self.__schemas__[alias]].validate;\n    self.__compiled__[alias].normalize =\n      self.__compiled__[self.__schemas__[alias]].normalize;\n  });\n\n  //\n  // Fake record for guessed links\n  //\n  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };\n\n  //\n  // Build schema condition\n  //\n  var slist = Object.keys(self.__compiled__)\n                      .filter(function (name) {\n                        // Filter disabled & fake schemas\n                        return name.length > 0 && self.__compiled__[name];\n                      })\n                      .map(escapeRE)\n                      .join('|');\n  // (?!_) cause 1.5x slowdown\n  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');\n  self.re.schema_search = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');\n\n  self.re.pretest = RegExp(\n    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',\n    'i'\n  );\n\n  //\n  // Cleanup\n  //\n\n  resetScanCache(self);\n}\n\n/**\n * class Match\n *\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\n **/\nfunction Match(self, shift) {\n  var start = self.__index__,\n      end   = self.__last_index__,\n      text  = self.__text_cache__.slice(start, end);\n\n  /**\n   * Match#schema -> String\n   *\n   * Prefix (protocol) for matched string.\n   **/\n  this.schema    = self.__schema__.toLowerCase();\n  /**\n   * Match#index -> Number\n   *\n   * First position of matched string.\n   **/\n  this.index     = start + shift;\n  /**\n   * Match#lastIndex -> Number\n   *\n   * Next position after matched string.\n   **/\n  this.lastIndex = end + shift;\n  /**\n   * Match#raw -> String\n   *\n   * Matched string.\n   **/\n  this.raw       = text;\n  /**\n   * Match#text -> String\n   *\n   * Notmalized text of matched string.\n   **/\n  this.text      = text;\n  /**\n   * Match#url -> String\n   *\n   * Normalized url of matched string.\n   **/\n  this.url       = text;\n}\n\nfunction createMatch(self, shift) {\n  var match = new Match(self, shift);\n\n  self.__compiled__[match.schema].normalize(match, self);\n\n  return match;\n}\n\n\n/**\n * class LinkifyIt\n **/\n\n/**\n * new LinkifyIt(schemas, options)\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Creates new linkifier instance with optional additional schemas.\n * Can be called without `new` keyword for convenience.\n *\n * By default understands:\n *\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n *\n * `schemas` is an object, where each key/value describes protocol/rule:\n *\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n * - __value__ - rule to check tail after link prefix\n *   - _String_ - just alias to existing rule\n *   - _Object_\n *     - _validate_ - validator function (should return matched length on success),\n *       or `RegExp`.\n *     - _normalize_ - optional function to normalize text & url of matched result\n *       (for example, for @twitter mentions).\n *\n * `options`:\n *\n * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n *   like version numbers. Default `false`.\n * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n *\n **/\nfunction LinkifyIt(schemas, options) {\n  if (!(this instanceof LinkifyIt)) {\n    return new LinkifyIt(schemas, options);\n  }\n\n  if (!options) {\n    if (isOptionsObj(schemas)) {\n      options = schemas;\n      schemas = {};\n    }\n  }\n\n  this.__opts__           = assign({}, defaultOptions, options);\n\n  // Cache last tested result. Used to skip repeating steps on next `match` call.\n  this.__index__          = -1;\n  this.__last_index__     = -1; // Next scan position\n  this.__schema__         = '';\n  this.__text_cache__     = '';\n\n  this.__schemas__        = assign({}, defaultSchemas, schemas);\n  this.__compiled__       = {};\n\n  this.__tlds__           = tlds_default;\n  this.__tlds_replaced__  = false;\n\n  this.re = {};\n\n  compile(this);\n}\n\n\n/** chainable\n * LinkifyIt#add(schema, definition)\n * - schema (String): rule name (fixed pattern prefix)\n * - definition (String|RegExp|Object): schema definition\n *\n * Add new rule definition. See constructor description for details.\n **/\nLinkifyIt.prototype.add = function add(schema, definition) {\n  this.__schemas__[schema] = definition;\n  compile(this);\n  return this;\n};\n\n\n/** chainable\n * LinkifyIt#set(options)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Set recognition options for links without schema.\n **/\nLinkifyIt.prototype.set = function set(options) {\n  this.__opts__ = assign(this.__opts__, options);\n  return this;\n};\n\n\n/**\n * LinkifyIt#test(text) -> Boolean\n *\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n **/\nLinkifyIt.prototype.test = function test(text) {\n  // Reset scan cache\n  this.__text_cache__ = text;\n  this.__index__      = -1;\n\n  if (!text.length) { return false; }\n\n  var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n\n  // try to scan for link with schema - that's the most simple rule\n  if (this.re.schema_test.test(text)) {\n    re = this.re.schema_search;\n    re.lastIndex = 0;\n    while ((m = re.exec(text)) !== null) {\n      len = this.testSchemaAt(text, m[2], re.lastIndex);\n      if (len) {\n        this.__schema__     = m[2];\n        this.__index__      = m.index + m[1].length;\n        this.__last_index__ = m.index + m[0].length + len;\n        break;\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {\n    // guess schemaless links\n    tld_pos = text.search(this.re.host_fuzzy_test);\n    if (tld_pos >= 0) {\n      // if tld is located after found link - no need to check fuzzy pattern\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\n        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n\n          shift = ml.index + ml[1].length;\n\n          if (this.__index__ < 0 || shift < this.__index__) {\n            this.__schema__     = '';\n            this.__index__      = shift;\n            this.__last_index__ = ml.index + ml[0].length;\n          }\n        }\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {\n    // guess schemaless emails\n    at_pos = text.indexOf('@');\n    if (at_pos >= 0) {\n      // We can't skip this check, because this cases are possible:\n      // 192.168.1.1@gmail.com, my.in@example.com\n      if ((me = text.match(this.re.email_fuzzy)) !== null) {\n\n        shift = me.index + me[1].length;\n        next  = me.index + me[0].length;\n\n        if (this.__index__ < 0 || shift < this.__index__ ||\n            (shift === this.__index__ && next > this.__last_index__)) {\n          this.__schema__     = 'mailto:';\n          this.__index__      = shift;\n          this.__last_index__ = next;\n        }\n      }\n    }\n  }\n\n  return this.__index__ >= 0;\n};\n\n\n/**\n * LinkifyIt#pretest(text) -> Boolean\n *\n * Very quick check, that can give false positives. Returns true if link MAY BE\n * can exists. Can be used for speed optimization, when you need to check that\n * link NOT exists.\n **/\nLinkifyIt.prototype.pretest = function pretest(text) {\n  return this.re.pretest.test(text);\n};\n\n\n/**\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\n * - text (String): text to scan\n * - name (String): rule (schema) name\n * - position (Number): text offset to check from\n *\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n * at given position. Returns length of found pattern (0 on fail).\n **/\nLinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n  // If not supported schema check requested - terminate\n  if (!this.__compiled__[schema.toLowerCase()]) {\n    return 0;\n  }\n  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n};\n\n\n/**\n * LinkifyIt#match(text) -> Array|null\n *\n * Returns array of found link descriptions or `null` on fail. We strongly\n * recommend to use [[LinkifyIt#test]] first, for best speed.\n *\n * ##### Result match description\n *\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n *   protocol-neutral  links.\n * - __index__ - offset of matched text\n * - __lastIndex__ - index of next char after mathch end\n * - __raw__ - matched text\n * - __text__ - normalized text\n * - __url__ - link, generated from matched text\n **/\nLinkifyIt.prototype.match = function match(text) {\n  var shift = 0, result = [];\n\n  // Try to take previous element from cache, if .test() called before\n  if (this.__index__ >= 0 && this.__text_cache__ === text) {\n    result.push(createMatch(this, shift));\n    shift = this.__last_index__;\n  }\n\n  // Cut head if cache was used\n  var tail = shift ? text.slice(shift) : text;\n\n  // Scan string until end reached\n  while (this.test(tail)) {\n    result.push(createMatch(this, shift));\n\n    tail = tail.slice(this.__last_index__);\n    shift += this.__last_index__;\n  }\n\n  if (result.length) {\n    return result;\n  }\n\n  return null;\n};\n\n\n/** chainable\n * LinkifyIt#tlds(list [, keepOld]) -> this\n * - list (Array): list of tlds\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n *\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n * to avoid false positives. By default this algorythm used:\n *\n * - hostname with any 2-letter root zones are ok.\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф\n *   are ok.\n * - encoded (`xn--...`) root zones are ok.\n *\n * If list is replaced, then exact match for 2-chars root zones will be checked.\n **/\nLinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n  list = Array.isArray(list) ? list : [ list ];\n\n  if (!keepOld) {\n    this.__tlds__ = list.slice();\n    this.__tlds_replaced__ = true;\n    compile(this);\n    return this;\n  }\n\n  this.__tlds__ = this.__tlds__.concat(list)\n                                  .sort()\n                                  .filter(function (el, idx, arr) {\n                                    return el !== arr[idx - 1];\n                                  })\n                                  .reverse();\n\n  compile(this);\n  return this;\n};\n\n/**\n * LinkifyIt#normalize(match)\n *\n * Default normalizer (if schema does not define it's own).\n **/\nLinkifyIt.prototype.normalize = function normalize(match) {\n\n  // Do minimal possible changes by default. Need to collect feedback prior\n  // to move forward https://github.com/markdown-it/linkify-it/issues/1\n\n  if (!match.schema) { match.url = 'http://' + match.url; }\n\n  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\n    match.url = 'mailto:' + match.url;\n  }\n};\n\n\n/**\n * LinkifyIt#onCompile()\n *\n * Override to modify basic RegExp-s.\n **/\nLinkifyIt.prototype.onCompile = function onCompile() {\n};\n\n\nmodule.exports = LinkifyIt;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/linkify-it/index.js?");

/***/ }),

/***/ "./node_modules/linkify-it/lib/re.js":
/*!*******************************************!*\
  !*** ./node_modules/linkify-it/lib/re.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nmodule.exports = function (opts) {\n  var re = {};\n\n  // Use direct extract instead of `regenerate` to reduse browserified size\n  re.src_Any = (__webpack_require__(/*! uc.micro/properties/Any/regex */ \"./node_modules/uc.micro/properties/Any/regex.js\").source);\n  re.src_Cc  = (__webpack_require__(/*! uc.micro/categories/Cc/regex */ \"./node_modules/uc.micro/categories/Cc/regex.js\").source);\n  re.src_Z   = (__webpack_require__(/*! uc.micro/categories/Z/regex */ \"./node_modules/uc.micro/categories/Z/regex.js\").source);\n  re.src_P   = (__webpack_require__(/*! uc.micro/categories/P/regex */ \"./node_modules/uc.micro/categories/P/regex.js\").source);\n\n  // \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');\n\n  // \\p{\\Z\\Cc} (white spaces + control)\n  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');\n\n  // Experimental. List of chars, completely prohibited in links\n  // because can separate it from other part of text\n  var text_separators = '[><\\uff5c]';\n\n  // All possible word characters (everything without punctuation, spaces & controls)\n  // Defined via punctuation & spaces to save space\n  // Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';\n  // The same as abothe but without [0-9]\n  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  re.src_ip4 =\n\n    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';\n\n  // Prohibit any of \"@/[]()\" in user/pass to avoid wrong domain fetch.\n  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\\\[\\\\]()]).)+@)?';\n\n  re.src_port =\n\n    '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?';\n\n  re.src_host_terminator =\n\n    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|' + re.src_ZPCc + '))';\n\n  re.src_path =\n\n    '(?:' +\n      '[/?#]' +\n        '(?:' +\n          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\\\]{}.,\"\\'?!\\\\-]).|' +\n          '\\\\[(?:(?!' + re.src_ZCc + '|\\\\]).)*\\\\]|' +\n          '\\\\((?:(?!' + re.src_ZCc + '|[)]).)*\\\\)|' +\n          '\\\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\\\}|' +\n          '\\\\\"(?:(?!' + re.src_ZCc + '|[\"]).)+\\\\\"|' +\n          \"\\\\'(?:(?!\" + re.src_ZCc + \"|[']).)+\\\\'|\" +\n          \"\\\\'(?=\" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found\n          '\\\\.{2,4}[a-zA-Z0-9%/]|' + // github has ... in commit range links,\n                                     // google has .... in links (issue #66)\n                                     // Restrict to\n                                     // - english\n                                     // - percent-encoded\n                                     // - parts of file path\n                                     // until more examples found.\n          '\\\\.(?!' + re.src_ZCc + '|[.]).|' +\n          (opts && opts['---'] ?\n            '\\\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate\n            :\n            '\\\\-+|'\n          ) +\n          '\\\\,(?!' + re.src_ZCc + ').|' +      // allow `,,,` in paths\n          '\\\\!(?!' + re.src_ZCc + '|[!]).|' +\n          '\\\\?(?!' + re.src_ZCc + '|[?]).' +\n        ')+' +\n      '|\\\\/' +\n    ')?';\n\n  // Allow anything in markdown spec, forbid quote (\") at the first position\n  // because emails enclosed in quotes are far more common\n  re.src_email_name =\n\n    '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n\n  re.src_xn =\n\n    'xn--[a-z0-9\\\\-]{1,59}';\n\n  // More to read about domain names\n  // http://serverfault.com/questions/638260/\n\n  re.src_domain_root =\n\n    // Allow letters & digits (http://test1)\n    '(?:' +\n      re.src_xn +\n      '|' +\n      re.src_pseudo_letter + '{1,63}' +\n    ')';\n\n  re.src_domain =\n\n    '(?:' +\n      re.src_xn +\n      '|' +\n      '(?:' + re.src_pseudo_letter + ')' +\n      '|' +\n      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +\n    ')';\n\n  re.src_host =\n\n    '(?:' +\n    // Don't need IP check, because digits are already allowed in normal domain names\n    //   src_ip4 +\n    // '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)*' + re.src_domain/*_root*/ + ')' +\n    ')';\n\n  re.tpl_host_fuzzy =\n\n    '(?:' +\n      re.src_ip4 +\n    '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))' +\n    ')';\n\n  re.tpl_host_no_ip_fuzzy =\n\n    '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))';\n\n  re.src_host_strict =\n\n    re.src_host + re.src_host_terminator;\n\n  re.tpl_host_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_host_terminator;\n\n  re.src_host_port_strict =\n\n    re.src_host + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_no_ip_fuzzy_strict =\n\n    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Main rules\n\n  // Rude test fuzzy links by host, for quick deny\n  re.tpl_host_fuzzy_test =\n\n    'localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';\n\n  re.tpl_email_fuzzy =\n\n      '(^|' + text_separators + '|\"|\\\\(|' + re.src_ZCc + ')' +\n      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';\n\n  re.tpl_link_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';\n\n  re.tpl_link_no_ip_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';\n\n  return re;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/linkify-it/lib/re.js?");

/***/ }),

/***/ "./node_modules/markdown-it-sanitizer/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/markdown-it-sanitizer/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("// Sanitizer\n\n\n\nmodule.exports = function sanitizer_plugin(md, options) {\n\n  var linkify = md.linkify,\n      escapeHtml = md.utils.escapeHtml,\n      // <a href=\"url\" title=\"(optional)\"></a>\n      patternLinkOpen = '<a\\\\s([^<>]*href=\"[^\"<>]*\"[^<>]*)\\\\s?>',\n      regexpLinkOpen = RegExp(patternLinkOpen, 'i'),\n      // <img src=\"url\" alt=\"\"(optional) title=\"\"(optional)>\n      patternImage = '<img\\\\s([^<>]*src=\"[^\"<>]*\"[^<>]*)\\\\s?\\\\/?>',\n      regexpImage = RegExp(patternImage, 'i'),\n      regexpImageProtocols = /^(?:https?:)?\\/\\//i,\n      regexpLinkProtocols = /^(?:https?:\\/\\/|ftp:\\/\\/|\\/\\/|mailto:|xmpp:)/i;\n\n  options = options ? options : {};\n  var removeUnknown = (typeof options.removeUnknown !== 'undefined') ? options.removeUnknown : false;\n  var removeUnbalanced = (typeof options.removeUnbalanced !== 'undefined') ? options.removeUnbalanced : false;\n  var imageClass = (typeof options.imageClass !== 'undefined') ? options.imageClass : '';\n  var runBalancer = false;\n  var j;\n\n\n  var allowedTags = [ 'a', 'b', 'blockquote', 'code', 'em', 'h1', 'h2', 'h3', 'h4', 'h5',\n                     'h6', 'li', 'ol', 'p', 'pre', 's', 'sub', 'sup', 'strong', 'ul' ];\n  var openTagCount = new Array(allowedTags.length);\n  var removeTag = new Array(allowedTags.length);\n  for (j = 0; j < allowedTags.length; j++) { openTagCount[j] = 0; }\n  for (j = 0; j < allowedTags.length; j++) { removeTag[j] = false; }\n\n  function getUrl(link) {\n    var match = linkify.match(link);\n    if (match && match.length === 1 && match[0].index === 0 && match[0].lastIndex === link.length) {\n      return match[0].url;\n    }\n    return null;\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  //          REPLACE UNKNOWN TAGS\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function replaceUnknownTags(str) {\n    /*\n     * it starts with '<' and maybe ends with '>',\n     * maybe has a '<' on the right\n     * it doesnt have '<' or '>' in between\n     * -> it's a tag!\n     */\n    str = str.replace(/<[^<>]*>?/gi, function (tag) {\n      var match, attrs, url, alt, title, tagnameIndex;\n\n      // '<->', '<- ' and '<3 ' look nice, they are harmless\n      if (/(^<->|^<-\\s|^<3\\s)/.test(tag)) { return tag; }\n\n      // images\n      match = tag.match(regexpImage);\n      if (match) {\n        attrs = match[1];\n        url   = getUrl(attrs.match(/src=\"([^\"<>]*)\"/i)[1]);\n        alt   = attrs.match(/alt=\"([^\"<>]*)\"/i);\n        alt   = (alt && typeof alt[1] !== 'undefined') ? alt[1] : '';\n        title = attrs.match(/title=\"([^\"<>]*)\"/i);\n        title = (title && typeof title[1] !== 'undefined') ? title[1] : '';\n\n        // only http and https are allowed for images\n        if (url && regexpImageProtocols.test(url)) {\n          if (imageClass !== '') {\n            return '<img src=\"' + url + '\" alt=\"' + alt + '\" title=\"' + title + '\" class=\"' + imageClass + '\">';\n          }\n          return '<img src=\"' + url + '\" alt=\"' + alt + '\" title=\"' + title + '\">';\n        }\n      }\n\n      // links\n      tagnameIndex = allowedTags.indexOf('a');\n      match = tag.match(regexpLinkOpen);\n      if (match) {\n        attrs = match[1];\n        url   = getUrl(attrs.match(/href=\"([^\"<>]*)\"/i)[1]);\n        title = attrs.match(/title=\"([^\"<>]*)\"/i);\n        title = (title && typeof title[1] !== 'undefined') ? title[1] : '';\n        // only http, https, ftp, mailto and xmpp are allowed for links\n        if (url && regexpLinkProtocols.test(url)) {\n          runBalancer = true;\n          openTagCount[tagnameIndex] += 1;\n          return '<a href=\"' + url + '\" title=\"' + title + '\" target=\"_blank\">';\n        }\n      }\n      match = /<\\/a>/i.test(tag);\n      if (match) {\n        runBalancer = true;\n        openTagCount[tagnameIndex] -= 1;\n        if (openTagCount[tagnameIndex] < 0) {\n          removeTag[tagnameIndex] = true;\n        }\n        return '</a>';\n      }\n\n      // standalone tags\n      match = tag.match(/<(br|hr)\\s?\\/?>/i);\n      if (match) {\n        return '<' + match[1].toLowerCase() + '>';\n      }\n\n      // whitelisted tags\n      match = tag.match(/<(\\/?)(b|blockquote|code|em|h[1-6]|li|ol(?: start=\"\\d+\")?|p|pre|s|sub|sup|strong|ul)>/i);\n      if (match && !/<\\/ol start=\"\\d+\"/i.test(tag)) {\n        runBalancer = true;\n        tagnameIndex = allowedTags.indexOf(match[2].toLowerCase().split(' ')[0]);\n        if (match[1] === '/') {\n          openTagCount[tagnameIndex] -= 1;\n        } else {\n          openTagCount[tagnameIndex] += 1;\n        }\n        if (openTagCount[tagnameIndex] < 0) {\n          removeTag[tagnameIndex] = true;\n        }\n        return '<' + match[1] + match[2].toLowerCase() + '>';\n      }\n\n      // other tags we don't recognize\n      if (removeUnknown === true) {\n        return '';\n      }\n      return escapeHtml(tag);\n    });\n\n    return str;\n  }\n\n\n  function sanitizeInlineAndBlock(state) {\n    var i, blkIdx, inlineTokens;\n    // reset counts\n    for (j = 0; j < allowedTags.length; j++) { openTagCount[j] = 0; }\n    for (j = 0; j < allowedTags.length; j++) { removeTag[j] = false; }\n    runBalancer = false;\n\n\n    for (blkIdx = 0; blkIdx < state.tokens.length; blkIdx++) {\n      if (state.tokens[blkIdx].type === 'html_block') {\n        state.tokens[blkIdx].content = replaceUnknownTags(state.tokens[blkIdx].content);\n      }\n      if (state.tokens[blkIdx].type !== 'inline') {\n        continue;\n      }\n\n      inlineTokens = state.tokens[blkIdx].children;\n      for (i = 0; i < inlineTokens.length; i++) {\n        if (inlineTokens[i].type === 'html_inline') {\n          inlineTokens[i].content = replaceUnknownTags(inlineTokens[i].content);\n        }\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  //          REPLACE UNBALANCED TAGS\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function balance(state) {\n    if (runBalancer === false) { return; }\n    var blkIdx, inlineTokens;\n\n    function replaceUnbalancedTag(str, tagname) {\n      var openingRegexp, closingRegexp;\n      if (tagname === 'a') {\n        openingRegexp = RegExp('<a href=\"[^\"<>]*\" title=\"[^\"<>]*\" target=\"_blank\">', 'g');\n      } else if (tagname === 'ol') {\n        openingRegexp = /<ol(?: start=\"\\d+\")?>/g;\n      } else {\n        openingRegexp = RegExp('<' + tagname + '>', 'g');\n      }\n      closingRegexp = RegExp('</' + tagname + '>', 'g');\n      if (removeUnbalanced === true) {\n        str = str.replace(openingRegexp, '');\n        str = str.replace(closingRegexp, '');\n      } else {\n        str = str.replace(openingRegexp, function (m) { return escapeHtml(m); });\n        str = str.replace(closingRegexp, function (m) { return escapeHtml(m); });\n      }\n      return str;\n    }\n\n    function replaceAllUnbalancedTags(str) {\n      var i;\n      for (i = 0; i < allowedTags.length; i++) {\n        if (removeTag[i] === true) {\n          str = replaceUnbalancedTag(str, allowedTags[i]);\n        }\n      }\n      return str;\n    }\n\n    for (j = 0; j < allowedTags.length; j++) {\n      if (openTagCount[j] !== 0) {\n        removeTag[j] = true;\n      }\n    }\n\n    // replace unbalanced tags\n    for (blkIdx = 0; blkIdx < state.tokens.length; blkIdx++) {\n      if (state.tokens[blkIdx].type === 'html_block') {\n        state.tokens[blkIdx].content = replaceAllUnbalancedTags(state.tokens[blkIdx].content);\n        continue;\n      }\n      if (state.tokens[blkIdx].type !== 'inline') {\n        continue;\n      }\n      inlineTokens = state.tokens[blkIdx].children;\n      for (j = 0; j < inlineTokens.length; j++) {\n        if (inlineTokens[j].type === 'html_inline') {\n          inlineTokens[j].content = replaceAllUnbalancedTags(inlineTokens[j].content);\n        }\n      }\n    }\n  }\n\n  md.core.ruler.after('linkify', 'sanitize_inline', sanitizeInlineAndBlock);\n  md.core.ruler.after('sanitize_inline', 'sanitize_balance', balance);\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it-sanitizer/index.js?");

/***/ }),

/***/ "./node_modules/markdown-it/index.js":
/*!*******************************************!*\
  !*** ./node_modules/markdown-it/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nmodule.exports = __webpack_require__(/*! ./lib/ */ \"./node_modules/markdown-it/lib/index.js\");\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/index.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/entities.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/entities.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// HTML5 entities map: { name -> utf16string }\n//\n\n\n/*eslint quotes:0*/\nmodule.exports = __webpack_require__(/*! entities/maps/entities.json */ \"./node_modules/entities/maps/entities.json\");\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/common/entities.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/html_blocks.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_blocks.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n\n\n\nmodule.exports = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'meta',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'source',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n];\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/common/html_blocks.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/html_re.js":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_re.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("// Regexps to match html elements\n\n\n\nvar attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\n\nvar unquoted      = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar single_quoted = \"'[^']*'\";\nvar double_quoted = '\"[^\"]*\"';\n\nvar attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';\n\nvar attribute   = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)';\n\nvar open_tag    = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\n\nvar close_tag   = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\nvar comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar processing  = '<[?].*?[?]>';\nvar declaration = '<![A-Z]+\\\\s+[^>]*>';\nvar cdata       = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\n\nvar HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +\n                        '|' + processing + '|' + declaration + '|' + cdata + ')');\nvar HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');\n\nmodule.exports.HTML_TAG_RE = HTML_TAG_RE;\nmodule.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/common/html_re.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Utilities\n//\n\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction isString(obj) { return _class(obj) === '[object String]'; }\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return _hasOwnProperty.call(object, key);\n}\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt(src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\n\nvar UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\nvar ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;\nvar UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');\n\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nvar entities = __webpack_require__(/*! ./entities */ \"./node_modules/markdown-it/lib/common/entities.js\");\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n\n  if (has(entities, name)) {\n    return entities[name];\n  }\n\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16)\n    :\n      parseInt(name.slice(1), 10);\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n\n  return match;\n}\n\n/*function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n}*/\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\nfunction unescapeAll(str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str; }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped; }\n    return replaceEntityPattern(match, entity);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n\nfunction escapeRE(str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isSpace(code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true;\n  }\n  return false;\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace(code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true; }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/*eslint-disable max-len*/\nvar UNICODE_PUNCT_RE = __webpack_require__(/*! uc.micro/categories/P/regex */ \"./node_modules/uc.micro/categories/P/regex.js\");\n\n// Currently without astral characters support.\nfunction isPunctChar(ch) {\n  return UNICODE_PUNCT_RE.test(ch);\n}\n\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct(ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nexports.lib                 = {};\nexports.lib.mdurl = __webpack_require__(/*! mdurl */ \"./node_modules/mdurl/index.js\");\nexports.lib.ucmicro = __webpack_require__(/*! uc.micro */ \"./node_modules/uc.micro/index.js\");\n\nexports.assign              = assign;\nexports.isString            = isString;\nexports.has                 = has;\nexports.unescapeMd          = unescapeMd;\nexports.unescapeAll         = unescapeAll;\nexports.isValidEntityCode   = isValidEntityCode;\nexports.fromCodePoint       = fromCodePoint;\n// exports.replaceEntities     = replaceEntities;\nexports.escapeHtml          = escapeHtml;\nexports.arrayReplaceAt      = arrayReplaceAt;\nexports.isSpace             = isSpace;\nexports.isWhiteSpace        = isWhiteSpace;\nexports.isMdAsciiPunct      = isMdAsciiPunct;\nexports.isPunctChar         = isPunctChar;\nexports.escapeRE            = escapeRE;\nexports.normalizeReference  = normalizeReference;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/common/utils.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Just a shortcut for bulk export\n\n\n\nexports.parseLinkLabel = __webpack_require__(/*! ./parse_link_label */ \"./node_modules/markdown-it/lib/helpers/parse_link_label.js\");\nexports.parseLinkDestination = __webpack_require__(/*! ./parse_link_destination */ \"./node_modules/markdown-it/lib/helpers/parse_link_destination.js\");\nexports.parseLinkTitle = __webpack_require__(/*! ./parse_link_title */ \"./node_modules/markdown-it/lib/helpers/parse_link_title.js\");\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/helpers/index.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_destination.js":
/*!************************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_destination.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Parse link destination\n//\n\n\n\nvar isSpace     = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\nvar unescapeAll = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").unescapeAll);\n\n\nmodule.exports = function parseLinkDestination(str, pos, max) {\n  var code, level,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (str.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = str.charCodeAt(pos);\n      if (code === 0x0A /* \\n */ || isSpace(code)) { return result; }\n      if (code === 0x3E /* > */) {\n        result.pos = pos + 1;\n        result.str = unescapeAll(str.slice(start + 1, pos));\n        result.ok = true;\n        return result;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n\n      pos++;\n    }\n\n    // no closing '>'\n    return result;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n\n    if (code === 0x20) { break; }\n\n    // ascii control characters\n    if (code < 0x20 || code === 0x7F) { break; }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++;\n    }\n\n    if (code === 0x29 /* ) */) {\n      if (level === 0) { break; }\n      level--;\n    }\n\n    pos++;\n  }\n\n  if (start === pos) { return result; }\n  if (level !== 0) { return result; }\n\n  result.str = unescapeAll(str.slice(start, pos));\n  result.lines = lines;\n  result.pos = pos;\n  result.ok = true;\n  return result;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/helpers/parse_link_destination.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_label.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_label.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level, found, marker, prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n\n  return labelEnd;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/helpers/parse_link_label.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_title.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_title.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Parse link title\n//\n\n\n\nvar unescapeAll = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").unescapeAll);\n\n\nmodule.exports = function parseLinkTitle(str, pos, max) {\n  var code,\n      marker,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (pos >= max) { return result; }\n\n  marker = str.charCodeAt(pos);\n\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }\n\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) { marker = 0x29; }\n\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n    if (code === marker) {\n      result.pos = pos + 1;\n      result.lines = lines;\n      result.str = unescapeAll(str.slice(start + 1, pos));\n      result.ok = true;\n      return result;\n    } else if (code === 0x0A) {\n      lines++;\n    } else if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos++;\n      if (str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n\n    pos++;\n  }\n\n  return result;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/helpers/parse_link_title.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Main parser class\n\n\n\n\nvar utils        = __webpack_require__(/*! ./common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\");\nvar helpers      = __webpack_require__(/*! ./helpers */ \"./node_modules/markdown-it/lib/helpers/index.js\");\nvar Renderer     = __webpack_require__(/*! ./renderer */ \"./node_modules/markdown-it/lib/renderer.js\");\nvar ParserCore   = __webpack_require__(/*! ./parser_core */ \"./node_modules/markdown-it/lib/parser_core.js\");\nvar ParserBlock  = __webpack_require__(/*! ./parser_block */ \"./node_modules/markdown-it/lib/parser_block.js\");\nvar ParserInline = __webpack_require__(/*! ./parser_inline */ \"./node_modules/markdown-it/lib/parser_inline.js\");\nvar LinkifyIt    = __webpack_require__(/*! linkify-it */ \"./node_modules/linkify-it/index.js\");\nvar mdurl        = __webpack_require__(/*! mdurl */ \"./node_modules/mdurl/index.js\");\nvar punycode     = __webpack_require__(/*! punycode */ \"./node_modules/punycode/punycode.es6.js\");\n\n\nvar config = {\n  'default': __webpack_require__(/*! ./presets/default */ \"./node_modules/markdown-it/lib/presets/default.js\"),\n  zero: __webpack_require__(/*! ./presets/zero */ \"./node_modules/markdown-it/lib/presets/zero.js\"),\n  commonmark: __webpack_require__(/*! ./presets/commonmark */ \"./node_modules/markdown-it/lib/presets/commonmark.js\")\n};\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// This validator can prohibit more than really needed to prevent XSS. It's a\n// tradeoff to keep code simple and to be secure by default.\n//\n// If you need different setup - override validator method as you wish. Or\n// replace it with dummy function and use external sanitizer.\n//\n\nvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\nvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n\nfunction validateLink(url) {\n  // url should be normalized at this point, and existing entities are decoded\n  var str = url.trim().toLowerCase();\n\n  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];\n\nfunction normalizeLink(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.encode(mdurl.format(parsed));\n}\n\nfunction normalizeLinkText(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toUnicode(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.decode(mdurl.format(parsed));\n}\n\n\n/**\n * class MarkdownIt\n *\n * Main parser/renderer class.\n *\n * ##### Usage\n *\n * ```javascript\n * // node.js, \"classic\" way:\n * var MarkdownIt = require('markdown-it'),\n *     md = new MarkdownIt();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // node.js, the same, but with sugar:\n * var md = require('markdown-it')();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // browser without AMD, added to \"window\" on script load\n * // Note, there are no dash.\n * var md = window.markdownit();\n * var result = md.render('# markdown-it rulezz!');\n * ```\n *\n * Single line rendering, without paragraph wrap:\n *\n * ```javascript\n * var md = require('markdown-it')();\n * var result = md.renderInline('__markdown-it__ rulezz!');\n * ```\n **/\n\n/**\n * new MarkdownIt([presetName, options])\n * - presetName (String): optional, `commonmark` / `zero`\n * - options (Object)\n *\n * Creates parser instanse with given config. Can be called without `new`.\n *\n * ##### presetName\n *\n * MarkdownIt provides named presets as a convenience to quickly\n * enable/disable active syntax rules and options for common use cases.\n *\n * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -\n *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -\n *   similar to GFM, used when no preset name given. Enables all available rules,\n *   but still without html, typographer & autolinker.\n * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -\n *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n *   For example, when you need only `bold` and `italic` markup and nothing else.\n *\n * ##### options:\n *\n * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n *   That's not safe! You may need external sanitizer to protect output from XSS.\n *   It's better to extend features via plugins, instead of enabling HTML.\n * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n *   (`<br />`). This is needed only for full CommonMark compatibility. In real\n *   world you will need HTML output.\n * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\n * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n *   Can be useful for external highlighters.\n * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +\n *   quotes beautification (smartquotes).\n * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement\n *   pairs, when typographer enabled and smartquotes on. For example, you can\n *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and\n *   `['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›']` for French (including nbsp).\n * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n *   return empty string if the source was not changed and should be escaped\n *   externaly. If result starts with <pre... internal wrapper is skipped.\n *\n * ##### Example\n *\n * ```javascript\n * // commonmark mode\n * var md = require('markdown-it')('commonmark');\n *\n * // default mode\n * var md = require('markdown-it')();\n *\n * // enable everything\n * var md = require('markdown-it')({\n *   html: true,\n *   linkify: true,\n *   typographer: true\n * });\n * ```\n *\n * ##### Syntax highlighting\n *\n * ```js\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return hljs.highlight(lang, str, true).value;\n *       } catch (__) {}\n *     }\n *\n *     return ''; // use external default escaping\n *   }\n * });\n * ```\n *\n * Or with full wrapper override (if you need assign class to `<pre>`):\n *\n * ```javascript\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * // Actual default values\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return '<pre class=\"hljs\"><code>' +\n *                hljs.highlight(lang, str, true).value +\n *                '</code></pre>';\n *       } catch (__) {}\n *     }\n *\n *     return '<pre class=\"hljs\"><code>' + md.utils.escapeHtml(str) + '</code></pre>';\n *   }\n * });\n * ```\n *\n **/\nfunction MarkdownIt(presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options);\n  }\n\n  if (!options) {\n    if (!utils.isString(presetName)) {\n      options = presetName || {};\n      presetName = 'default';\n    }\n  }\n\n  /**\n   * MarkdownIt#inline -> ParserInline\n   *\n   * Instance of [[ParserInline]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.inline = new ParserInline();\n\n  /**\n   * MarkdownIt#block -> ParserBlock\n   *\n   * Instance of [[ParserBlock]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.block = new ParserBlock();\n\n  /**\n   * MarkdownIt#core -> Core\n   *\n   * Instance of [[Core]] chain executor. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.core = new ParserCore();\n\n  /**\n   * MarkdownIt#renderer -> Renderer\n   *\n   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n   * rules for new token types, generated by plugins.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * function myToken(tokens, idx, options, env, self) {\n   *   //...\n   *   return result;\n   * };\n   *\n   * md.renderer.rules['my_token'] = myToken\n   * ```\n   *\n   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).\n   **/\n  this.renderer = new Renderer();\n\n  /**\n   * MarkdownIt#linkify -> LinkifyIt\n   *\n   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)\n   * rule.\n   **/\n  this.linkify = new LinkifyIt();\n\n  /**\n   * MarkdownIt#validateLink(url) -> Boolean\n   *\n   * Link validation function. CommonMark allows too much in links. By default\n   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n   * except some embedded image types.\n   *\n   * You can change this behaviour:\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   * // enable everything\n   * md.validateLink = function () { return true; }\n   * ```\n   **/\n  this.validateLink = validateLink;\n\n  /**\n   * MarkdownIt#normalizeLink(url) -> String\n   *\n   * Function used to encode link url to a machine-readable format,\n   * which includes url-encoding, punycode, etc.\n   **/\n  this.normalizeLink = normalizeLink;\n\n  /**\n   * MarkdownIt#normalizeLinkText(url) -> String\n   *\n   * Function used to decode link url to a human-readable format`\n   **/\n  this.normalizeLinkText = normalizeLinkText;\n\n\n  // Expose utils & helpers for easy acces from plugins\n\n  /**\n   * MarkdownIt#utils -> utils\n   *\n   * Assorted utility functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).\n   **/\n  this.utils = utils;\n\n  /**\n   * MarkdownIt#helpers -> helpers\n   *\n   * Link components parser functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n   **/\n  this.helpers = utils.assign({}, helpers);\n\n\n  this.options = {};\n  this.configure(presetName);\n\n  if (options) { this.set(options); }\n}\n\n\n/** chainable\n * MarkdownIt.set(options)\n *\n * Set parser options (in the same format as in constructor). Probably, you\n * will never need it, but you can change options after constructor call.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .set({ html: true, breaks: true })\n *             .set({ typographer, true });\n * ```\n *\n * __Note:__ To achieve the best possible performance, don't modify a\n * `markdown-it` instance options on the fly. If you need multiple configurations\n * it's best to create multiple instances and initialize each with separate\n * config.\n **/\nMarkdownIt.prototype.set = function (options) {\n  utils.assign(this.options, options);\n  return this;\n};\n\n\n/** chainable, internal\n * MarkdownIt.configure(presets)\n *\n * Batch load of all options and compenent settings. This is internal method,\n * and you probably will not need it. But if you with - see available presets\n * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n *\n * We strongly recommend to use presets instead of direct config loads. That\n * will give better compatibility with next versions.\n **/\nMarkdownIt.prototype.configure = function (presets) {\n  var self = this, presetName;\n\n  if (utils.isString(presets)) {\n    presetName = presets;\n    presets = config[presetName];\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name'); }\n  }\n\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty'); }\n\n  if (presets.options) { self.set(presets.options); }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enableOnly(presets.components[name].rules);\n      }\n      if (presets.components[name].rules2) {\n        self[name].ruler2.enableOnly(presets.components[name].rules2);\n      }\n    });\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.enable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to enable\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable list or rules. It will automatically find appropriate components,\n * containing rules with given names. If rule not found, and `ignoreInvalid`\n * not set - throws exception.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .enable(['sub', 'sup'])\n *             .disable('smartquotes');\n * ```\n **/\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.enable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.enable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);\n  }\n\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.disable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * The same as [[MarkdownIt.enable]], but turn specified rules off.\n **/\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.disable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.disable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.use(plugin, params)\n *\n * Load specified plugin with given params into current parser instance.\n * It's just a sugar to call `plugin(md, params)` with curring.\n *\n * ##### Example\n *\n * ```javascript\n * var iterator = require('markdown-it-for-inline');\n * var md = require('markdown-it')()\n *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n *             });\n * ```\n **/\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));\n  plugin.apply(plugin, args);\n  return this;\n};\n\n\n/** internal\n * MarkdownIt.parse(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Parse input string and returns list of block tokens (special token type\n * \"inline\" will contain list of inline tokens). You should not call this\n * method directly, until you write custom renderer (for example, to produce\n * AST).\n *\n * `env` is used to pass data between \"distributed\" rules and return additional\n * metadata like reference info, needed for the renderer. It also can be used to\n * inject data in specific cases. Usually, you will be ok to pass `{}`,\n * and then pass updated object to renderer.\n **/\nMarkdownIt.prototype.parse = function (src, env) {\n  if (typeof src !== 'string') {\n    throw new Error('Input data should be a String');\n  }\n\n  var state = new this.core.State(src, this, env);\n\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.render(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Render markdown string into html. It does all magic for you :).\n *\n * `env` can be used to inject additional metadata (`{}` by default).\n * But you will not need it with high probability. See also comment\n * in [[MarkdownIt.parse]].\n **/\nMarkdownIt.prototype.render = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parse(src, env), this.options, env);\n};\n\n\n/** internal\n * MarkdownIt.parseInline(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n * block tokens list with the single `inline` element, containing parsed inline\n * tokens in `children` property. Also updates `env` object.\n **/\nMarkdownIt.prototype.parseInline = function (src, env) {\n  var state = new this.core.State(src, this, env);\n\n  state.inlineMode = true;\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.renderInline(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n * will NOT be wrapped into `<p>` tags.\n **/\nMarkdownIt.prototype.renderInline = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parseInline(src, env), this.options, env);\n};\n\n\nmodule.exports = MarkdownIt;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/index.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_block.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_block.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n\n\n\nvar Ruler           = __webpack_require__(/*! ./ruler */ \"./node_modules/markdown-it/lib/ruler.js\");\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      __webpack_require__(/*! ./rules_block/table */ \"./node_modules/markdown-it/lib/rules_block/table.js\"),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       __webpack_require__(/*! ./rules_block/code */ \"./node_modules/markdown-it/lib/rules_block/code.js\") ],\n  [ 'fence',      __webpack_require__(/*! ./rules_block/fence */ \"./node_modules/markdown-it/lib/rules_block/fence.js\"),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', __webpack_require__(/*! ./rules_block/blockquote */ \"./node_modules/markdown-it/lib/rules_block/blockquote.js\"), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         __webpack_require__(/*! ./rules_block/hr */ \"./node_modules/markdown-it/lib/rules_block/hr.js\"),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       __webpack_require__(/*! ./rules_block/list */ \"./node_modules/markdown-it/lib/rules_block/list.js\"),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  __webpack_require__(/*! ./rules_block/reference */ \"./node_modules/markdown-it/lib/rules_block/reference.js\") ],\n  [ 'heading',    __webpack_require__(/*! ./rules_block/heading */ \"./node_modules/markdown-it/lib/rules_block/heading.js\"),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   __webpack_require__(/*! ./rules_block/lheading */ \"./node_modules/markdown-it/lib/rules_block/lheading.js\") ],\n  [ 'html_block', __webpack_require__(/*! ./rules_block/html_block */ \"./node_modules/markdown-it/lib/rules_block/html_block.js\"), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'paragraph',  __webpack_require__(/*! ./rules_block/paragraph */ \"./node_modules/markdown-it/lib/rules_block/paragraph.js\") ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = __webpack_require__(/*! ./rules_block/state_block */ \"./node_modules/markdown-it/lib/rules_block/state_block.js\");\n\n\nmodule.exports = ParserBlock;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/parser_block.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_core.js":
/*!*****************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_core.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/** internal\n * class Core\n *\n * Top-level rules executor. Glues block/inline parsers and does intermediate\n * transformations.\n **/\n\n\n\nvar Ruler  = __webpack_require__(/*! ./ruler */ \"./node_modules/markdown-it/lib/ruler.js\");\n\n\nvar _rules = [\n  [ 'normalize',      __webpack_require__(/*! ./rules_core/normalize */ \"./node_modules/markdown-it/lib/rules_core/normalize.js\")      ],\n  [ 'block',          __webpack_require__(/*! ./rules_core/block */ \"./node_modules/markdown-it/lib/rules_core/block.js\")          ],\n  [ 'inline',         __webpack_require__(/*! ./rules_core/inline */ \"./node_modules/markdown-it/lib/rules_core/inline.js\")         ],\n  [ 'linkify',        __webpack_require__(/*! ./rules_core/linkify */ \"./node_modules/markdown-it/lib/rules_core/linkify.js\")        ],\n  [ 'replacements',   __webpack_require__(/*! ./rules_core/replacements */ \"./node_modules/markdown-it/lib/rules_core/replacements.js\")   ],\n  [ 'smartquotes',    __webpack_require__(/*! ./rules_core/smartquotes */ \"./node_modules/markdown-it/lib/rules_core/smartquotes.js\")    ]\n];\n\n\n/**\n * new Core()\n **/\nfunction Core() {\n  /**\n   * Core#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of core rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n\n/**\n * Core.process(state)\n *\n * Executes core chain rules.\n **/\nCore.prototype.process = function (state) {\n  var i, l, rules;\n\n  rules = this.ruler.getRules('');\n\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\nCore.prototype.State = __webpack_require__(/*! ./rules_core/state_core */ \"./node_modules/markdown-it/lib/rules_core/state_core.js\");\n\n\nmodule.exports = Core;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/parser_core.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_inline.js":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_inline.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n\n\n\nvar Ruler           = __webpack_require__(/*! ./ruler */ \"./node_modules/markdown-it/lib/ruler.js\");\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Parser rules\n\nvar _rules = [\n  [ 'text',            __webpack_require__(/*! ./rules_inline/text */ \"./node_modules/markdown-it/lib/rules_inline/text.js\") ],\n  [ 'newline',         __webpack_require__(/*! ./rules_inline/newline */ \"./node_modules/markdown-it/lib/rules_inline/newline.js\") ],\n  [ 'escape',          __webpack_require__(/*! ./rules_inline/escape */ \"./node_modules/markdown-it/lib/rules_inline/escape.js\") ],\n  [ 'backticks',       __webpack_require__(/*! ./rules_inline/backticks */ \"./node_modules/markdown-it/lib/rules_inline/backticks.js\") ],\n  [ 'strikethrough',   (__webpack_require__(/*! ./rules_inline/strikethrough */ \"./node_modules/markdown-it/lib/rules_inline/strikethrough.js\").tokenize) ],\n  [ 'emphasis',        (__webpack_require__(/*! ./rules_inline/emphasis */ \"./node_modules/markdown-it/lib/rules_inline/emphasis.js\").tokenize) ],\n  [ 'link',            __webpack_require__(/*! ./rules_inline/link */ \"./node_modules/markdown-it/lib/rules_inline/link.js\") ],\n  [ 'image',           __webpack_require__(/*! ./rules_inline/image */ \"./node_modules/markdown-it/lib/rules_inline/image.js\") ],\n  [ 'autolink',        __webpack_require__(/*! ./rules_inline/autolink */ \"./node_modules/markdown-it/lib/rules_inline/autolink.js\") ],\n  [ 'html_inline',     __webpack_require__(/*! ./rules_inline/html_inline */ \"./node_modules/markdown-it/lib/rules_inline/html_inline.js\") ],\n  [ 'entity',          __webpack_require__(/*! ./rules_inline/entity */ \"./node_modules/markdown-it/lib/rules_inline/entity.js\") ]\n];\n\nvar _rules2 = [\n  [ 'balance_pairs',   __webpack_require__(/*! ./rules_inline/balance_pairs */ \"./node_modules/markdown-it/lib/rules_inline/balance_pairs.js\") ],\n  [ 'strikethrough',   (__webpack_require__(/*! ./rules_inline/strikethrough */ \"./node_modules/markdown-it/lib/rules_inline/strikethrough.js\").postProcess) ],\n  [ 'emphasis',        (__webpack_require__(/*! ./rules_inline/emphasis */ \"./node_modules/markdown-it/lib/rules_inline/emphasis.js\").postProcess) ],\n  [ 'text_collapse',   __webpack_require__(/*! ./rules_inline/text_collapse */ \"./node_modules/markdown-it/lib/rules_inline/text_collapse.js\") ]\n];\n\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline() {\n  var i;\n\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new Ruler();\n\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\n\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  var ok, i, pos = state.pos,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      maxNesting = state.md.options.maxNesting,\n      cache = state.cache;\n\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n\n      if (ok) { break; }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n\n  if (!ok) { state.pos++; }\n  cache[pos] = state.pos;\n};\n\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      end = state.posMax,\n      maxNesting = state.md.options.maxNesting;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n        if (ok) { break; }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md, env, outTokens);\n\n  this.tokenize(state);\n\n  rules = this.ruler2.getRules('');\n  len = rules.length;\n\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\n\n\nParserInline.prototype.State = __webpack_require__(/*! ./rules_inline/state_inline */ \"./node_modules/markdown-it/lib/rules_inline/state_inline.js\");\n\n\nmodule.exports = ParserInline;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/parser_inline.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/commonmark.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/commonmark.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("// Commonmark default options\n\n\n\n\nmodule.exports = {\n  options: {\n    html:         true,         // Enable HTML tags in source\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fence',\n        'heading',\n        'hr',\n        'html_block',\n        'lheading',\n        'list',\n        'reference',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'html_inline',\n        'image',\n        'link',\n        'newline',\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'emphasis',\n        'text_collapse'\n      ]\n    }\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/presets/commonmark.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/default.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/default.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("// markdown-it default options\n\n\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   100            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/presets/default.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/zero.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/zero.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("// \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\n// modes. For example, to parse bold/italic only.\n\n\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'text_collapse'\n      ]\n    }\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/presets/zero.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/renderer.js":
/*!**************************************************!*\
  !*** ./node_modules/markdown-it/lib/renderer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n\n\n\nvar assign          = (__webpack_require__(/*! ./common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").assign);\nvar unescapeAll     = (__webpack_require__(/*! ./common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").unescapeAll);\nvar escapeHtml      = (__webpack_require__(/*! ./common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").escapeHtml);\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<code' + slf.renderAttrs(token) + '>' +\n          escapeHtml(tokens[idx].content) +\n          '</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<pre' + slf.renderAttrs(token) + '><code>' +\n          escapeHtml(tokens[idx].content) +\n          '</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      highlighted, i, tmpAttrs, tmpToken;\n\n  if (info) {\n    langName = info.split(/\\s+/g)[0];\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .clone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    i        = token.attrIndex('class');\n    tmpAttrs = token.attrs ? token.attrs.slice() : [];\n\n    if (i < 0) {\n      tmpAttrs.push([ 'class', options.langPrefix + langName ]);\n    } else {\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;\n    }\n\n    // Fake token just to render attributes\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n\n    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'\n          + highlighted\n          + '</code></pre>\\n';\n  }\n\n\n  return  '<pre><code' + slf.renderAttrs(token) + '>'\n        + highlighted\n        + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env);\n\n  return slf.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) { return ''; }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n\n  return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '';\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += tokens[i].content;\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i, len, type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/renderer.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/ruler.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/ruler.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n\n\n\n/**\n * new Ruler()\n **/\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\n\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\n\n  this.enable(list, ignoreInvalid);\n};\n\n\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || [];\n};\n\nmodule.exports = Ruler;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/ruler.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/blockquote.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/blockquote.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Block quotes\n\n\n\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      wasOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip spaces after \">\" and re-calculate offset\n  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  wasOutdented = false;\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !wasOutdented) {\n      // This line is inside the blockquote.\n\n      // skip spaces after \">\" and re-calculate offset\n      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/blockquote.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/code.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/code.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("// Code block (4 spaces padded)\n\n\n\n\nmodule.exports = function code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last, token;\n\n  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = last;\n\n  token         = state.push('code_block', 'code', 0);\n  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/code.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/fence.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/fence.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("// fences (``` lang, ~~~ lang)\n\n\n\n\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem, token, markup,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n\n  if (params.indexOf(String.fromCharCode(marker)) >= 0) { return false; }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n\n  token         = state.push('fence', 'code', 0);\n  token.info    = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup  = markup;\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/fence.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/heading.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/heading.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// heading (#, ##, ...)\n\n\n\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nmodule.exports = function heading(state, startLine, endLine, silent) {\n  var ch, level, tmp, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && !isSpace(ch))) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipSpacesBack(max, pos);\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  token        = state.push('heading_open', 'h' + String(level), 1);\n  token.markup = '########'.slice(0, level);\n  token.map    = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = state.src.slice(pos, max).trim();\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token        = state.push('heading_close', 'h' + String(level), -1);\n  token.markup = '########'.slice(0, level);\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/heading.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/hr.js":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/hr.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Horizontal rule\n\n\n\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nmodule.exports = function hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && !isSpace(ch)) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n\n  token        = state.push('hr', 'hr', 0);\n  token.map    = [ startLine, state.line ];\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/hr.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/html_block.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/html_block.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// HTML block\n\n\n\n\nvar block_names = __webpack_require__(/*! ../common/html_blocks */ \"./node_modules/markdown-it/lib/common/html_blocks.js\");\nvar HTML_OPEN_CLOSE_TAG_RE = (__webpack_require__(/*! ../common/html_re */ \"./node_modules/markdown-it/lib/common/html_re.js\").HTML_OPEN_CLOSE_TAG_RE);\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nvar HTML_SEQUENCES = [\n  [ /^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true ],\n  [ /^<!--/,        /-->/,   true ],\n  [ /^<\\?/,         /\\?>/,   true ],\n  [ /^<![A-Z]/,     />/,     true ],\n  [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ],\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true ],\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false ]\n];\n\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i, nextLine, token, lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (!state.md.options.html) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\n  }\n\n  if (i === HTML_SEQUENCES.length) { return false; }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++; }\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n\n  token         = state.push('html_block', '', 0);\n  token.map     = [ startLine, nextLine ];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/html_block.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/lheading.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/lheading.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("// lheading (---, ===)\n\n\n\n\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\n  var content, terminate, i, l, token, pos, max, level, marker,\n      nextLine = startLine + 1, oldParentType,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker);\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2);\n            break;\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine + 1;\n\n  token          = state.push('heading_open', 'h' + String(level), 1);\n  token.markup   = String.fromCharCode(marker);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line - 1 ];\n  token.children = [];\n\n  token          = state.push('heading_close', 'h' + String(level), -1);\n  token.markup   = String.fromCharCode(marker);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/lheading.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/list.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/list.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Lists\n\n\n\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldIndent,\n      oldLIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.tShift[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldLIndent = state.sCount[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldLIndent;\n    state.tight = oldTight;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/list.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/paragraph.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/paragraph.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("// Paragraph\n\n\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token, oldParentType,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/paragraph.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/reference.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/reference.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nvar normalizeReference   = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").normalizeReference);\nvar isSpace              = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.parentType = oldParentType;\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/reference.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/state_block.js":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/state_block.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Parser state class\n\n\n\nvar Token = __webpack_require__(/*! ../token */ \"./node_modules/markdown-it/lib/token.js\");\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = [];  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = [];\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root';\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, lineIndent, ch, first, last, queue, lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/state_block.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/table.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/table.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// GFM table, non-standard\n\n\n\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n\n  return state.src.substr(pos, max - pos);\n}\n\nfunction escapedSplit(str) {\n  var result = [],\n      pos = 0,\n      max = str.length,\n      ch,\n      escapes = 0,\n      lastPos = 0,\n      backTicked = false,\n      lastBackTick = 0;\n\n  ch  = str.charCodeAt(pos);\n\n  while (pos < max) {\n    if (ch === 0x60/* ` */) {\n      if (backTicked) {\n        // make \\` close code sequence, but not open it;\n        // the reason is: `\\` is correct code block\n        backTicked = false;\n        lastBackTick = pos;\n      } else if (escapes % 2 === 0) {\n        backTicked = true;\n        lastBackTick = pos;\n      }\n    } else if (ch === 0x7c/* | */ && (escapes % 2 === 0) && !backTicked) {\n      result.push(str.substring(lastPos, pos));\n      lastPos = pos + 1;\n    }\n\n    if (ch === 0x5c/* \\ */) {\n      escapes++;\n    } else {\n      escapes = 0;\n    }\n\n    pos++;\n\n    // If there was an un-closed backtick, go back to just after\n    // the last backtick, but as if it was a normal character\n    if (pos === max && backTicked) {\n      backTicked = false;\n      pos = lastBackTick + 1;\n    }\n\n    ch = str.charCodeAt(pos);\n  }\n\n  result.push(str.substring(lastPos));\n\n  return result;\n}\n\n\nmodule.exports = function table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, columns, columnCount, token,\n      aligns, t, tableLines, tbodyLines;\n\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false; }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  ch = state.src.charCodeAt(pos++);\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n  while (pos < state.eMarks[nextLine]) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false; }\n\n    pos++;\n  }\n\n  lineText = getLine(state, startLine + 1);\n\n  columns = lineText.split('|');\n  aligns = [];\n  for (i = 0; i < columns.length; i++) {\n    t = columns[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n  columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\n  // header row will define an amount of columns in the entire table,\n  // and align row shouldn't be smaller than that (the rest of the rows can)\n  columnCount = columns.length;\n  if (columnCount > aligns.length) { return false; }\n\n  if (silent) { return true; }\n\n  token     = state.push('table_open', 'table', 1);\n  token.map = tableLines = [ startLine, 0 ];\n\n  token     = state.push('thead_open', 'thead', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  token     = state.push('tr_open', 'tr', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  for (i = 0; i < columns.length; i++) {\n    token          = state.push('th_open', 'th', 1);\n    token.map      = [ startLine, startLine + 1 ];\n    if (aligns[i]) {\n      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n    }\n\n    token          = state.push('inline', '', 0);\n    token.content  = columns[i].trim();\n    token.map      = [ startLine, startLine + 1 ];\n    token.children = [];\n\n    token          = state.push('th_close', 'th', -1);\n  }\n\n  token     = state.push('tr_close', 'tr', -1);\n  token     = state.push('thead_close', 'thead', -1);\n\n  token     = state.push('tbody_open', 'tbody', 1);\n  token.map = tbodyLines = [ startLine + 2, 0 ];\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    lineText = getLine(state, nextLine).trim();\n    if (lineText.indexOf('|') === -1) { break; }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }\n    columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\n    token = state.push('tr_open', 'tr', 1);\n    for (i = 0; i < columnCount; i++) {\n      token          = state.push('td_open', 'td', 1);\n      if (aligns[i]) {\n        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n      }\n\n      token          = state.push('inline', '', 0);\n      token.content  = columns[i] ? columns[i].trim() : '';\n      token.children = [];\n\n      token          = state.push('td_close', 'td', -1);\n    }\n    token = state.push('tr_close', 'tr', -1);\n  }\n  token = state.push('tbody_close', 'tbody', -1);\n  token = state.push('table_close', 'table', -1);\n\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_block/table.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/block.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/block.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n\nmodule.exports = function block(state) {\n  var token;\n\n  if (state.inlineMode) {\n    token          = new state.Token('inline', '', 0);\n    token.content  = state.src;\n    token.map      = [ 0, 1 ];\n    token.children = [];\n    state.tokens.push(token);\n  } else {\n    state.md.block.parse(state.src, state.md, state.env, state.tokens);\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_core/block.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/inline.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/inline.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n    }\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_core/inline.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/linkify.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/linkify.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n\n\n\nvar arrayReplaceAt = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").arrayReplaceAt);\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\n      level, htmlLinkLevel, url, fullUrl, urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\n        text = currentToken.content;\n        links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) { continue; }\n\n          urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token         = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level   = level;\n            nodes.push(token);\n          }\n\n          token         = new state.Token('link_open', 'a', 1);\n          token.attrs   = [ [ 'href', fullUrl ] ];\n          token.level   = level++;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          token         = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level   = level;\n          nodes.push(token);\n\n          token         = new state.Token('link_close', 'a', -1);\n          token.level   = --level;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          token         = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level   = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_core/linkify.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/normalize.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/normalize.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("// Normalize input string\n\n\n\n\nvar NEWLINES_RE  = /\\r[\\n\\u0085]?|[\\u2424\\u2028\\u0085]/g;\nvar NULL_RE      = /\\u0000/g;\n\n\nmodule.exports = function inline(state) {\n  var str;\n\n  // Normalize newlines\n  str = state.src.replace(NEWLINES_RE, '\\n');\n\n  // Replace NULL characters\n  str = str.replace(NULL_RE, '\\uFFFD');\n\n  state.src = str;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_core/normalize.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/replacements.js":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/replacements.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("// Simple typographyc replacements\n//\n// (c) (C) → ©\n// (tm) (TM) → ™\n// (r) (R) → ®\n// +- → ±\n// (p) (P) -> §\n// ... → … (also ?.... → ?.., !.... → !..)\n// ???????? → ???, !!!!! → !!!, `,,` → `,`\n// -- → &ndash;, --- → &mdash;\n//\n\n\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\n// Workaround for phantomjs - need regex without /g flag,\n// or root check will fail every second time\nvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  c: '©',\n  r: '®',\n  p: '§',\n  tm: '™'\n};\n\nfunction replaceFn(match, name) {\n  return SCOPED_ABBR[name.toLowerCase()];\n}\n\nfunction replace_scoped(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\nfunction replace_rare(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      if (RARE_RE.test(token.content)) {\n        token.content = token.content\n                    .replace(/\\+-/g, '±')\n                    // .., ..., ....... -> …\n                    // but ?..... & !..... -> ?.. & !..\n                    .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..')\n                    .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n                    // em-dash\n                    .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n                    // en-dash\n                    .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\n                    .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n      }\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\n\nmodule.exports = function replace(state) {\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n      replace_scoped(state.tokens[blkIdx].children);\n    }\n\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n      replace_rare(state.tokens[blkIdx].children);\n    }\n\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_core/replacements.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/smartquotes.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/smartquotes.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Convert straight quotation marks to typographic ones\n//\n\n\n\nvar isWhiteSpace   = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isWhiteSpace);\nvar isPunctChar    = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isPunctChar);\nvar isMdAsciiPunct = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isMdAsciiPunct);\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /* ’ */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (tokens[j].type !== 'text') continue;\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (tokens[j].type !== 'text') continue;\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // treat this as the middle of the word\n        canOpen = false;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_core/smartquotes.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/state_core.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/state_core.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Core state object\n//\n\n\nvar Token = __webpack_require__(/*! ../token */ \"./node_modules/markdown-it/lib/token.js\");\n\n\nfunction StateCore(src, md, env) {\n  this.src = src;\n  this.env = env;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.md = md; // link to parser instance\n}\n\n// re-export Token class to use in core rules\nStateCore.prototype.Token = Token;\n\n\nmodule.exports = StateCore;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_core/state_core.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/autolink.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/autolink.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("// Process autolinks '<protocol:...>'\n\n\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)>/;\n\n\nmodule.exports = function autolink(state, silent) {\n  var tail, linkMatch, emailMatch, url, fullUrl, token,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) { return false; }\n\n  if (AUTOLINK_RE.test(tail)) {\n    linkMatch = tail.match(AUTOLINK_RE);\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink(url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  if (EMAIL_RE.test(tail)) {\n    emailMatch = tail.match(EMAIL_RE);\n\n    url = emailMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink('mailto:' + url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/autolink.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/backticks.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/backticks.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("// Parse backticks\n\n\n\nmodule.exports = function backtick(state, silent) {\n  var start, max, marker, matchStart, matchEnd, token,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        token         = state.push('code_inline', 'code', 0);\n        token.markup  = marker;\n        token.content = state.src.slice(pos, matchStart)\n                                 .replace(/[ \\n]+/g, ' ')\n                                 .trim();\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/backticks.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/balance_pairs.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/balance_pairs.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("// For each opening emphasis-like marker find a matching closing one\n//\n\n\n\nmodule.exports = function link_pairs(state) {\n  var i, j, lastDelim, currDelim,\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    lastDelim = delimiters[i];\n\n    if (!lastDelim.close) { continue; }\n\n    j = i - lastDelim.jump - 1;\n\n    while (j >= 0) {\n      currDelim = delimiters[j];\n\n      if (currDelim.open &&\n          currDelim.marker === lastDelim.marker &&\n          currDelim.end < 0 &&\n          currDelim.level === lastDelim.level) {\n\n        // typeofs are for backward compatibility with plugins\n        var odd_match = (currDelim.close || lastDelim.open) &&\n                        typeof currDelim.length !== 'undefined' &&\n                        typeof lastDelim.length !== 'undefined' &&\n                        (currDelim.length + lastDelim.length) % 3 === 0;\n\n        if (!odd_match) {\n          lastDelim.jump = i - j;\n          lastDelim.open = false;\n          currDelim.end  = i;\n          currDelim.jump = 0;\n          break;\n        }\n      }\n\n      j -= currDelim.jump + 1;\n    }\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/balance_pairs.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/emphasis.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/emphasis.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("// Process *this* and _that_\n//\n\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump:   i,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // Token level.\n      //\n      level:  state.level,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               delimiters[startDelim.end + 1].token === endDelim.token + 1 &&\n               delimiters[i - 1].marker === startDelim.marker;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/emphasis.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/entity.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/entity.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\n\nvar entities          = __webpack_require__(/*! ../common/entities */ \"./node_modules/markdown-it/lib/common/entities.js\");\nvar has               = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").has);\nvar isValidEntityCode = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isValidEntityCode);\nvar fromCodePoint     = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").fromCodePoint);\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nmodule.exports = function entity(state, silent) {\n  var ch, code, match, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        if (has(entities, match[1])) {\n          if (!silent) { state.pending += entities[match[1]]; }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) { state.pending += '&'; }\n  state.pos++;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/entity.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/escape.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/escape.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Process escaped chars and hardbreaks\n\n\n\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nmodule.exports = function escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push('hardbreak', 'br', 0);\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/escape.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/html_inline.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/html_inline.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Process html tags\n\n\n\n\nvar HTML_TAG_RE = (__webpack_require__(/*! ../common/html_re */ \"./node_modules/markdown-it/lib/common/html_re.js\").HTML_TAG_RE);\n\n\nfunction isLetter(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nmodule.exports = function html_inline(state, silent) {\n  var ch, match, max, token,\n      pos = state.pos;\n\n  if (!state.md.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    token         = state.push('html_inline', '', 0);\n    token.content = state.src.slice(pos, pos + match[0].length);\n  }\n  state.pos += match[0].length;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/html_inline.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/image.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/image.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Process ![image](<src> \"title\")\n\n\n\nvar normalizeReference   = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").normalizeReference);\nvar isSpace              = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nmodule.exports = function image(state, silent) {\n  var attrs,\n      code,\n      content,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      ref,\n      res,\n      title,\n      token,\n      tokens,\n      start,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 2;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens = []\n    );\n\n    token          = state.push('image', 'img', 0);\n    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];\n    token.children = tokens;\n    token.content  = content;\n\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/image.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/link.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/link.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Process [link](<to> \"stuff\")\n\n\n\nvar normalizeReference   = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").normalizeReference);\nvar isSpace              = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nmodule.exports = function link(state, silent) {\n  var attrs,\n      code,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      res,\n      ref,\n      title,\n      token,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      parseReference = true;\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 1;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false;\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true;\n    }\n    pos++;\n  }\n\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    token        = state.push('link_open', 'a', 1);\n    token.attrs  = attrs = [ [ 'href', href ] ];\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n\n    state.md.inline.tokenize(state);\n\n    token        = state.push('link_close', 'a', -1);\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/link.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/newline.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/newline.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Proceess '\\n'\n\n\n\nvar isSpace = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isSpace);\n\n\nmodule.exports = function newline(state, silent) {\n  var pmax, max, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        state.pending = state.pending.replace(/ +$/, '');\n        state.push('hardbreak', 'br', 0);\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push('softbreak', 'br', 0);\n      }\n\n    } else {\n      state.push('softbreak', 'br', 0);\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && isSpace(state.src.charCodeAt(pos))) { pos++; }\n\n  state.pos = pos;\n  return true;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/newline.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/state_inline.js":
/*!*******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/state_inline.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Inline parser state\n\n\n\n\nvar Token          = __webpack_require__(/*! ../token */ \"./node_modules/markdown-it/lib/token.js\");\nvar isWhiteSpace   = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isWhiteSpace);\nvar isPunctChar    = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isPunctChar);\nvar isMdAsciiPunct = (__webpack_require__(/*! ../common/utils */ \"./node_modules/markdown-it/lib/common/utils.js\").isMdAsciiPunct);\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  this.delimiters = [];   // Emphasis-like delimiters\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/state_inline.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/strikethrough.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/strikethrough.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("// ~~strike through~~\n//\n\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function strikethrough(state, silent) {\n  var i, scanned, token, len, ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x7E/* ~ */) { return false; }\n\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch = String.fromCharCode(marker);\n\n  if (len < 2) { return false; }\n\n  if (len % 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch;\n    len--;\n  }\n\n  for (i = 0; i < len; i += 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch + ch;\n\n    state.delimiters.push({\n      marker: marker,\n      jump:   i,\n      token:  state.tokens.length - 1,\n      level:  state.level,\n      end:    -1,\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function strikethrough(state) {\n  var i, j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x7E/* ~ */) {\n      continue;\n    }\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    token         = state.tokens[startDelim.token];\n    token.type    = 's_open';\n    token.tag     = 's';\n    token.nesting = 1;\n    token.markup  = '~~';\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = 's_close';\n    token.tag     = 's';\n    token.nesting = -1;\n    token.markup  = '~~';\n    token.content = '';\n\n    if (state.tokens[endDelim.token - 1].type === 'text' &&\n        state.tokens[endDelim.token - 1].content === '~') {\n\n      loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++;\n    }\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/strikethrough.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/text.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n\n\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n};\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParcerInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n};*/\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/text.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/text_collapse.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/text_collapse.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("// Merge adjacent text nodes into one, and re-calculate all token levels\n//\n\n\n\nmodule.exports = function text_collapse(state) {\n  var curr, last,\n      level = 0,\n      tokens = state.tokens,\n      max = state.tokens.length;\n\n  for (curr = last = 0; curr < max; curr++) {\n    // re-calculate levels\n    level += tokens[curr].nesting;\n    tokens[curr].level = level;\n\n    if (tokens[curr].type === 'text' &&\n        curr + 1 < max &&\n        tokens[curr + 1].type === 'text') {\n\n      // collapse two adjacent text nodes\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n    } else {\n      if (curr !== last) { tokens[last] = tokens[curr]; }\n\n      last++;\n    }\n  }\n\n  if (curr !== last) {\n    tokens.length = last;\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/rules_inline/text_collapse.js?");

/***/ }),

/***/ "./node_modules/markdown-it/lib/token.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/token.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("// Token class\n\n\n\n\n/**\n * class Token\n **/\n\n/**\n * new Token(type, tag, nesting)\n *\n * Create new token and fill passed properties.\n **/\nfunction Token(type, tag, nesting) {\n  /**\n   * Token#type -> String\n   *\n   * Type of the token (string, e.g. \"paragraph_open\")\n   **/\n  this.type     = type;\n\n  /**\n   * Token#tag -> String\n   *\n   * html tag name, e.g. \"p\"\n   **/\n  this.tag      = tag;\n\n  /**\n   * Token#attrs -> Array\n   *\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n   **/\n  this.attrs    = null;\n\n  /**\n   * Token#map -> Array\n   *\n   * Source map info. Format: `[ line_begin, line_end ]`\n   **/\n  this.map      = null;\n\n  /**\n   * Token#nesting -> Number\n   *\n   * Level change (number in {-1, 0, 1} set), where:\n   *\n   * -  `1` means the tag is opening\n   * -  `0` means the tag is self-closing\n   * - `-1` means the tag is closing\n   **/\n  this.nesting  = nesting;\n\n  /**\n   * Token#level -> Number\n   *\n   * nesting level, the same as `state.level`\n   **/\n  this.level    = 0;\n\n  /**\n   * Token#children -> Array\n   *\n   * An array of child nodes (inline and img tokens)\n   **/\n  this.children = null;\n\n  /**\n   * Token#content -> String\n   *\n   * In a case of self-closing tag (code, html, fence, etc.),\n   * it has contents of this tag.\n   **/\n  this.content  = '';\n\n  /**\n   * Token#markup -> String\n   *\n   * '*' or '_' for emphasis, fence string for fence, etc.\n   **/\n  this.markup   = '';\n\n  /**\n   * Token#info -> String\n   *\n   * fence infostring\n   **/\n  this.info     = '';\n\n  /**\n   * Token#meta -> Object\n   *\n   * A place for plugins to store an arbitrary data\n   **/\n  this.meta     = null;\n\n  /**\n   * Token#block -> Boolean\n   *\n   * True for block-level tokens, false for inline tokens.\n   * Used in renderer to calculate line breaks\n   **/\n  this.block    = false;\n\n  /**\n   * Token#hidden -> Boolean\n   *\n   * If it's true, ignore this element when rendering. Used for tight lists\n   * to hide paragraphs.\n   **/\n  this.hidden   = false;\n}\n\n\n/**\n * Token.attrIndex(name) -> Number\n *\n * Search attribute index by name.\n **/\nToken.prototype.attrIndex = function attrIndex(name) {\n  var attrs, i, len;\n\n  if (!this.attrs) { return -1; }\n\n  attrs = this.attrs;\n\n  for (i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name) { return i; }\n  }\n  return -1;\n};\n\n\n/**\n * Token.attrPush(attrData)\n *\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\n **/\nToken.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [ attrData ];\n  }\n};\n\n\n/**\n * Token.attrSet(name, value)\n *\n * Set `name` attribute to `value`. Override old value if exists.\n **/\nToken.prototype.attrSet = function attrSet(name, value) {\n  var idx = this.attrIndex(name),\n      attrData = [ name, value ];\n\n  if (idx < 0) {\n    this.attrPush(attrData);\n  } else {\n    this.attrs[idx] = attrData;\n  }\n};\n\n\n/**\n * Token.attrGet(name)\n *\n * Get the value of attribute `name`, or null if it does not exist.\n **/\nToken.prototype.attrGet = function attrGet(name) {\n  var idx = this.attrIndex(name), value = null;\n  if (idx >= 0) {\n    value = this.attrs[idx][1];\n  }\n  return value;\n};\n\n\n/**\n * Token.attrJoin(name, value)\n *\n * Join value to existing attribute via space. Or create new attribute if not\n * exists. Useful to operate with token classes.\n **/\nToken.prototype.attrJoin = function attrJoin(name, value) {\n  var idx = this.attrIndex(name);\n\n  if (idx < 0) {\n    this.attrPush([ name, value ]);\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\n  }\n};\n\n\nmodule.exports = Token;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/markdown-it/lib/token.js?");

/***/ }),

/***/ "./node_modules/mdurl/decode.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/decode.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";
eval("\n\n\n\n/* eslint-disable no-bitwise */\n\nvar decodeCache = {};\n\nfunction getDecodeCache(exclude) {\n  var i, ch, cache = decodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = decodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache;\n}\n\n\n// Decode percent-encoded string.\n//\nfunction decode(string, exclude) {\n  var cache;\n\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  cache = getDecodeCache(exclude);\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n    var i, l, b1, b2, b3, b4, chr,\n        result = '';\n\n    for (i = 0, l = seq.length; i < l; i += 3) {\n      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue;\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 3;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\n\n          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 6;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n\n          i += 9;\n          continue;\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result;\n  });\n}\n\n\ndecode.defaultChars   = ';/?:@&=+$,#';\ndecode.componentChars = '';\n\n\nmodule.exports = decode;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/mdurl/decode.js?");

/***/ }),

/***/ "./node_modules/mdurl/encode.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/encode.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";
eval("\n\n\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\n\nmodule.exports = encode;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/mdurl/encode.js?");

/***/ }),

/***/ "./node_modules/mdurl/format.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/format.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";
eval("\n\n\n\nmodule.exports = function format(url) {\n  var result = '';\n\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n\n  return result;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/mdurl/format.js?");

/***/ }),

/***/ "./node_modules/mdurl/index.js":
/*!*************************************!*\
  !*** ./node_modules/mdurl/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nmodule.exports.encode = __webpack_require__(/*! ./encode */ \"./node_modules/mdurl/encode.js\");\nmodule.exports.decode = __webpack_require__(/*! ./decode */ \"./node_modules/mdurl/decode.js\");\nmodule.exports.format = __webpack_require__(/*! ./format */ \"./node_modules/mdurl/format.js\");\nmodule.exports.parse = __webpack_require__(/*! ./parse */ \"./node_modules/mdurl/parse.js\");\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/mdurl/index.js?");

/***/ }),

/***/ "./node_modules/mdurl/parse.js":
/*!*************************************!*\
  !*** ./node_modules/mdurl/parse.js ***!
  \*************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = [ '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t' ],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = [ '{', '}', '|', '\\\\', '^', '`' ].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = [ '\\'' ].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\n    hostEndingChars = [ '/', '?', '#' ],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    /* eslint-disable no-script-url */\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    };\n    /* eslint-enable no-script-url */\n\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, slashesDenoteHost) {\n  var i, l, lowerProto, hec, slashes,\n      rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    var host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this;\n};\n\nUrl.prototype.parseHost = function(host) {\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nmodule.exports = urlParse;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/mdurl/parse.js?");

/***/ }),

/***/ "./node_modules/mersenne-twister/src/mersenne-twister.js":
/*!***************************************************************!*\
  !*** ./node_modules/mersenne-twister/src/mersenne-twister.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("/*\n  https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace\n  so it's better encapsulated. Now you can have multiple random number generators\n  and they won't stomp all over eachother's state.\n\n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n\n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n\n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_seed(seed)\n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n\tif (seed == undefined) {\n\t\tseed = new Date().getTime();\n\t}\n\n\t/* Period parameters */\n\tthis.N = 624;\n\tthis.M = 397;\n\tthis.MATRIX_A = 0x9908b0df;   /* constant vector a */\n\tthis.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n\tthis.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n\n\tthis.mt = new Array(this.N); /* the array for the state vector */\n\tthis.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n\tif (seed.constructor == Array) {\n\t\tthis.init_by_array(seed, seed.length);\n\t}\n\telse {\n\t\tthis.init_seed(seed);\n\t}\n}\n\n/* initializes mt[N] with a seed */\n/* origin name init_genrand */\nMersenneTwister.prototype.init_seed = function(s) {\n\tthis.mt[0] = s >>> 0;\n\tfor (this.mti=1; this.mti<this.N; this.mti++) {\n\t\tvar s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n\t\tthis.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n\t\t+ this.mti;\n\t\t/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n\t\t/* In the previous versions, MSBs of the seed affect   */\n\t\t/* only MSBs of the array mt[].                        */\n\t\t/* 2002/01/09 modified by Makoto Matsumoto             */\n\t\tthis.mt[this.mti] >>>= 0;\n\t\t/* for >32 bit machines */\n\t}\n}\n\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n\tvar i, j, k;\n\tthis.init_seed(19650218);\n\ti=1; j=0;\n\tk = (this.N>key_length ? this.N : key_length);\n\tfor (; k; k--) {\n\t\tvar s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n\t\tthis.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n\t\t+ init_key[j] + j; /* non linear */\n\t\tthis.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n\t\ti++; j++;\n\t\tif (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n\t\tif (j>=key_length) j=0;\n\t}\n\tfor (k=this.N-1; k; k--) {\n\t\tvar s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n\t\tthis.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n\t\t- i; /* non linear */\n\t\tthis.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n\t\ti++;\n\t\tif (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n\t}\n\n\tthis.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n}\n\n/* generates a random number on [0,0xffffffff]-interval */\n/* origin name genrand_int32 */\nMersenneTwister.prototype.random_int = function() {\n\tvar y;\n\tvar mag01 = new Array(0x0, this.MATRIX_A);\n\t/* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n\tif (this.mti >= this.N) { /* generate N words at one time */\n\t\tvar kk;\n\n\t\tif (this.mti == this.N+1)  /* if init_seed() has not been called, */\n\t\t\tthis.init_seed(5489);  /* a default initial seed is used */\n\n\t\tfor (kk=0;kk<this.N-this.M;kk++) {\n\t\t\ty = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n\t\t\tthis.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n\t\t}\n\t\tfor (;kk<this.N-1;kk++) {\n\t\t\ty = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n\t\t\tthis.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n\t\t}\n\t\ty = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n\t\tthis.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n\t\tthis.mti = 0;\n\t}\n\n\ty = this.mt[this.mti++];\n\n\t/* Tempering */\n\ty ^= (y >>> 11);\n\ty ^= (y << 7) & 0x9d2c5680;\n\ty ^= (y << 15) & 0xefc60000;\n\ty ^= (y >>> 18);\n\n\treturn y >>> 0;\n}\n\n/* generates a random number on [0,0x7fffffff]-interval */\n/* origin name genrand_int31 */\nMersenneTwister.prototype.random_int31 = function() {\n\treturn (this.random_int()>>>1);\n}\n\n/* generates a random number on [0,1]-real-interval */\n/* origin name genrand_real1 */\nMersenneTwister.prototype.random_incl = function() {\n\treturn this.random_int()*(1.0/4294967295.0);\n\t/* divided by 2^32-1 */\n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n\treturn this.random_int()*(1.0/4294967296.0);\n\t/* divided by 2^32 */\n}\n\n/* generates a random number on (0,1)-real-interval */\n/* origin name genrand_real3 */\nMersenneTwister.prototype.random_excl = function() {\n\treturn (this.random_int() + 0.5)*(1.0/4294967296.0);\n\t/* divided by 2^32 */\n}\n\n/* generates a random number on [0,1) with 53-bit resolution*/\n/* origin name genrand_res53 */\nMersenneTwister.prototype.random_long = function() {\n\tvar a=this.random_int()>>>5, b=this.random_int()>>>6;\n\treturn(a*67108864.0+b)*(1.0/9007199254740992.0);\n}\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\nmodule.exports = MersenneTwister;\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/mersenne-twister/src/mersenne-twister.js?");

/***/ }),

/***/ "./node_modules/punycode/punycode.es6.js":
/*!***********************************************!*\
  !*** ./node_modules/punycode/punycode.es6.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"toASCII\": () => (/* binding */ toASCII),\n/* harmony export */   \"toUnicode\": () => (/* binding */ toUnicode),\n/* harmony export */   \"ucs2decode\": () => (/* binding */ ucs2decode),\n/* harmony export */   \"ucs2encode\": () => (/* binding */ ucs2encode)\n/* harmony export */ });\n\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (punycode);\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/punycode/punycode.es6.js?");

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/querystring/decode.js?");

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/querystring/encode.js?");

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/querystring/decode.js\");\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/querystring/encode.js\");\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/querystring/index.js?");

/***/ }),

/***/ "./node_modules/uc.micro/categories/Cc/regex.js":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cc/regex.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports=/[\\0-\\x1F\\x7F-\\x9F]/\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/uc.micro/categories/Cc/regex.js?");

/***/ }),

/***/ "./node_modules/uc.micro/categories/Cf/regex.js":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cf/regex.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports=/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/uc.micro/categories/Cf/regex.js?");

/***/ }),

/***/ "./node_modules/uc.micro/categories/P/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uc.micro/categories/P/regex.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("module.exports=/[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/uc.micro/categories/P/regex.js?");

/***/ }),

/***/ "./node_modules/uc.micro/categories/Z/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uc.micro/categories/Z/regex.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("module.exports=/[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/uc.micro/categories/Z/regex.js?");

/***/ }),

/***/ "./node_modules/uc.micro/index.js":
/*!****************************************!*\
  !*** ./node_modules/uc.micro/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.Any = __webpack_require__(/*! ./properties/Any/regex */ \"./node_modules/uc.micro/properties/Any/regex.js\");\nexports.Cc = __webpack_require__(/*! ./categories/Cc/regex */ \"./node_modules/uc.micro/categories/Cc/regex.js\");\nexports.Cf = __webpack_require__(/*! ./categories/Cf/regex */ \"./node_modules/uc.micro/categories/Cf/regex.js\");\nexports.P = __webpack_require__(/*! ./categories/P/regex */ \"./node_modules/uc.micro/categories/P/regex.js\");\nexports.Z = __webpack_require__(/*! ./categories/Z/regex */ \"./node_modules/uc.micro/categories/Z/regex.js\");\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/uc.micro/index.js?");

/***/ }),

/***/ "./node_modules/uc.micro/properties/Any/regex.js":
/*!*******************************************************!*\
  !*** ./node_modules/uc.micro/properties/Any/regex.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports=/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/uc.micro/properties/Any/regex.js?");

/***/ }),

/***/ "./node_modules/urijs/src/IPv6.js":
/*!****************************************!*\
  !*** ./node_modules/urijs/src/IPv6.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n * IPv6 Support\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if ( true && module.exports) {\n    // Node\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (root) {\n  'use strict';\n\n  /*\n  var _in = \"fe80:0000:0000:0000:0204:61ff:fe9d:f156\";\n  var _out = IPv6.best(_in);\n  var _expected = \"fe80::204:61ff:fe9d:f156\";\n\n  console.log(_in, _out, _expected, _out === _expected);\n  */\n\n  // save current IPv6 variable, if any\n  var _IPv6 = root && root.IPv6;\n\n  function bestPresentation(address) {\n    // based on:\n    // Javascript to test an IPv6 address for proper format, and to\n    // present the \"best text representation\" according to IETF Draft RFC at\n    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04\n    // 8 Feb 2010 Rich Brown, Dartware, LLC\n    // Please feel free to use this code as long as you provide a link to\n    // http://www.intermapper.com\n    // http://intermapper.com/support/tools/IPV6-Validator.aspx\n    // http://download.dartware.com/thirdparty/ipv6validator.js\n\n    var _address = address.toLowerCase();\n    var segments = _address.split(':');\n    var length = segments.length;\n    var total = 8;\n\n    // trim colons (:: or ::a:b:c… or …a:b:c::)\n    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {\n      // must have been ::\n      // remove first two items\n      segments.shift();\n      segments.shift();\n    } else if (segments[0] === '' && segments[1] === '') {\n      // must have been ::xxxx\n      // remove the first item\n      segments.shift();\n    } else if (segments[length - 1] === '' && segments[length - 2] === '') {\n      // must have been xxxx::\n      segments.pop();\n    }\n\n    length = segments.length;\n\n    // adjust total segments for IPv4 trailer\n    if (segments[length - 1].indexOf('.') !== -1) {\n      // found a \".\" which means IPv4\n      total = 7;\n    }\n\n    // fill empty segments them with \"0000\"\n    var pos;\n    for (pos = 0; pos < length; pos++) {\n      if (segments[pos] === '') {\n        break;\n      }\n    }\n\n    if (pos < total) {\n      segments.splice(pos, 1, '0000');\n      while (segments.length < total) {\n        segments.splice(pos, 0, '0000');\n      }\n    }\n\n    // strip leading zeros\n    var _segments;\n    for (var i = 0; i < total; i++) {\n      _segments = segments[i].split('');\n      for (var j = 0; j < 3 ; j++) {\n        if (_segments[0] === '0' && _segments.length > 1) {\n          _segments.splice(0,1);\n        } else {\n          break;\n        }\n      }\n\n      segments[i] = _segments.join('');\n    }\n\n    // find longest sequence of zeroes and coalesce them into one segment\n    var best = -1;\n    var _best = 0;\n    var _current = 0;\n    var current = -1;\n    var inzeroes = false;\n    // i; already declared\n\n    for (i = 0; i < total; i++) {\n      if (inzeroes) {\n        if (segments[i] === '0') {\n          _current += 1;\n        } else {\n          inzeroes = false;\n          if (_current > _best) {\n            best = current;\n            _best = _current;\n          }\n        }\n      } else {\n        if (segments[i] === '0') {\n          inzeroes = true;\n          current = i;\n          _current = 1;\n        }\n      }\n    }\n\n    if (_current > _best) {\n      best = current;\n      _best = _current;\n    }\n\n    if (_best > 1) {\n      segments.splice(best, _best, '');\n    }\n\n    length = segments.length;\n\n    // assemble remaining segments\n    var result = '';\n    if (segments[0] === '')  {\n      result = ':';\n    }\n\n    for (i = 0; i < length; i++) {\n      result += segments[i];\n      if (i === length - 1) {\n        break;\n      }\n\n      result += ':';\n    }\n\n    if (segments[length - 1] === '') {\n      result += ':';\n    }\n\n    return result;\n  }\n\n  function noConflict() {\n    /*jshint validthis: true */\n    if (root.IPv6 === this) {\n      root.IPv6 = _IPv6;\n    }\n\n    return this;\n  }\n\n  return {\n    best: bestPresentation,\n    noConflict: noConflict\n  };\n}));\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/urijs/src/IPv6.js?");

/***/ }),

/***/ "./node_modules/urijs/src/SecondLevelDomains.js":
/*!******************************************************!*\
  !*** ./node_modules/urijs/src/SecondLevelDomains.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n * Second Level Domain (SLD) Support\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if ( true && module.exports) {\n    // Node\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (root) {\n  'use strict';\n\n  // save current SecondLevelDomains variable, if any\n  var _SecondLevelDomains = root && root.SecondLevelDomains;\n\n  var SLD = {\n    // list of known Second Level Domains\n    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains\n    // ----\n    // publicsuffix.org is more current and actually used by a couple of browsers internally.\n    // downside is it also contains domains like \"dyndns.org\" - which is fine for the security\n    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js\n    // ----\n    list: {\n      'ac':' com gov mil net org ',\n      'ae':' ac co gov mil name net org pro sch ',\n      'af':' com edu gov net org ',\n      'al':' com edu gov mil net org ',\n      'ao':' co ed gv it og pb ',\n      'ar':' com edu gob gov int mil net org tur ',\n      'at':' ac co gv or ',\n      'au':' asn com csiro edu gov id net org ',\n      'ba':' co com edu gov mil net org rs unbi unmo unsa untz unze ',\n      'bb':' biz co com edu gov info net org store tv ',\n      'bh':' biz cc com edu gov info net org ',\n      'bn':' com edu gov net org ',\n      'bo':' com edu gob gov int mil net org tv ',\n      'br':' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',\n      'bs':' com edu gov net org ',\n      'bz':' du et om ov rg ',\n      'ca':' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',\n      'ck':' biz co edu gen gov info net org ',\n      'cn':' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',\n      'co':' com edu gov mil net nom org ',\n      'cr':' ac c co ed fi go or sa ',\n      'cy':' ac biz com ekloges gov ltd name net org parliament press pro tm ',\n      'do':' art com edu gob gov mil net org sld web ',\n      'dz':' art asso com edu gov net org pol ',\n      'ec':' com edu fin gov info med mil net org pro ',\n      'eg':' com edu eun gov mil name net org sci ',\n      'er':' com edu gov ind mil net org rochest w ',\n      'es':' com edu gob nom org ',\n      'et':' biz com edu gov info name net org ',\n      'fj':' ac biz com info mil name net org pro ',\n      'fk':' ac co gov net nom org ',\n      'fr':' asso com f gouv nom prd presse tm ',\n      'gg':' co net org ',\n      'gh':' com edu gov mil org ',\n      'gn':' ac com gov net org ',\n      'gr':' com edu gov mil net org ',\n      'gt':' com edu gob ind mil net org ',\n      'gu':' com edu gov net org ',\n      'hk':' com edu gov idv net org ',\n      'hu':' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',\n      'id':' ac co go mil net or sch web ',\n      'il':' ac co gov idf k12 muni net org ',\n      'in':' ac co edu ernet firm gen gov i ind mil net nic org res ',\n      'iq':' com edu gov i mil net org ',\n      'ir':' ac co dnssec gov i id net org sch ',\n      'it':' edu gov ',\n      'je':' co net org ',\n      'jo':' com edu gov mil name net org sch ',\n      'jp':' ac ad co ed go gr lg ne or ',\n      'ke':' ac co go info me mobi ne or sc ',\n      'kh':' com edu gov mil net org per ',\n      'ki':' biz com de edu gov info mob net org tel ',\n      'km':' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',\n      'kn':' edu gov net org ',\n      'kr':' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',\n      'kw':' com edu gov net org ',\n      'ky':' com edu gov net org ',\n      'kz':' com edu gov mil net org ',\n      'lb':' com edu gov net org ',\n      'lk':' assn com edu gov grp hotel int ltd net ngo org sch soc web ',\n      'lr':' com edu gov net org ',\n      'lv':' asn com conf edu gov id mil net org ',\n      'ly':' com edu gov id med net org plc sch ',\n      'ma':' ac co gov m net org press ',\n      'mc':' asso tm ',\n      'me':' ac co edu gov its net org priv ',\n      'mg':' com edu gov mil nom org prd tm ',\n      'mk':' com edu gov inf name net org pro ',\n      'ml':' com edu gov net org presse ',\n      'mn':' edu gov org ',\n      'mo':' com edu gov net org ',\n      'mt':' com edu gov net org ',\n      'mv':' aero biz com coop edu gov info int mil museum name net org pro ',\n      'mw':' ac co com coop edu gov int museum net org ',\n      'mx':' com edu gob net org ',\n      'my':' com edu gov mil name net org sch ',\n      'nf':' arts com firm info net other per rec store web ',\n      'ng':' biz com edu gov mil mobi name net org sch ',\n      'ni':' ac co com edu gob mil net nom org ',\n      'np':' com edu gov mil net org ',\n      'nr':' biz com edu gov info net org ',\n      'om':' ac biz co com edu gov med mil museum net org pro sch ',\n      'pe':' com edu gob mil net nom org sld ',\n      'ph':' com edu gov i mil net ngo org ',\n      'pk':' biz com edu fam gob gok gon gop gos gov net org web ',\n      'pl':' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',\n      'pr':' ac biz com edu est gov info isla name net org pro prof ',\n      'ps':' com edu gov net org plo sec ',\n      'pw':' belau co ed go ne or ',\n      'ro':' arts com firm info nom nt org rec store tm www ',\n      'rs':' ac co edu gov in org ',\n      'sb':' com edu gov net org ',\n      'sc':' com edu gov net org ',\n      'sh':' co com edu gov net nom org ',\n      'sl':' com edu gov net org ',\n      'st':' co com consulado edu embaixada gov mil net org principe saotome store ',\n      'sv':' com edu gob org red ',\n      'sz':' ac co org ',\n      'tr':' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',\n      'tt':' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',\n      'tw':' club com ebiz edu game gov idv mil net org ',\n      'mu':' ac co com gov net or org ',\n      'mz':' ac co edu gov org ',\n      'na':' co com ',\n      'nz':' ac co cri geek gen govt health iwi maori mil net org parliament school ',\n      'pa':' abo ac com edu gob ing med net nom org sld ',\n      'pt':' com edu gov int net nome org publ ',\n      'py':' com edu gov mil net org ',\n      'qa':' com edu gov mil net org ',\n      're':' asso com nom ',\n      'ru':' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',\n      'rw':' ac co com edu gouv gov int mil net ',\n      'sa':' com edu gov med net org pub sch ',\n      'sd':' com edu gov info med net org tv ',\n      'se':' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',\n      'sg':' com edu gov idn net org per ',\n      'sn':' art com edu gouv org perso univ ',\n      'sy':' com edu gov mil net news org ',\n      'th':' ac co go in mi net or ',\n      'tj':' ac biz co com edu go gov info int mil name net nic org test web ',\n      'tn':' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',\n      'tz':' ac co go ne or ',\n      'ua':' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',\n      'ug':' ac co go ne or org sc ',\n      'uk':' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',\n      'us':' dni fed isa kids nsn ',\n      'uy':' com edu gub mil net org ',\n      've':' co com edu gob info mil net org web ',\n      'vi':' co com k12 net org ',\n      'vn':' ac biz com edu gov health info int name net org pro ',\n      'ye':' co com gov ltd me net org plc ',\n      'yu':' ac co edu gov org ',\n      'za':' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',\n      'zm':' ac co com edu gov net org sch ',\n      // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains\n      'com': 'ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ',\n      'net': 'gb jp se uk ',\n      'org': 'ae',\n      'de': 'com '\n    },\n    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost\n    // in both performance and memory footprint. No initialization required.\n    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4\n    // Following methods use lastIndexOf() rather than array.split() in order\n    // to avoid any memory allocations.\n    has: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return false;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {\n        return false;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return false;\n      }\n      return sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') >= 0;\n    },\n    is: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return false;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset >= 0) {\n        return false;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return false;\n      }\n      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;\n    },\n    get: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return null;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {\n        return null;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return null;\n      }\n      if (sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') < 0) {\n        return null;\n      }\n      return domain.slice(sldOffset+1);\n    },\n    noConflict: function(){\n      if (root.SecondLevelDomains === this) {\n        root.SecondLevelDomains = _SecondLevelDomains;\n      }\n      return this;\n    }\n  };\n\n  return SLD;\n}));\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/urijs/src/SecondLevelDomains.js?");

/***/ }),

/***/ "./node_modules/urijs/src/URI.js":
/*!***************************************!*\
  !*** ./node_modules/urijs/src/URI.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if ( true && module.exports) {\n    // Node\n    module.exports = factory(__webpack_require__(/*! ./punycode */ \"./node_modules/urijs/src/punycode.js\"), __webpack_require__(/*! ./IPv6 */ \"./node_modules/urijs/src/IPv6.js\"), __webpack_require__(/*! ./SecondLevelDomains */ \"./node_modules/urijs/src/SecondLevelDomains.js\"));\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./punycode */ \"./node_modules/urijs/src/punycode.js\"), __webpack_require__(/*! ./IPv6 */ \"./node_modules/urijs/src/IPv6.js\"), __webpack_require__(/*! ./SecondLevelDomains */ \"./node_modules/urijs/src/SecondLevelDomains.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (punycode, IPv6, SLD, root) {\n  'use strict';\n  /*global location, escape, unescape */\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URI variable, if any\n  var _URI = root && root.URI;\n\n  function URI(url, base) {\n    var _urlSupplied = arguments.length >= 1;\n    var _baseSupplied = arguments.length >= 2;\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URI)) {\n      if (_urlSupplied) {\n        if (_baseSupplied) {\n          return new URI(url, base);\n        }\n\n        return new URI(url);\n      }\n\n      return new URI();\n    }\n\n    if (url === undefined) {\n      if (_urlSupplied) {\n        throw new TypeError('undefined is not a valid argument for URI');\n      }\n\n      if (typeof location !== 'undefined') {\n        url = location.href + '';\n      } else {\n        url = '';\n      }\n    }\n\n    if (url === null) {\n      if (_urlSupplied) {\n        throw new TypeError('null is not a valid argument for URI');\n      }\n    }\n\n    this.href(url);\n\n    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor\n    if (base !== undefined) {\n      return this.absoluteTo(base);\n    }\n\n    return this;\n  }\n\n  function isInteger(value) {\n    return /^[0-9]+$/.test(value);\n  }\n\n  URI.version = '1.19.11';\n\n  var p = URI.prototype;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function escapeRegEx(string) {\n    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963\n    return string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  }\n\n  function getType(value) {\n    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value\n    if (value === undefined) {\n      return 'Undefined';\n    }\n\n    return String(Object.prototype.toString.call(value)).slice(8, -1);\n  }\n\n  function isArray(obj) {\n    return getType(obj) === 'Array';\n  }\n\n  function filterArrayValues(data, value) {\n    var lookup = {};\n    var i, length;\n\n    if (getType(value) === 'RegExp') {\n      lookup = null;\n    } else if (isArray(value)) {\n      for (i = 0, length = value.length; i < length; i++) {\n        lookup[value[i]] = true;\n      }\n    } else {\n      lookup[value] = true;\n    }\n\n    for (i = 0, length = data.length; i < length; i++) {\n      /*jshint laxbreak: true */\n      var _match = lookup && lookup[data[i]] !== undefined\n        || !lookup && value.test(data[i]);\n      /*jshint laxbreak: false */\n      if (_match) {\n        data.splice(i, 1);\n        length--;\n        i--;\n      }\n    }\n\n    return data;\n  }\n\n  function arrayContains(list, value) {\n    var i, length;\n\n    // value may be string, number, array, regexp\n    if (isArray(value)) {\n      // Note: this can be optimized to O(n) (instead of current O(m * n))\n      for (i = 0, length = value.length; i < length; i++) {\n        if (!arrayContains(list, value[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    var _type = getType(value);\n    for (i = 0, length = list.length; i < length; i++) {\n      if (_type === 'RegExp') {\n        if (typeof list[i] === 'string' && list[i].match(value)) {\n          return true;\n        }\n      } else if (list[i] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function arraysEqual(one, two) {\n    if (!isArray(one) || !isArray(two)) {\n      return false;\n    }\n\n    // arrays can't be equal if they have different amount of content\n    if (one.length !== two.length) {\n      return false;\n    }\n\n    one.sort();\n    two.sort();\n\n    for (var i = 0, l = one.length; i < l; i++) {\n      if (one[i] !== two[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function trimSlashes(text) {\n    var trim_expression = /^\\/+|\\/+$/g;\n    return text.replace(trim_expression, '');\n  }\n\n  URI._parts = function() {\n    return {\n      protocol: null,\n      username: null,\n      password: null,\n      hostname: null,\n      urn: null,\n      port: null,\n      path: null,\n      query: null,\n      fragment: null,\n      // state\n      preventInvalidHostname: URI.preventInvalidHostname,\n      duplicateQueryParameters: URI.duplicateQueryParameters,\n      escapeQuerySpace: URI.escapeQuerySpace\n    };\n  };\n  // state: throw on invalid hostname\n  // see https://github.com/medialize/URI.js/pull/345\n  // and https://github.com/medialize/URI.js/issues/354\n  URI.preventInvalidHostname = false;\n  // state: allow duplicate query parameters (a=1&a=1)\n  URI.duplicateQueryParameters = false;\n  // state: replaces + with %20 (space in query strings)\n  URI.escapeQuerySpace = true;\n  // static properties\n  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;\n  URI.idn_expression = /[^a-z0-9\\._-]/i;\n  URI.punycode_expression = /(xn--)/i;\n  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?\n  URI.ip4_expression = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n  // credits to Rich Brown\n  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096\n  // specification: http://www.ietf.org/rfc/rfc4291.txt\n  URI.ip6_expression = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/;\n  // expression used is \"gruber revised\" (@gruber v2) determined to be the\n  // best solution in a regex-golf we did a couple of ages ago at\n  // * http://mathiasbynens.be/demo/url-regex\n  // * http://rodneyrehm.de/t/url-regex.html\n  URI.find_uri_expression = /\\b((?:[a-z][\\w-]+:(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’]))/ig;\n  URI.findUri = {\n    // valid \"scheme://\" or \"www.\"\n    start: /\\b(?:([a-z][a-z0-9.+-]*:\\/\\/)|www\\.)/gi,\n    // everything up to the next whitespace\n    end: /[\\s\\r\\n]|$/,\n    // trim trailing punctuation captured by end RegExp\n    trim: /[`!()\\[\\]{};:'\".,<>?«»“”„‘’]+$/,\n    // balanced parens inclusion (), [], {}, <>\n    parens: /(\\([^\\)]*\\)|\\[[^\\]]*\\]|\\{[^}]*\\}|<[^>]*>)/g,\n  };\n  URI.leading_whitespace_expression = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/\n  // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n  URI.ascii_tab_whitespace = /[\\u0009\\u000A\\u000D]+/g\n  // http://www.iana.org/assignments/uri-schemes.html\n  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports\n  URI.defaultPorts = {\n    http: '80',\n    https: '443',\n    ftp: '21',\n    gopher: '70',\n    ws: '80',\n    wss: '443'\n  };\n  // list of protocols which always require a hostname\n  URI.hostProtocols = [\n    'http',\n    'https'\n  ];\n\n  // allowed hostname characters according to RFC 3986\n  // ALPHA DIGIT \"-\" \".\" \"_\" \"~\" \"!\" \"$\" \"&\" \"'\" \"(\" \")\" \"*\" \"+\" \",\" \";\" \"=\" %encoded\n  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . - _\n  URI.invalid_hostname_characters = /[^a-zA-Z0-9\\.\\-:_]/;\n  // map DOM Elements to their URI attribute\n  URI.domAttributes = {\n    'a': 'href',\n    'blockquote': 'cite',\n    'link': 'href',\n    'base': 'href',\n    'script': 'src',\n    'form': 'action',\n    'img': 'src',\n    'area': 'href',\n    'iframe': 'src',\n    'embed': 'src',\n    'source': 'src',\n    'track': 'src',\n    'input': 'src', // but only if type=\"image\"\n    'audio': 'src',\n    'video': 'src'\n  };\n  URI.getDomAttribute = function(node) {\n    if (!node || !node.nodeName) {\n      return undefined;\n    }\n\n    var nodeName = node.nodeName.toLowerCase();\n    // <input> should only expose src for type=\"image\"\n    if (nodeName === 'input' && node.type !== 'image') {\n      return undefined;\n    }\n\n    return URI.domAttributes[nodeName];\n  };\n\n  function escapeForDumbFirefox36(value) {\n    // https://github.com/medialize/URI.js/issues/91\n    return escape(value);\n  }\n\n  // encoding / decoding according to RFC3986\n  function strictEncodeURIComponent(string) {\n    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent\n    return encodeURIComponent(string)\n      .replace(/[!'()*]/g, escapeForDumbFirefox36)\n      .replace(/\\*/g, '%2A');\n  }\n  URI.encode = strictEncodeURIComponent;\n  URI.decode = decodeURIComponent;\n  URI.iso8859 = function() {\n    URI.encode = escape;\n    URI.decode = unescape;\n  };\n  URI.unicode = function() {\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = decodeURIComponent;\n  };\n  URI.characters = {\n    pathname: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,\n        map: {\n          // -._~!'()*\n          '%24': '$',\n          '%26': '&',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%3A': ':',\n          '%40': '@'\n        }\n      },\n      decode: {\n        expression: /[\\/\\?#]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23'\n        }\n      }\n    },\n    reserved: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,\n        map: {\n          // gen-delims\n          '%3A': ':',\n          '%2F': '/',\n          '%3F': '?',\n          '%23': '#',\n          '%5B': '[',\n          '%5D': ']',\n          '%40': '@',\n          // sub-delims\n          '%21': '!',\n          '%24': '$',\n          '%26': '&',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '='\n        }\n      }\n    },\n    urnpath: {\n      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable\n      // for usage in a URN. RFC2141 also calls out \"-\", \".\", and \"_\" as acceptable characters, but\n      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also\n      // note that the colon character is not featured in the encoding map; this is because URI.js\n      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it\n      // should not appear unencoded in a segment itself.\n      // See also the note above about RFC3986 and capitalalized hex digits.\n      encode: {\n        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,\n        map: {\n          '%21': '!',\n          '%24': '$',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%40': '@'\n        }\n      },\n      // These characters are the characters called out by RFC2141 as \"reserved\" characters that\n      // should never appear in a URN, plus the colon character (see note above).\n      decode: {\n        expression: /[\\/\\?#:]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23',\n          ':': '%3A'\n        }\n      }\n    }\n  };\n  URI.encodeQuery = function(string, escapeQuerySpace) {\n    var escaped = URI.encode(string + '');\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;\n  };\n  URI.decodeQuery = function(string, escapeQuerySpace) {\n    string += '';\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    try {\n      return URI.decode(escapeQuerySpace ? string.replace(/\\+/g, '%20') : string);\n    } catch(e) {\n      // we're not going to mess with weird encodings,\n      // give up and return the undecoded original string\n      // see https://github.com/medialize/URI.js/issues/87\n      // see https://github.com/medialize/URI.js/issues/92\n      return string;\n    }\n  };\n  // generate encode/decode path functions\n  var _parts = {'encode':'encode', 'decode':'decode'};\n  var _part;\n  var generateAccessor = function(_group, _part) {\n    return function(string) {\n      try {\n        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {\n          return URI.characters[_group][_part].map[c];\n        });\n      } catch (e) {\n        // we're not going to mess with weird encodings,\n        // give up and return the undecoded original string\n        // see https://github.com/medialize/URI.js/issues/87\n        // see https://github.com/medialize/URI.js/issues/92\n        return string;\n      }\n    };\n  };\n\n  for (_part in _parts) {\n    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);\n    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);\n  }\n\n  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {\n    return function(string) {\n      // Why pass in names of functions, rather than the function objects themselves? The\n      // definitions of some functions (but in particular, URI.decode) will occasionally change due\n      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure\n      // that the functions we use here are \"fresh\".\n      var actualCodingFunc;\n      if (!_innerCodingFuncName) {\n        actualCodingFunc = URI[_codingFuncName];\n      } else {\n        actualCodingFunc = function(string) {\n          return URI[_codingFuncName](URI[_innerCodingFuncName](string));\n        };\n      }\n\n      var segments = (string + '').split(_sep);\n\n      for (var i = 0, length = segments.length; i < length; i++) {\n        segments[i] = actualCodingFunc(segments[i]);\n      }\n\n      return segments.join(_sep);\n    };\n  };\n\n  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.\n  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');\n  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');\n  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');\n  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');\n\n  URI.encodeReserved = generateAccessor('reserved', 'encode');\n\n  URI.parse = function(string, parts) {\n    var pos;\n    if (!parts) {\n      parts = {\n        preventInvalidHostname: URI.preventInvalidHostname\n      };\n    }\n\n    string = string.replace(URI.leading_whitespace_expression, '')\n    // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n    string = string.replace(URI.ascii_tab_whitespace, '')\n\n    // [protocol\"://\"[username[\":\"password]\"@\"]hostname[\":\"port]\"/\"?][path][\"?\"querystring][\"#\"fragment]\n\n    // extract fragment\n    pos = string.indexOf('#');\n    if (pos > -1) {\n      // escaping?\n      parts.fragment = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // extract query\n    pos = string.indexOf('?');\n    if (pos > -1) {\n      // escaping?\n      parts.query = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // slashes and backslashes have lost all meaning for the web protocols (https, http, wss, ws)\n    string = string.replace(/^(https?|ftp|wss?)?:+[/\\\\]*/i, '$1://');\n    // slashes and backslashes have lost all meaning for scheme relative URLs\n    string = string.replace(/^[/\\\\]{2,}/i, '//');\n\n    // extract protocol\n    if (string.substring(0, 2) === '//') {\n      // relative-scheme\n      parts.protocol = null;\n      string = string.substring(2);\n      // extract \"user:pass@host:port\"\n      string = URI.parseAuthority(string, parts);\n    } else {\n      pos = string.indexOf(':');\n      if (pos > -1) {\n        parts.protocol = string.substring(0, pos) || null;\n        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {\n          // : may be within the path\n          parts.protocol = undefined;\n        } else if (string.substring(pos + 1, pos + 3).replace(/\\\\/g, '/') === '//') {\n          string = string.substring(pos + 3);\n\n          // extract \"user:pass@host:port\"\n          string = URI.parseAuthority(string, parts);\n        } else {\n          string = string.substring(pos + 1);\n          parts.urn = true;\n        }\n      }\n    }\n\n    // what's left must be the path\n    parts.path = string;\n\n    // and we're done\n    return parts;\n  };\n  URI.parseHost = function(string, parts) {\n    if (!string) {\n      string = '';\n    }\n\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    // https://github.com/medialize/URI.js/pull/233\n    string = string.replace(/\\\\/g, '/');\n\n    // extract host:port\n    var pos = string.indexOf('/');\n    var bracketPos;\n    var t;\n\n    if (pos === -1) {\n      pos = string.length;\n    }\n\n    if (string.charAt(0) === '[') {\n      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6\n      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts\n      // IPv6+port in the format [2001:db8::1]:80 (for the time being)\n      bracketPos = string.indexOf(']');\n      parts.hostname = string.substring(1, bracketPos) || null;\n      parts.port = string.substring(bracketPos + 2, pos) || null;\n      if (parts.port === '/') {\n        parts.port = null;\n      }\n    } else {\n      var firstColon = string.indexOf(':');\n      var firstSlash = string.indexOf('/');\n      var nextColon = string.indexOf(':', firstColon + 1);\n      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {\n        // IPv6 host contains multiple colons - but no port\n        // this notation is actually not allowed by RFC 3986, but we're a liberal parser\n        parts.hostname = string.substring(0, pos) || null;\n        parts.port = null;\n      } else {\n        t = string.substring(0, pos).split(':');\n        parts.hostname = t[0] || null;\n        parts.port = t[1] || null;\n      }\n    }\n\n    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {\n      pos++;\n      string = '/' + string;\n    }\n\n    if (parts.preventInvalidHostname) {\n      URI.ensureValidHostname(parts.hostname, parts.protocol);\n    }\n\n    if (parts.port) {\n      URI.ensureValidPort(parts.port);\n    }\n\n    return string.substring(pos) || '/';\n  };\n  URI.parseAuthority = function(string, parts) {\n    string = URI.parseUserinfo(string, parts);\n    return URI.parseHost(string, parts);\n  };\n  URI.parseUserinfo = function(string, parts) {\n    // extract username:password\n    var _string = string\n    var firstBackSlash = string.indexOf('\\\\');\n    if (firstBackSlash !== -1) {\n      string = string.replace(/\\\\/g, '/')\n    }\n    var firstSlash = string.indexOf('/');\n    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);\n    var t;\n\n    // authority@ must come before /path or \\path\n    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {\n      t = string.substring(0, pos).split(':');\n      parts.username = t[0] ? URI.decode(t[0]) : null;\n      t.shift();\n      parts.password = t[0] ? URI.decode(t.join(':')) : null;\n      string = _string.substring(pos + 1);\n    } else {\n      parts.username = null;\n      parts.password = null;\n    }\n\n    return string;\n  };\n  URI.parseQuery = function(string, escapeQuerySpace) {\n    if (!string) {\n      return {};\n    }\n\n    // throw out the funky business - \"?\"[name\"=\"value\"&\"]+\n    string = string.replace(/&+/g, '&').replace(/^\\?*&*|&+$/g, '');\n\n    if (!string) {\n      return {};\n    }\n\n    var items = {};\n    var splits = string.split('&');\n    var length = splits.length;\n    var v, name, value;\n\n    for (var i = 0; i < length; i++) {\n      v = splits[i].split('=');\n      name = URI.decodeQuery(v.shift(), escapeQuerySpace);\n      // no \"=\" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters\n      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;\n\n      if (name === '__proto__') {\n        // ignore attempt at exploiting JavaScript internals\n        continue;\n      } else if (hasOwn.call(items, name)) {\n        if (typeof items[name] === 'string' || items[name] === null) {\n          items[name] = [items[name]];\n        }\n\n        items[name].push(value);\n      } else {\n        items[name] = value;\n      }\n    }\n\n    return items;\n  };\n\n  URI.build = function(parts) {\n    var t = '';\n    var requireAbsolutePath = false\n\n    if (parts.protocol) {\n      t += parts.protocol + ':';\n    }\n\n    if (!parts.urn && (t || parts.hostname)) {\n      t += '//';\n      requireAbsolutePath = true\n    }\n\n    t += (URI.buildAuthority(parts) || '');\n\n    if (typeof parts.path === 'string') {\n      if (parts.path.charAt(0) !== '/' && requireAbsolutePath) {\n        t += '/';\n      }\n\n      t += parts.path;\n    }\n\n    if (typeof parts.query === 'string' && parts.query) {\n      t += '?' + parts.query;\n    }\n\n    if (typeof parts.fragment === 'string' && parts.fragment) {\n      t += '#' + parts.fragment;\n    }\n    return t;\n  };\n  URI.buildHost = function(parts) {\n    var t = '';\n\n    if (!parts.hostname) {\n      return '';\n    } else if (URI.ip6_expression.test(parts.hostname)) {\n      t += '[' + parts.hostname + ']';\n    } else {\n      t += parts.hostname;\n    }\n\n    if (parts.port) {\n      t += ':' + parts.port;\n    }\n\n    return t;\n  };\n  URI.buildAuthority = function(parts) {\n    return URI.buildUserinfo(parts) + URI.buildHost(parts);\n  };\n  URI.buildUserinfo = function(parts) {\n    var t = '';\n\n    if (parts.username) {\n      t += URI.encode(parts.username);\n    }\n\n    if (parts.password) {\n      t += ':' + URI.encode(parts.password);\n    }\n\n    if (t) {\n      t += '@';\n    }\n\n    return t;\n  };\n  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {\n    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html\n    // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed\n    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!\n    // URI.js treats the query string as being application/x-www-form-urlencoded\n    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type\n\n    var t = '';\n    var unique, key, i, length;\n    for (key in data) {\n      if (key === '__proto__') {\n        // ignore attempt at exploiting JavaScript internals\n        continue;\n      } else if (hasOwn.call(data, key)) {\n        if (isArray(data[key])) {\n          unique = {};\n          for (i = 0, length = data[key].length; i < length; i++) {\n            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {\n              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);\n              if (duplicateQueryParameters !== true) {\n                unique[data[key][i] + ''] = true;\n              }\n            }\n          }\n        } else if (data[key] !== undefined) {\n          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);\n        }\n      }\n    }\n\n    return t.substring(1);\n  };\n  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {\n    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded\n    // don't append \"=\" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization\n    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');\n  };\n\n  URI.addQuery = function(data, name, value) {\n    if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.addQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (data[name] === undefined) {\n        data[name] = value;\n        return;\n      } else if (typeof data[name] === 'string') {\n        data[name] = [data[name]];\n      }\n\n      if (!isArray(value)) {\n        value = [value];\n      }\n\n      data[name] = (data[name] || []).concat(value);\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n  };\n\n  URI.setQuery = function(data, name, value) {\n    if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.setQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      data[name] = value === undefined ? null : value;\n    } else {\n      throw new TypeError('URI.setQuery() accepts an object, string as the name parameter');\n    }\n  };\n\n  URI.removeQuery = function(data, name, value) {\n    var i, length, key;\n\n    if (isArray(name)) {\n      for (i = 0, length = name.length; i < length; i++) {\n        data[name[i]] = undefined;\n      }\n    } else if (getType(name) === 'RegExp') {\n      for (key in data) {\n        if (name.test(key)) {\n          data[key] = undefined;\n        }\n      }\n    } else if (typeof name === 'object') {\n      for (key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.removeQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (value !== undefined) {\n        if (getType(value) === 'RegExp') {\n          if (!isArray(data[name]) && value.test(data[name])) {\n            data[name] = undefined;\n          } else {\n            data[name] = filterArrayValues(data[name], value);\n          }\n        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {\n          data[name] = undefined;\n        } else if (isArray(data[name])) {\n          data[name] = filterArrayValues(data[name], value);\n        }\n      } else {\n        data[name] = undefined;\n      }\n    } else {\n      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');\n    }\n  };\n  URI.hasQuery = function(data, name, value, withinArray) {\n    switch (getType(name)) {\n      case 'String':\n        // Nothing to do here\n        break;\n\n      case 'RegExp':\n        for (var key in data) {\n          if (hasOwn.call(data, key)) {\n            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n\n      case 'Object':\n        for (var _key in name) {\n          if (hasOwn.call(name, _key)) {\n            if (!URI.hasQuery(data, _key, name[_key])) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n\n      default:\n        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');\n    }\n\n    switch (getType(value)) {\n      case 'Undefined':\n        // true if exists (but may be empty)\n        return name in data; // data[name] !== undefined;\n\n      case 'Boolean':\n        // true if exists and non-empty\n        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);\n        return value === _booly;\n\n      case 'Function':\n        // allow complex comparison\n        return !!value(data[name], name, data);\n\n      case 'Array':\n        if (!isArray(data[name])) {\n          return false;\n        }\n\n        var op = withinArray ? arrayContains : arraysEqual;\n        return op(data[name], value);\n\n      case 'RegExp':\n        if (!isArray(data[name])) {\n          return Boolean(data[name] && data[name].match(value));\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      case 'Number':\n        value = String(value);\n        /* falls through */\n      case 'String':\n        if (!isArray(data[name])) {\n          return data[name] === value;\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      default:\n        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');\n    }\n  };\n\n\n  URI.joinPaths = function() {\n    var input = [];\n    var segments = [];\n    var nonEmptySegments = 0;\n\n    for (var i = 0; i < arguments.length; i++) {\n      var url = new URI(arguments[i]);\n      input.push(url);\n      var _segments = url.segment();\n      for (var s = 0; s < _segments.length; s++) {\n        if (typeof _segments[s] === 'string') {\n          segments.push(_segments[s]);\n        }\n\n        if (_segments[s]) {\n          nonEmptySegments++;\n        }\n      }\n    }\n\n    if (!segments.length || !nonEmptySegments) {\n      return new URI('');\n    }\n\n    var uri = new URI('').segment(segments);\n\n    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {\n      uri.path('/' + uri.path());\n    }\n\n    return uri.normalize();\n  };\n\n  URI.commonPath = function(one, two) {\n    var length = Math.min(one.length, two.length);\n    var pos;\n\n    // find first non-matching character\n    for (pos = 0; pos < length; pos++) {\n      if (one.charAt(pos) !== two.charAt(pos)) {\n        pos--;\n        break;\n      }\n    }\n\n    if (pos < 1) {\n      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';\n    }\n\n    // revert to last /\n    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {\n      pos = one.substring(0, pos).lastIndexOf('/');\n    }\n\n    return one.substring(0, pos + 1);\n  };\n\n  URI.withinString = function(string, callback, options) {\n    options || (options = {});\n    var _start = options.start || URI.findUri.start;\n    var _end = options.end || URI.findUri.end;\n    var _trim = options.trim || URI.findUri.trim;\n    var _parens = options.parens || URI.findUri.parens;\n    var _attributeOpen = /[a-z0-9-]=[\"']?$/i;\n\n    _start.lastIndex = 0;\n    while (true) {\n      var match = _start.exec(string);\n      if (!match) {\n        break;\n      }\n\n      var start = match.index;\n      if (options.ignoreHtml) {\n        // attribut(e=[\"']?$)\n        var attributeOpen = string.slice(Math.max(start - 3, 0), start);\n        if (attributeOpen && _attributeOpen.test(attributeOpen)) {\n          continue;\n        }\n      }\n\n      var end = start + string.slice(start).search(_end);\n      var slice = string.slice(start, end);\n      // make sure we include well balanced parens\n      var parensEnd = -1;\n      while (true) {\n        var parensMatch = _parens.exec(slice);\n        if (!parensMatch) {\n          break;\n        }\n\n        var parensMatchEnd = parensMatch.index + parensMatch[0].length;\n        parensEnd = Math.max(parensEnd, parensMatchEnd);\n      }\n\n      if (parensEnd > -1) {\n        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, '');\n      } else {\n        slice = slice.replace(_trim, '');\n      }\n\n      if (slice.length <= match[0].length) {\n        // the extract only contains the starting marker of a URI,\n        // e.g. \"www\" or \"http://\"\n        continue;\n      }\n\n      if (options.ignore && options.ignore.test(slice)) {\n        continue;\n      }\n\n      end = start + slice.length;\n      var result = callback(slice, start, end, string);\n      if (result === undefined) {\n        _start.lastIndex = end;\n        continue;\n      }\n\n      result = String(result);\n      string = string.slice(0, start) + result + string.slice(end);\n      _start.lastIndex = start + result.length;\n    }\n\n    _start.lastIndex = 0;\n    return string;\n  };\n\n  URI.ensureValidHostname = function(v, protocol) {\n    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)\n    // they are not part of DNS and therefore ignored by URI.js\n\n    var hasHostname = !!v; // not null and not an empty string\n    var hasProtocol = !!protocol;\n    var rejectEmptyHostname = false;\n\n    if (hasProtocol) {\n      rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);\n    }\n\n    if (rejectEmptyHostname && !hasHostname) {\n      throw new TypeError('Hostname cannot be empty, if protocol is ' + protocol);\n    } else if (v && v.match(URI.invalid_hostname_characters)) {\n      // test punycode\n      if (!punycode) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');\n      }\n      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-:_]');\n      }\n    }\n  };\n\n  URI.ensureValidPort = function (v) {\n    if (!v) {\n      return;\n    }\n\n    var port = Number(v);\n    if (isInteger(port) && (port > 0) && (port < 65536)) {\n      return;\n    }\n\n    throw new TypeError('Port \"' + v + '\" is not a valid port');\n  };\n\n  // noConflict\n  URI.noConflict = function(removeAll) {\n    if (removeAll) {\n      var unconflicted = {\n        URI: this.noConflict()\n      };\n\n      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {\n        unconflicted.URITemplate = root.URITemplate.noConflict();\n      }\n\n      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {\n        unconflicted.IPv6 = root.IPv6.noConflict();\n      }\n\n      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {\n        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();\n      }\n\n      return unconflicted;\n    } else if (root.URI === this) {\n      root.URI = _URI;\n    }\n\n    return this;\n  };\n\n  p.build = function(deferBuild) {\n    if (deferBuild === true) {\n      this._deferred_build = true;\n    } else if (deferBuild === undefined || this._deferred_build) {\n      this._string = URI.build(this._parts);\n      this._deferred_build = false;\n    }\n\n    return this;\n  };\n\n  p.clone = function() {\n    return new URI(this);\n  };\n\n  p.valueOf = p.toString = function() {\n    return this.build(false)._string;\n  };\n\n\n  function generateSimpleAccessor(_part){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        this._parts[_part] = v || null;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  function generatePrefixAccessor(_part, _key){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        if (v !== null) {\n          v = v + '';\n          if (v.charAt(0) === _key) {\n            v = v.substring(1);\n          }\n        }\n\n        this._parts[_part] = v;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  p.protocol = generateSimpleAccessor('protocol');\n  p.username = generateSimpleAccessor('username');\n  p.password = generateSimpleAccessor('password');\n  p.hostname = generateSimpleAccessor('hostname');\n  p.port = generateSimpleAccessor('port');\n  p.query = generatePrefixAccessor('query', '?');\n  p.fragment = generatePrefixAccessor('fragment', '#');\n\n  p.search = function(v, build) {\n    var t = this.query(v, build);\n    return typeof t === 'string' && t.length ? ('?' + t) : t;\n  };\n  p.hash = function(v, build) {\n    var t = this.fragment(v, build);\n    return typeof t === 'string' && t.length ? ('#' + t) : t;\n  };\n\n  p.pathname = function(v, build) {\n    if (v === undefined || v === true) {\n      var res = this._parts.path || (this._parts.hostname ? '/' : '');\n      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;\n    } else {\n      if (this._parts.urn) {\n        this._parts.path = v ? URI.recodeUrnPath(v) : '';\n      } else {\n        this._parts.path = v ? URI.recodePath(v) : '/';\n      }\n      this.build(!build);\n      return this;\n    }\n  };\n  p.path = p.pathname;\n  p.href = function(href, build) {\n    var key;\n\n    if (href === undefined) {\n      return this.toString();\n    }\n\n    this._string = '';\n    this._parts = URI._parts();\n\n    var _URI = href instanceof URI;\n    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);\n    if (href.nodeName) {\n      var attribute = URI.getDomAttribute(href);\n      href = href[attribute] || '';\n      _object = false;\n    }\n\n    // window.location is reported to be an object, but it's not the sort\n    // of object we're looking for:\n    // * location.protocol ends with a colon\n    // * location.query != object.search\n    // * location.hash != object.fragment\n    // simply serializing the unknown object should do the trick\n    // (for location, not for everything...)\n    if (!_URI && _object && href.pathname !== undefined) {\n      href = href.toString();\n    }\n\n    if (typeof href === 'string' || href instanceof String) {\n      this._parts = URI.parse(String(href), this._parts);\n    } else if (_URI || _object) {\n      var src = _URI ? href._parts : href;\n      for (key in src) {\n        if (key === 'query') { continue; }\n        if (hasOwn.call(this._parts, key)) {\n          this._parts[key] = src[key];\n        }\n      }\n      if (src.query) {\n        this.query(src.query, false);\n      }\n    } else {\n      throw new TypeError('invalid input');\n    }\n\n    this.build(!build);\n    return this;\n  };\n\n  // identification accessors\n  p.is = function(what) {\n    var ip = false;\n    var ip4 = false;\n    var ip6 = false;\n    var name = false;\n    var sld = false;\n    var idn = false;\n    var punycode = false;\n    var relative = !this._parts.urn;\n\n    if (this._parts.hostname) {\n      relative = false;\n      ip4 = URI.ip4_expression.test(this._parts.hostname);\n      ip6 = URI.ip6_expression.test(this._parts.hostname);\n      ip = ip4 || ip6;\n      name = !ip;\n      sld = name && SLD && SLD.has(this._parts.hostname);\n      idn = name && URI.idn_expression.test(this._parts.hostname);\n      punycode = name && URI.punycode_expression.test(this._parts.hostname);\n    }\n\n    switch (what.toLowerCase()) {\n      case 'relative':\n        return relative;\n\n      case 'absolute':\n        return !relative;\n\n      // hostname identification\n      case 'domain':\n      case 'name':\n        return name;\n\n      case 'sld':\n        return sld;\n\n      case 'ip':\n        return ip;\n\n      case 'ip4':\n      case 'ipv4':\n      case 'inet4':\n        return ip4;\n\n      case 'ip6':\n      case 'ipv6':\n      case 'inet6':\n        return ip6;\n\n      case 'idn':\n        return idn;\n\n      case 'url':\n        return !this._parts.urn;\n\n      case 'urn':\n        return !!this._parts.urn;\n\n      case 'punycode':\n        return punycode;\n    }\n\n    return null;\n  };\n\n  // component specific input validation\n  var _protocol = p.protocol;\n  var _port = p.port;\n  var _hostname = p.hostname;\n\n  p.protocol = function(v, build) {\n    if (v) {\n      // accept trailing ://\n      v = v.replace(/:(\\/\\/)?$/, '');\n\n      if (!v.match(URI.protocol_expression)) {\n        throw new TypeError('Protocol \"' + v + '\" contains characters other than [A-Z0-9.+-] or doesn\\'t start with [A-Z]');\n      }\n    }\n\n    return _protocol.call(this, v, build);\n  };\n  p.scheme = p.protocol;\n  p.port = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      if (v === 0) {\n        v = null;\n      }\n\n      if (v) {\n        v += '';\n        if (v.charAt(0) === ':') {\n          v = v.substring(1);\n        }\n\n        URI.ensureValidPort(v);\n      }\n    }\n    return _port.call(this, v, build);\n  };\n  p.hostname = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      var x = { preventInvalidHostname: this._parts.preventInvalidHostname };\n      var res = URI.parseHost(v, x);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      v = x.hostname;\n      if (this._parts.preventInvalidHostname) {\n        URI.ensureValidHostname(v, this._parts.protocol);\n      }\n    }\n\n    return _hostname.call(this, v, build);\n  };\n\n  // compound accessors\n  p.origin = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      var protocol = this.protocol();\n      var authority = this.authority();\n      if (!authority) {\n        return '';\n      }\n\n      return (protocol ? protocol + '://' : '') + this.authority();\n    } else {\n      var origin = URI(v);\n      this\n        .protocol(origin.protocol())\n        .authority(origin.authority())\n        .build(!build);\n      return this;\n    }\n  };\n  p.host = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildHost(this._parts) : '';\n    } else {\n      var res = URI.parseHost(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.authority = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';\n    } else {\n      var res = URI.parseAuthority(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.userinfo = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      var t = URI.buildUserinfo(this._parts);\n      return t ? t.substring(0, t.length -1) : t;\n    } else {\n      if (v[v.length-1] !== '@') {\n        v += '@';\n      }\n\n      URI.parseUserinfo(v, this._parts);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.resource = function(v, build) {\n    var parts;\n\n    if (v === undefined) {\n      return this.path() + this.search() + this.hash();\n    }\n\n    parts = URI.parse(v);\n    this._parts.path = parts.path;\n    this._parts.query = parts.query;\n    this._parts.fragment = parts.fragment;\n    this.build(!build);\n    return this;\n  };\n\n  // fraction accessors\n  p.subdomain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    // convenience, return \"www\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // grab domain and add another segment\n      var end = this._parts.hostname.length - this.domain().length - 1;\n      return this._parts.hostname.substring(0, end) || '';\n    } else {\n      var e = this._parts.hostname.length - this.domain().length;\n      var sub = this._parts.hostname.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(sub));\n\n      if (v && v.charAt(v.length - 1) !== '.') {\n        v += '.';\n      }\n\n      if (v.indexOf(':') !== -1) {\n        throw new TypeError('Domains cannot contain colons');\n      }\n\n      if (v) {\n        URI.ensureValidHostname(v, this._parts.protocol);\n      }\n\n      this._parts.hostname = this._parts.hostname.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.domain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // convenience, return \"example.org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // if hostname consists of 1 or 2 segments, it must be the domain\n      var t = this._parts.hostname.match(/\\./g);\n      if (t && t.length < 2) {\n        return this._parts.hostname;\n      }\n\n      // grab tld and add another segment\n      var end = this._parts.hostname.length - this.tld(build).length - 1;\n      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;\n      return this._parts.hostname.substring(end) || '';\n    } else {\n      if (!v) {\n        throw new TypeError('cannot set domain empty');\n      }\n\n      if (v.indexOf(':') !== -1) {\n        throw new TypeError('Domains cannot contain colons');\n      }\n\n      URI.ensureValidHostname(v, this._parts.protocol);\n\n      if (!this._parts.hostname || this.is('IP')) {\n        this._parts.hostname = v;\n      } else {\n        var replace = new RegExp(escapeRegEx(this.domain()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.tld = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // return \"org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      var pos = this._parts.hostname.lastIndexOf('.');\n      var tld = this._parts.hostname.substring(pos + 1);\n\n      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {\n        return SLD.get(this._parts.hostname) || tld;\n      }\n\n      return tld;\n    } else {\n      var replace;\n\n      if (!v) {\n        throw new TypeError('cannot set TLD empty');\n      } else if (v.match(/[^a-zA-Z0-9-]/)) {\n        if (SLD && SLD.is(v)) {\n          replace = new RegExp(escapeRegEx(this.tld()) + '$');\n          this._parts.hostname = this._parts.hostname.replace(replace, v);\n        } else {\n          throw new TypeError('TLD \"' + v + '\" contains characters other than [A-Z0-9]');\n        }\n      } else if (!this._parts.hostname || this.is('IP')) {\n        throw new ReferenceError('cannot set TLD on non-domain host');\n      } else {\n        replace = new RegExp(escapeRegEx(this.tld()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.directory = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path && !this._parts.hostname) {\n        return '';\n      }\n\n      if (this._parts.path === '/') {\n        return '/';\n      }\n\n      var end = this._parts.path.length - this.filename().length - 1;\n      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');\n\n      return v ? URI.decodePath(res) : res;\n\n    } else {\n      var e = this._parts.path.length - this.filename().length;\n      var directory = this._parts.path.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(directory));\n\n      // fully qualifier directories begin with a slash\n      if (!this.is('relative')) {\n        if (!v) {\n          v = '/';\n        }\n\n        if (v.charAt(0) !== '/') {\n          v = '/' + v;\n        }\n      }\n\n      // directories always end with a slash\n      if (v && v.charAt(v.length - 1) !== '/') {\n        v += '/';\n      }\n\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.filename = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v !== 'string') {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var pos = this._parts.path.lastIndexOf('/');\n      var res = this._parts.path.substring(pos+1);\n\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      var mutatedDirectory = false;\n\n      if (v.charAt(0) === '/') {\n        v = v.substring(1);\n      }\n\n      if (v.match(/\\.?\\//)) {\n        mutatedDirectory = true;\n      }\n\n      var replace = new RegExp(escapeRegEx(this.filename()) + '$');\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n\n      if (mutatedDirectory) {\n        this.normalizePath(build);\n      } else {\n        this.build(!build);\n      }\n\n      return this;\n    }\n  };\n  p.suffix = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var filename = this.filename();\n      var pos = filename.lastIndexOf('.');\n      var s, res;\n\n      if (pos === -1) {\n        return '';\n      }\n\n      // suffix may only contain alnum characters (yup, I made this up.)\n      s = filename.substring(pos+1);\n      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      if (v.charAt(0) === '.') {\n        v = v.substring(1);\n      }\n\n      var suffix = this.suffix();\n      var replace;\n\n      if (!suffix) {\n        if (!v) {\n          return this;\n        }\n\n        this._parts.path += '.' + URI.recodePath(v);\n      } else if (!v) {\n        replace = new RegExp(escapeRegEx('.' + suffix) + '$');\n      } else {\n        replace = new RegExp(escapeRegEx(suffix) + '$');\n      }\n\n      if (replace) {\n        v = URI.recodePath(v);\n        this._parts.path = this._parts.path.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.segment = function(segment, v, build) {\n    var separator = this._parts.urn ? ':' : '/';\n    var path = this.path();\n    var absolute = path.substring(0, 1) === '/';\n    var segments = path.split(separator);\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      throw new Error('Bad segment \"' + segment + '\", must be 0-based integer');\n    }\n\n    if (absolute) {\n      segments.shift();\n    }\n\n    if (segment < 0) {\n      // allow negative indexes to address from the end\n      segment = Math.max(segments.length + segment, 0);\n    }\n\n    if (v === undefined) {\n      /*jshint laxbreak: true */\n      return segment === undefined\n        ? segments\n        : segments[segment];\n      /*jshint laxbreak: false */\n    } else if (segment === null || segments[segment] === undefined) {\n      if (isArray(v)) {\n        segments = [];\n        // collapse empty elements within array\n        for (var i=0, l=v.length; i < l; i++) {\n          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {\n            continue;\n          }\n\n          if (segments.length && !segments[segments.length -1].length) {\n            segments.pop();\n          }\n\n          segments.push(trimSlashes(v[i]));\n        }\n      } else if (v || typeof v === 'string') {\n        v = trimSlashes(v);\n        if (segments[segments.length -1] === '') {\n          // empty trailing elements have to be overwritten\n          // to prevent results such as /foo//bar\n          segments[segments.length -1] = v;\n        } else {\n          segments.push(v);\n        }\n      }\n    } else {\n      if (v) {\n        segments[segment] = trimSlashes(v);\n      } else {\n        segments.splice(segment, 1);\n      }\n    }\n\n    if (absolute) {\n      segments.unshift('');\n    }\n\n    return this.path(segments.join(separator), build);\n  };\n  p.segmentCoded = function(segment, v, build) {\n    var segments, i, l;\n\n    if (typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (v === undefined) {\n      segments = this.segment(segment, v, build);\n      if (!isArray(segments)) {\n        segments = segments !== undefined ? URI.decode(segments) : undefined;\n      } else {\n        for (i = 0, l = segments.length; i < l; i++) {\n          segments[i] = URI.decode(segments[i]);\n        }\n      }\n\n      return segments;\n    }\n\n    if (!isArray(v)) {\n      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;\n    } else {\n      for (i = 0, l = v.length; i < l; i++) {\n        v[i] = URI.encode(v[i]);\n      }\n    }\n\n    return this.segment(segment, v, build);\n  };\n\n  // mutating query string\n  var q = p.query;\n  p.query = function(v, build) {\n    if (v === true) {\n      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    } else if (typeof v === 'function') {\n      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n      var result = v.call(this, data);\n      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else if (v !== undefined && typeof v !== 'string') {\n      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else {\n      return q.call(this, v, build);\n    }\n  };\n  p.setQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n\n    if (typeof name === 'string' || name instanceof String) {\n      data[name] = value !== undefined ? value : null;\n    } else if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          data[key] = name[key];\n        }\n      }\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.addQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.addQuery(data, name, value === undefined ? null : value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.removeQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.removeQuery(data, name, value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.hasQuery = function(name, value, withinArray) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    return URI.hasQuery(data, name, value, withinArray);\n  };\n  p.setSearch = p.setQuery;\n  p.addSearch = p.addQuery;\n  p.removeSearch = p.removeQuery;\n  p.hasSearch = p.hasQuery;\n\n  // sanitizing URLs\n  p.normalize = function() {\n    if (this._parts.urn) {\n      return this\n        .normalizeProtocol(false)\n        .normalizePath(false)\n        .normalizeQuery(false)\n        .normalizeFragment(false)\n        .build();\n    }\n\n    return this\n      .normalizeProtocol(false)\n      .normalizeHostname(false)\n      .normalizePort(false)\n      .normalizePath(false)\n      .normalizeQuery(false)\n      .normalizeFragment(false)\n      .build();\n  };\n  p.normalizeProtocol = function(build) {\n    if (typeof this._parts.protocol === 'string') {\n      this._parts.protocol = this._parts.protocol.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeHostname = function(build) {\n    if (this._parts.hostname) {\n      if (this.is('IDN') && punycode) {\n        this._parts.hostname = punycode.toASCII(this._parts.hostname);\n      } else if (this.is('IPv6') && IPv6) {\n        this._parts.hostname = IPv6.best(this._parts.hostname);\n      }\n\n      this._parts.hostname = this._parts.hostname.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePort = function(build) {\n    // remove port of it's the protocol's default\n    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {\n      this._parts.port = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePath = function(build) {\n    var _path = this._parts.path;\n    if (!_path) {\n      return this;\n    }\n\n    if (this._parts.urn) {\n      this._parts.path = URI.recodeUrnPath(this._parts.path);\n      this.build(!build);\n      return this;\n    }\n\n    if (this._parts.path === '/') {\n      return this;\n    }\n\n    _path = URI.recodePath(_path);\n\n    var _was_relative;\n    var _leadingParents = '';\n    var _parent, _pos;\n\n    // handle relative paths\n    if (_path.charAt(0) !== '/') {\n      _was_relative = true;\n      _path = '/' + _path;\n    }\n\n    // handle relative files (as opposed to directories)\n    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {\n      _path += '/';\n    }\n\n    // resolve simples\n    _path = _path\n      .replace(/(\\/(\\.\\/)+)|(\\/\\.$)/g, '/')\n      .replace(/\\/{2,}/g, '/');\n\n    // remember leading parents\n    if (_was_relative) {\n      _leadingParents = _path.substring(1).match(/^(\\.\\.\\/)+/) || '';\n      if (_leadingParents) {\n        _leadingParents = _leadingParents[0];\n      }\n    }\n\n    // resolve parents\n    while (true) {\n      _parent = _path.search(/\\/\\.\\.(\\/|$)/);\n      if (_parent === -1) {\n        // no more ../ to resolve\n        break;\n      } else if (_parent === 0) {\n        // top level cannot be relative, skip it\n        _path = _path.substring(3);\n        continue;\n      }\n\n      _pos = _path.substring(0, _parent).lastIndexOf('/');\n      if (_pos === -1) {\n        _pos = _parent;\n      }\n      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);\n    }\n\n    // revert to relative\n    if (_was_relative && this.is('relative')) {\n      _path = _leadingParents + _path.substring(1);\n    }\n\n    this._parts.path = _path;\n    this.build(!build);\n    return this;\n  };\n  p.normalizePathname = p.normalizePath;\n  p.normalizeQuery = function(build) {\n    if (typeof this._parts.query === 'string') {\n      if (!this._parts.query.length) {\n        this._parts.query = null;\n      } else {\n        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));\n      }\n\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeFragment = function(build) {\n    if (!this._parts.fragment) {\n      this._parts.fragment = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeSearch = p.normalizeQuery;\n  p.normalizeHash = p.normalizeFragment;\n\n  p.iso8859 = function() {\n    // expect unicode input, iso8859 output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = escape;\n    URI.decode = decodeURIComponent;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.unicode = function() {\n    // expect iso8859 input, unicode output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = unescape;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.readable = function() {\n    var uri = this.clone();\n    // removing username, password, because they shouldn't be displayed according to RFC 3986\n    uri.username('').password('').normalize();\n    var t = '';\n    if (uri._parts.protocol) {\n      t += uri._parts.protocol + '://';\n    }\n\n    if (uri._parts.hostname) {\n      if (uri.is('punycode') && punycode) {\n        t += punycode.toUnicode(uri._parts.hostname);\n        if (uri._parts.port) {\n          t += ':' + uri._parts.port;\n        }\n      } else {\n        t += uri.host();\n      }\n    }\n\n    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {\n      t += '/';\n    }\n\n    t += uri.path(true);\n    if (uri._parts.query) {\n      var q = '';\n      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {\n        var kv = (qp[i] || '').split('=');\n        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)\n          .replace(/&/g, '%26');\n\n        if (kv[1] !== undefined) {\n          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)\n            .replace(/&/g, '%26');\n        }\n      }\n      t += '?' + q.substring(1);\n    }\n\n    t += URI.decodeQuery(uri.hash(), true);\n    return t;\n  };\n\n  // resolving relative and absolute URLs\n  p.absoluteTo = function(base) {\n    var resolved = this.clone();\n    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];\n    var basedir, i, p;\n\n    if (this._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    if (!(base instanceof URI)) {\n      base = new URI(base);\n    }\n\n    if (resolved._parts.protocol) {\n      // Directly returns even if this._parts.hostname is empty.\n      return resolved;\n    } else {\n      resolved._parts.protocol = base._parts.protocol;\n    }\n\n    if (this._parts.hostname) {\n      return resolved;\n    }\n\n    for (i = 0; (p = properties[i]); i++) {\n      resolved._parts[p] = base._parts[p];\n    }\n\n    if (!resolved._parts.path) {\n      resolved._parts.path = base._parts.path;\n      if (!resolved._parts.query) {\n        resolved._parts.query = base._parts.query;\n      }\n    } else {\n      if (resolved._parts.path.substring(-2) === '..') {\n        resolved._parts.path += '/';\n      }\n\n      if (resolved.path().charAt(0) !== '/') {\n        basedir = base.directory();\n        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';\n        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;\n        resolved.normalizePath();\n      }\n    }\n\n    resolved.build();\n    return resolved;\n  };\n  p.relativeTo = function(base) {\n    var relative = this.clone().normalize();\n    var relativeParts, baseParts, common, relativePath, basePath;\n\n    if (relative._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    base = new URI(base).normalize();\n    relativeParts = relative._parts;\n    baseParts = base._parts;\n    relativePath = relative.path();\n    basePath = base.path();\n\n    if (relativePath.charAt(0) !== '/') {\n      throw new Error('URI is already relative');\n    }\n\n    if (basePath.charAt(0) !== '/') {\n      throw new Error('Cannot calculate a URI relative to another relative URI');\n    }\n\n    if (relativeParts.protocol === baseParts.protocol) {\n      relativeParts.protocol = null;\n    }\n\n    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {\n      return relative.build();\n    }\n\n    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {\n      return relative.build();\n    }\n\n    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {\n      relativeParts.hostname = null;\n      relativeParts.port = null;\n    } else {\n      return relative.build();\n    }\n\n    if (relativePath === basePath) {\n      relativeParts.path = '';\n      return relative.build();\n    }\n\n    // determine common sub path\n    common = URI.commonPath(relativePath, basePath);\n\n    // If the paths have nothing in common, return a relative URL with the absolute path.\n    if (!common) {\n      return relative.build();\n    }\n\n    var parents = baseParts.path\n      .substring(common.length)\n      .replace(/[^\\/]*$/, '')\n      .replace(/.*?\\//g, '../');\n\n    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';\n\n    return relative.build();\n  };\n\n  // comparing URIs\n  p.equals = function(uri) {\n    var one = this.clone();\n    var two = new URI(uri);\n    var one_map = {};\n    var two_map = {};\n    var checked = {};\n    var one_query, two_query, key;\n\n    one.normalize();\n    two.normalize();\n\n    // exact match\n    if (one.toString() === two.toString()) {\n      return true;\n    }\n\n    // extract query string\n    one_query = one.query();\n    two_query = two.query();\n    one.query('');\n    two.query('');\n\n    // definitely not equal if not even non-query parts match\n    if (one.toString() !== two.toString()) {\n      return false;\n    }\n\n    // query parameters have the same length, even if they're permuted\n    if (one_query.length !== two_query.length) {\n      return false;\n    }\n\n    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);\n    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);\n\n    for (key in one_map) {\n      if (hasOwn.call(one_map, key)) {\n        if (!isArray(one_map[key])) {\n          if (one_map[key] !== two_map[key]) {\n            return false;\n          }\n        } else if (!arraysEqual(one_map[key], two_map[key])) {\n          return false;\n        }\n\n        checked[key] = true;\n      }\n    }\n\n    for (key in two_map) {\n      if (hasOwn.call(two_map, key)) {\n        if (!checked[key]) {\n          // two contains a parameter not present in one\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // state\n  p.preventInvalidHostname = function(v) {\n    this._parts.preventInvalidHostname = !!v;\n    return this;\n  };\n\n  p.duplicateQueryParameters = function(v) {\n    this._parts.duplicateQueryParameters = !!v;\n    return this;\n  };\n\n  p.escapeQuerySpace = function(v) {\n    this._parts.escapeQuerySpace = !!v;\n    return this;\n  };\n\n  return URI;\n}));\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/urijs/src/URI.js?");

/***/ }),

/***/ "./node_modules/urijs/src/punycode.js":
/*!********************************************!*\
  !*** ./node_modules/urijs/src/punycode.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/urijs/src/punycode.js?");

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/url/node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/url/node_modules/punycode/punycode.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring/index.js\");\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/url/url.js?");

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/url/util.js?");

/***/ }),

/***/ "./node_modules/entities/maps/entities.json":
/*!**************************************************!*\
  !*** ./node_modules/entities/maps/entities.json ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"\\'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}');\n\n//# sourceURL=webpack://cesium-navigation-es6/./node_modules/entities/maps/entities.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "cesium-navigation-es6:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 				script.type = "text/javascript";
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			};
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "./";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"CesiumNavigation": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkcesium_navigation_es6"] = self["webpackChunkcesium_navigation_es6"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./viewerCesiumNavigationMixin.js");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});